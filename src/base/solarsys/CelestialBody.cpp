//$Id$
//------------------------------------------------------------------------------
//                                  CelestialBody
//------------------------------------------------------------------------------
// GMAT: General Mission Analysis Tool.
//
// Copyright (c) 2002-2011 United States Government as represented by the
// Administrator of The National Aeronautics and Space Administration.
// All Other Rights Reserved.
//
// Author: Wendy C. Shoan
// Created: 2004/01/28
//
/**
 * Implementation of the CelestialBody class.
 *
 * @note This is an abstract class.
 *
 * @note Class (initial shell only) automatically generated by Dev-C++ New
 *       Class wizard (heavily modified after that)
 */
//------------------------------------------------------------------------------


#include <iostream>
#include <fstream>
#include <sstream>
#include <iomanip>
#include "gmatdefs.hpp"
#include "SpacePoint.hpp"
#include "CelestialBody.hpp"
#include "PlanetaryEphem.hpp"
#include "SolarSystem.hpp"
#include "SolarSystemException.hpp"
#include "PlanetaryEphemException.hpp"
#include "UtilityException.hpp"
#include "FileManager.hpp"
#include "Rvector3.hpp"
#include "Rvector6.hpp"
#include "Rmatrix.hpp"
#include "RealUtilities.hpp"
#include "AtmosphereModel.hpp"
#include "MessageInterface.hpp"
#include "GmatConstants.hpp"
#include "GmatDefaults.hpp"
#include "TimeSystemConverter.hpp"
#include "UtcDate.hpp"
#include "FileUtil.hpp"
#include "TimeTypes.hpp"
#include "AngleUtil.hpp"
#include "TimeTypes.hpp"
#include "StateConversionUtil.hpp"
#include "StringUtil.hpp"           // for ToString()
#include "GravityFile.hpp"          // for GetFileInfo()

//#define DEBUG_CELESTIAL_BODY 1
//#define DEBUG_GET_STATE
//#define DEBUG_CB_SET
//#define DEBUG_CB_INIT
//#define DEBUG_TWO_BODY
//#define DEBUG_EPHEM_SOURCE
//#define DEBUG_MODIFIED_FLAG
//#define DEBUG_CB_SET_STRING
//#define DEBUG_CB_SPICE
//#define DEBUG_CB_USER_DEFINED
//#define DEBUG_CB_GET_MJ2000_STATE
//#define DEBUG_REFERENCE_SETTING
//#define DEBUG_CB_READ_ONLY
//#define DEBUG_CB_CLOAKING
//#define DEBUG_CB_CLOAKING_EPOCH
//#define DEBUG_CB_EQ_RAD
//#define DEBUG_CB_CARTOGRAPHIC

//#ifndef DEBUG_MEMORY
//#define DEBUG_MEMORY
//#endif

#ifdef DEBUG_MEMORY
#include "MemoryTracker.hpp"
#endif

using namespace GmatMathUtil;


//---------------------------------
// static data
//---------------------------------
const std::string
CelestialBody::PARAMETER_TEXT[CelestialBodyParamCount - SpacePointParamCount] =
{
   "BodyType",
   "Mass",
   "EquatorialRadius",
   "Flattening",
   "PolarRadius",
   "Mu",
   "PosVelSource",
   "State",
   "StateTime",
   "CentralBody",
   "BodyNumber",
   "RefBodyNumber",
   "SourceFilename",
   "SourceFile",
   "UsePotentialFileFlag",
   "PotentialFileName",
   "AngularVelocity",
   "HourAngle",
   "AtmosphereModelName",
   "Order",
   "Degree",
   "RotationDataSource",
   "DateFormat",               // for two-body method
   "StateType",                // for two-body method
   "InitialEpoch",             // for two-body method
   "SMA",                      // for two-body method
   "ECC",                      // for two-body method
   "INC",                      // for two-body method
   "RAAN",                     // for two-body method
   "AOP",                      // for two-body method
   "TA",                       // for two-body method
   "OrientationDateFormat",    // orientation parameters, used to compute alpha, delta, W, Wdot
   "OrientationEpoch",
   "SpinAxisRAConstant",
   "SpinAxisRARate",
   "SpinAxisDECConstant",
   "SpinAxisDECRate",
   "RotationConstant",
   "RotationRate",
   "TextureMapFileName",
};

const Gmat::ParameterType
CelestialBody::PARAMETER_TYPE[CelestialBodyParamCount - SpacePointParamCount] =
{
   Gmat::STRING_TYPE,   //"BodyType",
   Gmat::REAL_TYPE,     //"Mass",
   Gmat::REAL_TYPE,     //"EquatorialRadius",
   Gmat::REAL_TYPE,     //"Flattening",
   Gmat::REAL_TYPE,     //"PolarRadius",
   Gmat::REAL_TYPE,     //"Mu",
   Gmat::STRING_TYPE,   //"PosVelSource",
   Gmat::RVECTOR_TYPE,  //"State",
   Gmat::TIME_TYPE,     //"StateTime",
   Gmat::STRING_TYPE,   //"CentralBody",
   Gmat::INTEGER_TYPE,  //"BodyNumber",
   Gmat::INTEGER_TYPE,  //"RefBodyNumber",
   Gmat::STRING_TYPE,   //"SourceFilename",
   Gmat::OBJECT_TYPE,   //"SourceFile",
   Gmat::BOOLEAN_TYPE,  //"UsePotentialFileFlag",
   Gmat::STRING_TYPE,   //"PotentialFileName",
   Gmat::RVECTOR_TYPE,  //"AngularVelocity",
   Gmat::REAL_TYPE,     //"HourAngle",
   Gmat::STRING_TYPE,   //"AtmosphereModelName",
   Gmat::INTEGER_TYPE,  //"Order",
   Gmat::INTEGER_TYPE,  //"Degree",
   Gmat::STRING_TYPE,   //"RotationDataSource",
   Gmat::STRING_TYPE,   //"DateFormat",   
   Gmat::STRING_TYPE,   //"StateType",  
   Gmat::REAL_TYPE,     //"InitialEpoch",
   Gmat::REAL_TYPE,     //"SMA", 
   Gmat::REAL_TYPE,     //"ECC",   
   Gmat::REAL_TYPE,     //"INC",   
   Gmat::REAL_TYPE,     //"RAAN",    
   Gmat::REAL_TYPE,     //"AOP",  
   Gmat::REAL_TYPE,     //"TA", 
   Gmat::STRING_TYPE,   //"OrientationDateFormat",  
   Gmat::REAL_TYPE,     //"OrientationEpoch",
   Gmat::REAL_TYPE,     //"SpinAxisRAConstant", 
   Gmat::REAL_TYPE,     //"SpinAxisRARate", 
   Gmat::REAL_TYPE,     //"SpinAxisDECConstant", 
   Gmat::REAL_TYPE,     //"SpinAxisDECRate", 
   Gmat::REAL_TYPE,     //"RotationConstant", 
   Gmat::REAL_TYPE,     //"RotationRate", 
   Gmat::STRING_TYPE,   //"TextureMapFileName"
};

const Real    CelestialBody::JD_EPOCH_2000_TCB     = GmatTimeConstants::JD_OF_J2000;
const Real    CelestialBody::JD_EPOCH_2000_TT      = GmatTimeConstants::JD_OF_J2000; // @ todo Figure out JD_EPOCH_2000_TT
const Real    CelestialBody::dDot                  = 1.0;
const Real    CelestialBody::TDot                  = 1.0;
const Real    CelestialBody::KEPLER_TOL            = 1.0e-08;
const Integer CelestialBody::KEPLER_MAX_ITERATIONS = 50;

//------------------------------------------------------------------------------
// public methods
//------------------------------------------------------------------------------
//------------------------------------------------------------------------------
//  CelestialBody(std::string itsBodyType, std::string name)
//------------------------------------------------------------------------------
/**
 * This method creates an object of the CelestialBody class
 * (additional constructor).
 *
 * @param <itsBodyType> string representation of its body type
 * @param <name> parameter indicating the name of the celestial body.
 */
//------------------------------------------------------------------------------
CelestialBody::CelestialBody(std::string itsBodyType, std::string name) :
   SpacePoint(Gmat::CELESTIAL_BODY, itsBodyType, name),
   equatorialRadius   (GmatSolarSystemDefaults::PLANET_EQUATORIAL_RADIUS[GmatSolarSystemDefaults::EARTH]),
   flattening         (GmatSolarSystemDefaults::PLANET_FLATTENING[GmatSolarSystemDefaults::EARTH]),
   mu                 (GmatSolarSystemDefaults::PLANET_MU[GmatSolarSystemDefaults::EARTH]),
   posVelSrc          (Gmat::DE405),
   stateTime          (GmatTimeConstants::MJD_OF_J2000),
   //theSolarSystem     (NULL),
   theCentralBodyName (""),
   theCentralBody     (NULL),
   centralBodySet     (false),
   bodyNumber         (0),
   referenceBodyNumber(0),
   sourceFilename     (""),
   theSourceFile      (NULL),
   usePotentialFile   (false),
   potentialFileName  (""),
   hourAngle          (0.0),
   atmModel           (NULL),
   atmModelType       ("None"),
   potentialFileRead  (false),
   order              (0),
   degree             (0),
   twoBodyFormat     ("TAIModJulian"),
   twoBodyStateType  ("Keplerian"),
   twoBodyEpoch      (GmatTimeConstants::MJD_OF_J2000),
   newTwoBody        (true),
   overrideTime      (false),
   ephemUpdateInterval (0.0),
   lastEphemTime      (0.0),
   rotationSrc        (Gmat::IAU_SIMPLIFIED),
   userDefined        (false),
   allowSpice         (false),
   orientationDateFormat ("TAIModJulian"),
   orientationEpoch   (GmatTimeConstants::MJD_OF_J2000), // @todo - really need it to be the TCB epoch used for the major bodies
   orientation        (GmatSolarSystemDefaults::PLANET_ORIENTATION_PARAMETERS[GmatSolarSystemDefaults::EARTH]),
   naifIdSet          (false),
   naifName           (name),
   textureMapFileName ("GenericCelestialBody.jpg"),
   msgWritten         (false)
{
   objectTypes.push_back(Gmat::CELESTIAL_BODY);
   objectTypeNames.push_back("CelestialBody");
   // @todo - what to use for defaults here? - set different values for different celestial bodies
   Rvector6 initKepler(GmatSolarSystemDefaults::PLANET_TWO_BODY_ELEMENTS[GmatSolarSystemDefaults::EARTH]);
   twoBodyKepler = initKepler;
   
   mass        = mu / GmatPhysicalConstants::UNIVERSAL_GRAVITATIONAL_CONSTANT;
   polarRadius = (1.0 - flattening) * equatorialRadius;

   for (Integer i = 0; i < Gmat::ModelTypeCount; i++)
      models[i].push_back("None");
   
   for (Integer i=0;i<6;i++)  prevState[i] = 0.0;
   #ifdef __USE_SPICE__
      kernelReader = NULL;
   #endif
   orbitSpiceKernelNames.clear();
   
   parameterCount = CelestialBodyParamCount;
   InitializeBody(itsBodyType);
   SaveAllAsDefault();

   // we want to cloak the DEFAULT Celestial Body data; i.e. we want to write only those
   // parameters that have been modified by the suer to a script; and we don't 
   // want to include the Create line either.  This will not be true for user-defined
   // bodies
   cloaking = true;

   #ifdef DEBUG_CB_CONSTRUCTOR
   MessageInterface::ShowMessage
      ("CelestialBody(string) <%p> '%s' constructor entered\n", this, GetName().c_str());
   #endif
}

//------------------------------------------------------------------------------
//  CelestialBody(Gmat::BodyType itsBodyType, std::string name)
//------------------------------------------------------------------------------
/**
 * This method creates an object of the CelestialBody class
 * (additional constructor).
 *
 * @param <itsBodyType> its body type
 * @param <name> parameter indicating the name of the celestial body.
 */
//------------------------------------------------------------------------------
CelestialBody::CelestialBody(Gmat::BodyType itsBodyType, std::string name) :
   SpacePoint(Gmat::CELESTIAL_BODY,
              Gmat::BODY_TYPE_STRINGS[itsBodyType], name),
   bodyType           (itsBodyType),
   equatorialRadius   (GmatSolarSystemDefaults::PLANET_EQUATORIAL_RADIUS[GmatSolarSystemDefaults::EARTH]),
   flattening         (GmatSolarSystemDefaults::PLANET_FLATTENING[GmatSolarSystemDefaults::EARTH]),
   mu                 (GmatSolarSystemDefaults::PLANET_MU[GmatSolarSystemDefaults::EARTH]),
   posVelSrc          (Gmat::DE405),
//   analyticMethod     (Gmat::LOW_FIDELITY),
   stateTime          (GmatTimeConstants::MJD_OF_J2000),
   //theSolarSystem     (NULL),
   theCentralBodyName (""),
   theCentralBody     (NULL),
   centralBodySet     (false),
   bodyNumber         (0),
   referenceBodyNumber(0),
   sourceFilename     (""),
   theSourceFile      (NULL),
   usePotentialFile   (false),
   potentialFileName  (""),
   hourAngle          (0.0),
   atmModel           (NULL),
   atmModelType       ("None"),
   potentialFileRead  (false),
   order              (0),
   degree             (0),
   twoBodyFormat     ("TAIModjulian"),
   twoBodyStateType  ("Keplerian"),
   twoBodyEpoch      (GmatTimeConstants::MJD_OF_J2000),
   newTwoBody        (true),
   overrideTime       (false),
   ephemUpdateInterval (0.0),
   lastEphemTime      (0.0),
   rotationSrc        (Gmat::IAU_SIMPLIFIED),
   userDefined        (false),
   allowSpice         (false),
   orientationDateFormat ("TAIModJulian"),
   orientationEpoch   (GmatTimeConstants::MJD_OF_J2000), // @todo - really need it to be the TCB epoch used for the major bodies
   orientation        (GmatSolarSystemDefaults::PLANET_ORIENTATION_PARAMETERS[GmatSolarSystemDefaults::EARTH]),
   naifIdSet          (false),
   naifName           (name),
   textureMapFileName ("GenericCelestialBody.jpg"),
   msgWritten         (false)
{
   objectTypes.push_back(Gmat::CELESTIAL_BODY);
   objectTypeNames.push_back("CelestialBody");
   
   // @todo - what to use for defaults here? - set different values for different celestial bodies
   Rvector6 initKepler(GmatSolarSystemDefaults::PLANET_TWO_BODY_ELEMENTS[GmatSolarSystemDefaults::EARTH]);
   twoBodyKepler = initKepler;

   mass        = mu / GmatPhysicalConstants::UNIVERSAL_GRAVITATIONAL_CONSTANT;
   polarRadius = (1.0 - flattening) * equatorialRadius;

   for (Integer i = 0; i < Gmat::ModelTypeCount; i++)
      models[i].push_back("None");
   for (Integer i=0;i<6;i++)  prevState[i] = 0.0;
   
   #ifdef __USE_SPICE__
      kernelReader = NULL;
   #endif
   orbitSpiceKernelNames.clear();
   
   parameterCount = CelestialBodyParamCount;
   
   InitializeBody(Gmat::BODY_TYPE_STRINGS[itsBodyType]);
   
   SaveAllAsDefault();
   
   #ifdef DEBUG_CB_CONSTRUCTOR
   MessageInterface::ShowMessage
      ("CelestialBody(bodyType) <%p> '%s' constructor entered\n",
       this, GetName().c_str());
   #endif
}

//------------------------------------------------------------------------------
//  CelestialBody(const CelestialBody &cBody)
//------------------------------------------------------------------------------
/**
 * This method creates an object of the CelestialBody class as a copy of the
 * specified CelestialBody class (copy constructor).
 *
 * @param <cBody> CelestialBody object to copy.
 */
//------------------------------------------------------------------------------
CelestialBody::CelestialBody(const CelestialBody &cBody) :
   SpacePoint          (cBody),
   bodyType            (cBody.bodyType),
   mass                (cBody.mass),
   equatorialRadius    (cBody.equatorialRadius),
   flattening          (cBody.flattening),
   polarRadius         (cBody.polarRadius),
   mu                  (cBody.mu),
   posVelSrc           (cBody.posVelSrc),
   theCentralBodyName  (cBody.theCentralBodyName),
   theCentralBody      (cBody.theCentralBody),    // correct?
   centralBodySet      (cBody.centralBodySet),    // correct?
   bodyNumber          (cBody.bodyNumber),
   referenceBodyNumber (cBody.referenceBodyNumber),
   sourceFilename      (cBody.sourceFilename),
   theSourceFile       (cBody.theSourceFile), // ????????????????
   usePotentialFile    (cBody.usePotentialFile),
   potentialFileName   (cBody.potentialFileName),
   hourAngle           (cBody.hourAngle),
   atmModel            (NULL),
   default_equatorialRadius      (cBody.default_equatorialRadius),
   default_flattening            (cBody.default_flattening),
   default_mu                    (cBody.default_mu),
   default_posVelSrc             (cBody.default_posVelSrc),
   default_centralBodyName       (cBody.default_centralBodyName),
   default_sourceFilename        (cBody.default_sourceFilename),
   default_orbitSpiceKernelNames      (cBody.default_orbitSpiceKernelNames),
   default_rotationSrc           (cBody.default_rotationSrc), 
   default_twoBodyEpoch          (cBody.default_twoBodyEpoch),
   default_twoBodyKepler         (cBody.default_twoBodyKepler),
   default_orientationEpoch      (cBody.default_orientationEpoch),
   default_orientation           (cBody.default_orientation),
   default_textureMapFileName    (cBody.default_textureMapFileName),
   order               (cBody.order),
   degree              (cBody.degree),
//   sij                 (cBody.sij),
//   cij                 (cBody.cij),
   twoBodyFormat       (cBody.twoBodyFormat),
   twoBodyStateType    (cBody.twoBodyStateType),
   twoBodyEpoch        (cBody.twoBodyEpoch),
   twoBodyKepler       (cBody.twoBodyKepler),
   prevTwoBodyEpoch    (cBody.prevTwoBodyEpoch),
   prevTwoBodyState    (cBody.prevTwoBodyState),
   newTwoBody          (cBody.newTwoBody),
   overrideTime        (cBody.overrideTime),
   ephemUpdateInterval (cBody.ephemUpdateInterval),
   lastEphemTime       (cBody.lastEphemTime),
   lastState           (cBody.lastState),
   rotationSrc         (cBody.rotationSrc),
   userDefined         (cBody.userDefined),
   allowSpice          (cBody.allowSpice),
   orientationDateFormat (cBody.orientationDateFormat),
   orientationEpoch    (cBody.orientationEpoch),
   orientation         (cBody.orientation),
   naifIdSet           (cBody.naifIdSet),
   naifName            (cBody.naifName),
   textureMapFileName  (cBody.textureMapFileName),
   msgWritten          (cBody.msgWritten)
{
   state                  = cBody.state;
   stateTime              = cBody.stateTime;
   angularVelocity        = cBody.angularVelocity;
   isFirstTimeMu          = true;
   isFirstTimeRadius      = true;
   potentialFileRead      = false;
   #ifdef __USE_SPICE__
      kernelReader = cBody.kernelReader;
   #endif
   
   if (cBody.atmModel)
   {
      //atmModel = (AtmosphereModel*)(cBody.atmModel->Clone());      
      AtmosphereModel *clonedAM = (AtmosphereModel*)(cBody.atmModel->Clone());   
      #ifdef DEBUG_MEMORY
      MemoryTracker::Instance()->Add
         (clonedAM, clonedAM->GetName(), "CelestialBody::copy constructor",
          "clonedAM = (AtmosphereModel*)cBody.atmModel->Clone()");
      #endif
      atmModel = clonedAM;
      #ifdef DEBUG_CELESTIAL_BODY
      MessageInterface::ShowMessage
         ("CelestialBody::CelestialBody() Setting ATM:%s on %s\n",
          atmModel->GetName().c_str(), instanceName.c_str());
      #endif
   }
   
   for (Integer i = 0; i < Gmat::ModelTypeCount; i++)
      models[i] = cBody.models[i];
   
   for (Integer i=0;i<6;i++)  prevState[i] = cBody.prevState[i];
   
   #ifdef DEBUG_CB_CONSTRUCTOR
   MessageInterface::ShowMessage
      ("CelestialBody() <%p> '%s' copy constructor entered\n", this, GetName().c_str());
   #endif
}

//------------------------------------------------------------------------------
//  CelestialBody& operator= (const CelestialBody& cBody)
//------------------------------------------------------------------------------
/**
 * Assignment operator for the CelestialBody class.
 *
 * @param <cBody> the CelestialBody object whose data to assign to "this"
 *            solar system.
 *
 * @return "this" CelestialBody with data of input CelestialBody cb.
 */
//------------------------------------------------------------------------------
CelestialBody& CelestialBody::operator=(const CelestialBody &cBody)
{
   if (&cBody == this)
      return *this;

   SpacePoint::operator=(cBody);
   bodyType            = cBody.bodyType;
   mass                = cBody.mass;
   equatorialRadius    = cBody.equatorialRadius;
   flattening          = cBody.flattening;
   polarRadius         = cBody.polarRadius;
   mu                  = cBody.mu;
   posVelSrc           = cBody.posVelSrc;
   state               = cBody.state;
   stateTime           = cBody.stateTime;
   theCentralBodyName  = cBody.theCentralBodyName;
   theCentralBody      = cBody.theCentralBody;   // correct?
   centralBodySet      = cBody.centralBodySet;   // correct?
   bodyNumber          = cBody.bodyNumber;
   referenceBodyNumber = cBody.referenceBodyNumber;
   sourceFilename      = cBody.sourceFilename;
   theSourceFile       = cBody.theSourceFile;   // ??????????????
   #ifdef __USE_SPICE__
      kernelReader        = cBody.kernelReader;
   #endif
   usePotentialFile    = cBody.usePotentialFile;
   potentialFileName   = cBody.potentialFileName;
   angularVelocity     = cBody.angularVelocity;
   hourAngle           = cBody.hourAngle;
   
   default_equatorialRadius       = cBody.default_equatorialRadius;
   default_flattening             = cBody.default_flattening;
   default_mu                     = cBody.default_mu;
   default_posVelSrc              = cBody.default_posVelSrc;
   default_centralBodyName        = cBody.default_centralBodyName;
   default_sourceFilename         = cBody.default_sourceFilename;
   default_orbitSpiceKernelNames       = cBody.default_orbitSpiceKernelNames;
   default_rotationSrc            = cBody.default_rotationSrc; 
   default_twoBodyEpoch           = cBody.default_twoBodyEpoch;
   default_twoBodyKepler          = cBody.default_twoBodyKepler;
   default_orientationEpoch       = cBody.default_orientationEpoch;
   default_orientation            = cBody.default_orientation;
   default_textureMapFileName     = cBody.default_textureMapFileName;
   
   isFirstTimeMu                  = cBody.isFirstTimeMu;
   isFirstTimeRadius              = cBody.isFirstTimeRadius;
   
   if (atmModel)
   {
      #ifdef DEBUG_MEMORY
      MemoryTracker::Instance()->Remove
         (atmModel, atmModel->GetName(), "CelestialBody::operator=",
          "deleting atmModel");
      #endif
      delete atmModel;
   }
   
   if (cBody.atmModel)
   {
      //atmModel = (AtmosphereModel*)(cBody.atmModel)->Clone();
      AtmosphereModel *clonedAM = (AtmosphereModel*)(cBody.atmModel)->Clone();
      #ifdef DEBUG_MEMORY
      MemoryTracker::Instance()->Add
         (clonedAM, clonedAM->GetName(), "CelestialBody::operator=",
          "clonedAM = (AtmosphereModel*)cBody.atmModel->Clone()");
      #endif
      atmModel = clonedAM;
   }
   else
      atmModel = NULL;
      
   for (Integer i = 0; i < Gmat::ModelTypeCount; i++)
      models[i] = cBody.models[i];
   
   twoBodyEpoch        = cBody.twoBodyEpoch;
   twoBodyKepler       = cBody.twoBodyKepler;
   prevTwoBodyEpoch    = cBody.prevTwoBodyEpoch;
   prevTwoBodyState    = cBody.prevTwoBodyState;
   twoBodyFormat       = cBody.twoBodyFormat;
   twoBodyStateType    = cBody.twoBodyStateType;
   newTwoBody          = cBody.newTwoBody;
   overrideTime        = cBody.overrideTime;
   ephemUpdateInterval = cBody.ephemUpdateInterval;
   lastEphemTime       = cBody.lastEphemTime;
   lastState           = cBody.lastState;
   rotationSrc         = cBody.rotationSrc;
   userDefined         = cBody.userDefined;
   allowSpice          = cBody.allowSpice;
   orientationDateFormat = cBody.orientationDateFormat;
   orientationEpoch    = cBody.orientationEpoch;
   orientation         = cBody.orientation;
   
   naifIdSet           = cBody.naifIdSet;
   naifName            = cBody.naifName;
   textureMapFileName  = cBody.textureMapFileName;
   msgWritten          = cBody.msgWritten;
   
   for (Integer i=0;i<6;i++)  prevState[i] = cBody.prevState[i];
   
   potentialFileRead   = false;

   return *this;
}

//------------------------------------------------------------------------------
//  ~CelestialBody()
//------------------------------------------------------------------------------
/**
 * Destructor for the CelestialBody class.
 */
//------------------------------------------------------------------------------
CelestialBody::~CelestialBody()
{
   if (atmModel)
   {
      #ifdef DEBUG_MEMORY
      MemoryTracker::Instance()->Remove
         (atmModel, atmModel->GetName(), "CelestialBody::~CelestialBody()",
          "deleting atmModel");
      #endif
      delete atmModel;
   }
   #ifdef DEBUG_CB_SPICE
      MessageInterface::ShowMessage("In CB (%s) destructor, attempting to unload the kernel(s):\n",
            instanceName.c_str());
      for (unsigned int jj = 0; jj < orbitSpiceKernelNames.size(); jj++)
         MessageInterface::ShowMessage("    %s\n", (orbitSpiceKernelNames.at(jj)).c_str());
   #endif
   #ifdef __USE_SPICE__
   // unload the kernel(s) from the SpiceKernelReader
      for (unsigned int kk = 0; kk < orbitSpiceKernelNames.size(); kk++)
         if (orbitSpiceKernelNames.at(kk) != "" && (kernelReader != NULL) &&
            (kernelReader->IsLoaded(orbitSpiceKernelNames.at(kk))))
            kernelReader->UnloadKernel(orbitSpiceKernelNames.at(kk));
//      if ((kernelReader != NULL) && (lskKernelName != "")) kernelReader->UnloadKernel(lskKernelName);
   #endif
}


//------------------------------------------------------------------------------
// bool Initialize()
//------------------------------------------------------------------------------
bool CelestialBody::Initialize()
{
   #ifdef DEBUG_CB_INIT
   MessageInterface::ShowMessage
      ("CelestialBody::Initialize() this=<%p> %10s, posVelSrc=%d, ephemUpdateInterval=%f\n",
       this, GetName().c_str(), posVelSrc, ephemUpdateInterval);
   #endif
   
   // Do we need to reset this?
   // When running GmatFunction, this causes to write message about using default mu
   // in every function call
   // Commented out for now(loj: 2008.10.03)
   //isFirstTimeMu = true;
   //isFirstTimeRadius = true;
   
   lastEphemTime = 0.0;
   stateTime = 0.0;   
   newTwoBody = true;

   if (!centralBodySet)
   {
      std::string errmsg = "Central body \"";
      errmsg += theCentralBodyName + "\" not set for body \"";
      errmsg += instanceName + "\"";
      throw SolarSystemException(errmsg);
   }
   
   // Set to false so that it can be reset to valid spiceNaifId
   // when running function (LOJ: 2010.05.17)
   naifIdSet = false;
   
   // Set up the kernel reader, if required
   SetUpSPICE();
   return true;
}

//------------------------------------------------------------------------------
// void SetUpBody()
//------------------------------------------------------------------------------
void CelestialBody::SetUpBody()
{
   // main thing to do for now is to make sure the central body is set
   if (!theSolarSystem)
   {
      std::string errmsg = "Solar System not set for body \"";
      errmsg += instanceName + "\"\n";
      throw SolarSystemException(errmsg);
   }
   if (!theCentralBody)
   {
      CelestialBody *cBody  = theSolarSystem->GetBody(theCentralBodyName);
      if (!cBody)
      {
         std::string errmsg = "Cannot set central body for body \"";
         errmsg += instanceName + "\" because body \"";
         errmsg += theCentralBodyName + "\" cannot be found.\n";
         throw SolarSystemException (errmsg);
      }
      SetRefObject(cBody, Gmat::CELESTIAL_BODY, theCentralBodyName);
   }
   if (RequiresJ2000Body() && j2000Body == NULL)
   {
      j2000Body = theSolarSystem->GetBody(j2000BodyName);
   }
   // add other set-up kinds of things later?
   return;
}



//------------------------------------------------------------------------------
//  const Rvector6& GetState(A1Mjd atTime)
//------------------------------------------------------------------------------
/**
 * This method returns the state (position and velocity) of the body at the
 * requested time.
 *
 * @param <atTime>  time for which state of the body is requested.
 *
 * @return state of the body at the requested time.
 *
 * @exception <PlanetaryEphemException> thrown when the requested Pos/Vel
 *            source is set to SLP or DE***, but the source file has not
 *            been set.
 *
 */
//------------------------------------------------------------------------------
const Rvector6&  CelestialBody::GetState(A1Mjd atTime)
{
   if (!theCentralBody) SetUpBody();

   #ifdef DEBUG_GET_STATE
   MessageInterface::ShowMessage
      ("CelestialBody::GetState() <%p> '%s' entered with time %.17f\n", this,
       GetName().c_str(), atTime.Get());
   MessageInterface::ShowMessage
      ("   posVelSrc=%d for <%p> %s\n", posVelSrc, this, GetName().c_str());
   MessageInterface::ShowMessage("   lastEphemTime = %.17f\n",lastEphemTime.Get());
   #endif
   
   Real dt = Abs(atTime.Subtract(lastEphemTime)) * GmatTimeConstants::SECS_PER_DAY;
   if ( dt < ephemUpdateInterval)
   {
      #ifdef DEBUG_GET_STATE
      MessageInterface::ShowMessage("   returning lastState %s\n", state.ToString().c_str());
      #endif
      return lastState;
   }
   
   Real*     posVel = NULL;
   switch (posVelSrc)
   {
      case Gmat::TWO_BODY_PROPAGATION :
         state = ComputeTwoBody(atTime);
         break;
      case Gmat::DE405 :
      {
         if (!theSourceFile)
         {
            throw PlanetaryEphemException(
//                  "SLP or DE file requested, but no file specified");
                  "DE file requested, but no file specified");
         }
         #ifdef DEBUG_GET_STATE
         MessageInterface::ShowMessage
            ("   In <%p> '%s', Calling theSourceFile(%s)->GetPosVel(%d, %f, %s)\n",
             this, GetName().c_str(), (theSourceFile->GetName()).c_str(), bodyNumber, atTime.GetReal(),
             overrideTime ? "true" : "false");
         #endif
         posVel     = theSourceFile->GetPosVel(bodyNumber, atTime, overrideTime);
         state.Set(posVel[0], posVel[1], posVel[2],
                   posVel[3], posVel[4], posVel[5]);
         break;
      }
      case Gmat::SPICE :
      {
         #ifdef __USE_SPICE__
         if (!spiceSetupDone) SetUpSPICE();
         Rvector6 spiceState = kernelReader->GetTargetState(naifName, naifId, atTime, j2000BodyName, naifIdObserver);
         state.Set(spiceState[0], spiceState[1], spiceState[2],
                   spiceState[3], spiceState[4], spiceState[5]);
         #else
         // Throw an error if GMAT was not build with __USE_SPICE__ (LOJ: 2010.05.18)
         std::string errmsg = "Use of SPICE file was disabled";
         throw SolarSystemException(errmsg);
         #endif
         break;
      }
      default:
         throw SolarSystemException("Invalid data source defined for body "
                                    + instanceName);
         break;
   }
   stateTime     = atTime;
   lastEphemTime = atTime;
   lastState     = state;
   
   for (Integer i=0;i<6;i++)
      prevState[i] = lastState[i];
   
   #ifdef DEBUG_GET_STATE
   MessageInterface::ShowMessage("   returning state %s\n", state.ToString().c_str());
   #endif
   
   return state;
}

//------------------------------------------------------------------------------
//  const Rvector6& GetState(Real atTime)
//------------------------------------------------------------------------------
 /**
 * This method returns the state (position and velocity) of the body at the
 * requested time.
 *
 * @param <atTime>  time for which state of the body is requested.
 *
 * @return state of the body at the requested time.
 *
 * @exception <PlanetaryEphemException> thrown when the requested Pos/Vel
 *            source is set to SLP or DE***, but the source file has not
 *            been set.
 *
 */
//------------------------------------------------------------------------------
const Rvector6&  CelestialBody::GetState(Real atTime)
{
   A1Mjd forTime(atTime);
   return GetState(forTime);
}


//------------------------------------------------------------------------------
// void GetState(const A1Mjd &atTime, Real *outState)
//------------------------------------------------------------------------------
void CelestialBody::GetState(const A1Mjd &atTime, Real *outState)
{
   #ifdef DEBUG_GET_STATE
      MessageInterface::ShowMessage("Entering GetState with time %.17f\n",
      atTime.Get());
   #endif
      
   if (!theCentralBody) SetUpBody();

   Real dt = Abs(atTime.Subtract(lastEphemTime)) * GmatTimeConstants::SECS_PER_DAY;
   if ( dt < ephemUpdateInterval)
   {
      for (Integer i=0;i<6;i++) outState[i] = prevState[i];
   }
   
   Rvector6 state;
   switch (posVelSrc)
   {
      case Gmat::TWO_BODY_PROPAGATION :
      {
//         Rvector6 state;
         state = ComputeTwoBody(atTime);
         for (Integer i=0;i<6;i++) outState[i] = state[i];
         break;
      }
      case Gmat::DE405 :
         if (!theSourceFile)
         {
            throw PlanetaryEphemException(
                  "DE 405 file requested, but no file specified");
         }
         #ifdef DEBUG_GET_STATE
         MessageInterface::ShowMessage
            ("   In <%p> '%s', Calling theSourceFile(%s)->GetPosVel(%d, %f, %s)\n",
             this, GetName().c_str(), (theSourceFile->GetName()).c_str(), bodyNumber, atTime.GetReal(),
             overrideTime ? "true" : "false");
         #endif
         outState     = theSourceFile->GetPosVel(bodyNumber,atTime, overrideTime);
         break;
      case Gmat::SPICE :
      #ifdef __USE_SPICE__
         if (!spiceSetupDone) SetUpSPICE();
         state = kernelReader->GetTargetState(naifName, naifId, atTime, j2000BodyName, naifIdObserver);
         for (Integer i=0;i<6;i++) outState[i] = state[i];
      #endif
         break;
      default:
         throw SolarSystemException("Invalid data source defined for body "
                                    + instanceName);
         break;
   }
   
   stateTime     = atTime;
   lastEphemTime = atTime;
   lastState.Set(outState[0],outState[1],outState[2],outState[3],outState[4],outState[5]);
   
   for (Integer i=0;i<6;i++)
      prevState[i] = outState[i];
   
   #ifdef DEBUG_GET_STATE
      MessageInterface::ShowMessage("Exiting GetState -------------f\n");
   #endif
}

// Moved to SpacePoint (LOJ: 2010.11.19)
// void CelestialBody::SetSolarSystem(SolarSystem *ss)
// {
//    theSolarSystem = ss;
// }

#ifdef __USE_SPICE__
void CelestialBody::SetSpiceOrbitKernelReader(SpiceOrbitKernelReader *skr)
{
   kernelReader   = skr;
   spiceSetupDone = false;
}
#endif

//------------------------------------------------------------------------------
//  Gmat::BodyType GetBodyType() const
//------------------------------------------------------------------------------
/**
 * This method returns the body type of the body.
 *
 * @return body type of the body.
 *
 */
//------------------------------------------------------------------------------
Gmat::BodyType CelestialBody::GetBodyType() const
{
   return bodyType;
}

//------------------------------------------------------------------------------
//  const std::string& GetCentralBody() const
//------------------------------------------------------------------------------
/**
 * This method returns the name of the central body of the body.
 *
 * @return name of the central body of the body.
 *
 */
//------------------------------------------------------------------------------
const std::string& CelestialBody::GetCentralBody() const
{
   return theCentralBodyName;
}


//------------------------------------------------------------------------------
//  Real GetGravitationalConstant() 
//------------------------------------------------------------------------------
/**
 * This method returns the gravitational constant (km^3/s^2) of the body.
 *
 * @return gravitational constant of the body.
 *
 */
//------------------------------------------------------------------------------
Real CelestialBody::GetGravitationalConstant() 
{
   #ifdef DEBUG_GRAV_CONST
   MessageInterface::ShowMessage
      ("CelestialBody::GetGravitationalConstant() this=<%p>, usePotentialFile=%d for %s, "
       "isFirstTimeMu=%d\n", this, usePotentialFile, instanceName.c_str(), isFirstTimeMu);
   #endif
   
   if (usePotentialFile == true)
   {
      if (!potentialFileRead)
      {
         if (!ReadPotentialFile())
         {
            if (isFirstTimeMu)
            {
               MessageInterface::ShowMessage
                  ("For body %s, cannot read file \"%s\", so using default mu"
                   " (%.18f)\n", instanceName.c_str(),
//                   potentialFileName.c_str(), defaultMu);
                   potentialFileName.c_str(), default_mu);
               
               isFirstTimeMu = false;
            }
            
//            mu = defaultMu;
            mu = default_mu;
         }
      }
      else
      {
         if (isFirstTimeMu)
         {
            MessageInterface::LogMessage
               ("For body %s, using mu (%.18f) from file \"%s\"\n",
                instanceName.c_str(), mu, potentialFileName.c_str());
            
            isFirstTimeMu = false;
         }
      }
   }
   else
   {
      if (isFirstTimeMu)
      {
         MessageInterface::LogMessage
            ("For body %s, not using potential file, so using default mu (%.18f)\n",
             instanceName.c_str(), mu, potentialFileName.c_str());
         
         isFirstTimeMu = false;
      }
   }
   
   // recompute mass
   mass = mu / GmatPhysicalConstants::UNIVERSAL_GRAVITATIONAL_CONSTANT;
   return mu;
}

//------------------------------------------------------------------------------
//  Real GetEquatorialRadius() 
//------------------------------------------------------------------------------
/**
* This method returns the equatorial radius (km) of the body.
 *
 * @return equatorial radius of the body.
 *
 */
//------------------------------------------------------------------------------
Real CelestialBody::GetEquatorialRadius() 
{   
   #ifdef DEBUG_CB_EQ_RAD
      MessageInterface::ShowMessage("Entering GetEquatorialRadius, %s equatorialRadius = %12.10f\n",
            instanceName.c_str(), equatorialRadius);
      MessageInterface::ShowMessage("    usePotentialFile = %s\n", (usePotentialFile? "true" : "false"));
   #endif
   if (usePotentialFile == true)
   {
      if (!potentialFileRead)
      {
         if (!ReadPotentialFile())
         {
            if (isFirstTimeRadius)
            {
               MessageInterface::ShowMessage
                  ("For body %s, cannot read file \"%s\", so using default eq. radius"
                   " (%.18f)\n", instanceName.c_str(),
//                   potentialFileName.c_str(), defaultEqRadius);
                   potentialFileName.c_str(), default_equatorialRadius);
               
               isFirstTimeRadius = false;
            }
         
//            equatorialRadius = defaultEqRadius;
            equatorialRadius = default_equatorialRadius;
         }
      }
      else
      {
         if (isFirstTimeRadius)
         {
            MessageInterface::ShowMessage
               ("For body %s, using eq. radius (%.18f) from file \"%s\"\n",
                instanceName.c_str(), equatorialRadius, potentialFileName.c_str());
         
            isFirstTimeRadius = false;
         }
      }
   }
   else
   {
      if (isFirstTimeRadius)
      {
         MessageInterface::LogMessage
            ("For body %s, not using potential file, so using default eq. radius (%.18f)\n",
             instanceName.c_str(), equatorialRadius, potentialFileName.c_str());
         
         isFirstTimeRadius = false;
      }
   }
   
   // recompute the polar radius
   polarRadius = (1.0 - flattening) * equatorialRadius;
   #ifdef DEBUG_CB_EQ_RAD
      MessageInterface::ShowMessage("Exiting GetEquatorialRadius, %s equatorialRadius = %12.10f\n",
            instanceName.c_str(), equatorialRadius);
   #endif
   return equatorialRadius;
}

//------------------------------------------------------------------------------
//  Real GetFlattening() const
//------------------------------------------------------------------------------
/**
 * This method returns the flattening value of the body.
 *
 * @return flattening of the body.
 *
 */
//------------------------------------------------------------------------------
Real CelestialBody::GetFlattening() const
{
   return flattening;
}

//------------------------------------------------------------------------------
//  Real GetPolarRadius() 
//------------------------------------------------------------------------------
/**
 * This method returns the polar radius (km) of the body.
 *
 * @return polar radius of the body.
 *
 */
//------------------------------------------------------------------------------
Real CelestialBody::GetPolarRadius() 
{
   // make sure it is computed correctly
   polarRadius = (1.0 - flattening) * equatorialRadius;
   return polarRadius;   
}

//------------------------------------------------------------------------------
//  Real GetMass() 
//------------------------------------------------------------------------------
/**
 * This method returns the mass (kg) of the body.
 *
 * @return mass of the body.
 *
 */
//------------------------------------------------------------------------------
 Real CelestialBody::GetMass() 
{
   // make sure it is computed correctly
   mass = mu / GmatPhysicalConstants::UNIVERSAL_GRAVITATIONAL_CONSTANT;
   return mass;
}

//------------------------------------------------------------------------------
//  Gmat::PosVelSource GetPosVelSource() const
//------------------------------------------------------------------------------
/**
 * This method returns the source of position and velocity for the body.
 *
 * @return position/velocity source for the body.
 *
 */
//------------------------------------------------------------------------------
Gmat::PosVelSource  CelestialBody::GetPosVelSource() const
{
   return posVelSrc;
}

//------------------------------------------------------------------------------
// std::string GetSourceFileName() const
//------------------------------------------------------------------------------
std::string CelestialBody::GetSourceFileName() const
{
   if (theSourceFile)
      return theSourceFile->GetName();
   return "";
}

//------------------------------------------------------------------------------
// PlanetaryEphem* GetSourceFile() const
//------------------------------------------------------------------------------
PlanetaryEphem*  CelestialBody::GetSourceFile() const
{
   return theSourceFile;
}

////------------------------------------------------------------------------------
////  Gmat::AnalyticMethod GetAnalyticMethod() const
////------------------------------------------------------------------------------
///**
// * This method returns the analytic method used for the body.
// *
// * @return analytic method for the body.
// *
// */
////------------------------------------------------------------------------------
//Gmat::AnalyticMethod CelestialBody::GetAnalyticMethod() const
//{
//   return analyticMethod;
//}

//------------------------------------------------------------------------------
//  bool CelestialBody::GetUsePotentialFile() const
//------------------------------------------------------------------------------
/**
 * This method returns the flag indicating whether to use the potential file
 * or not used for the body.
 *
 * @return flag indicating whether or not to use the potential file to determine
 *         mu, radius, and spherical harmonic coefficients.
 *
 */
//------------------------------------------------------------------------------
bool CelestialBody::GetUsePotentialFile() const
{
   return usePotentialFile;
}


//------------------------------------------------------------------------------
// bool GetOverrideTimeSystem() const
//------------------------------------------------------------------------------
bool CelestialBody::GetOverrideTimeSystem() const
{
   return overrideTime;
}


//------------------------------------------------------------------------------
// Real GetEphemUpdateInterval() const
//------------------------------------------------------------------------------
Real CelestialBody::GetEphemUpdateInterval() const
{
   return ephemUpdateInterval;
}


//------------------------------------------------------------------------------
// StringArray GetValidModelList(Gmat::ModelType m) const
//------------------------------------------------------------------------------
StringArray CelestialBody::GetValidModelList(Gmat::ModelType m) const
{
   return models[(Integer)m]; 
}


//------------------------------------------------------------------------------
//  const Rvector3& CelestialBody::GetAngularVelocity() 
//------------------------------------------------------------------------------
/**
 * This method returns the angular velocity for the body.
 *
 * @return angular velocity (Real[3]) for the body.
 *
 */
//------------------------------------------------------------------------------
const Rvector3& CelestialBody::GetAngularVelocity() 
{
   return angularVelocity; 
}

//------------------------------------------------------------------------------
//  Real GetHourAngle(A1Mjd atTime)
//------------------------------------------------------------------------------
/**
 * This method returns the hour angle for the body, referenced from the
 * Prime Meridian, measured westward
 *
 * @param <atTime> time for which to compute the hour angle
 *
 * @return hour angle for the body, in degrees, from the Prime Meridian
 *
 * @note This is a catch-all when information for the body is not defined.
 */
//------------------------------------------------------------------------------
Real  CelestialBody::GetHourAngle(A1Mjd atTime) 
{
   Rvector cart = GetBodyCartographicCoordinates(atTime);
   hourAngle = cart[2];  
   // reduce to a quantity within one day (GmatTimeConstants::SECS_PER_DAY seconds, 360.0 degrees)
   hourAngle = AngleUtil::PutAngleInDegRange(hourAngle,0.0,360.0);
   return hourAngle;
}

////------------------------------------------------------------------------------
////  const Rmatrix& GetHarmonicCoefficientsSij()
////------------------------------------------------------------------------------
///**
// * This method returns the spherical harmonic coefficients sij for the body.  It
// * will read the potential file if that is requested.
// *
// * @return sij spherical harmonic coefficients for the body.
// *
// *
// * @exception <SolarSystemException> thown if there is an error getting the data.
// */
////------------------------------------------------------------------------------
//const Rmatrix& CelestialBody::GetHarmonicCoefficientsSij()
//{
//   return sij;
//}
//
////------------------------------------------------------------------------------
////  const Rmatrix& GetHarmonicCoefficientsCij()
////------------------------------------------------------------------------------
///**
// * This method returns the spherical harmonic coefficients cij for the body.  It
// * will read the potential file if that is requested.
// *
// * @return cij spherical harmonic coefficients for the body.
// *
// * @exception <SolarSystemException> thown if there is an error getting the data.
// */
////------------------------------------------------------------------------------
//const Rmatrix& CelestialBody::GetHarmonicCoefficientsCij()
//{
//   return cij;
//}

//------------------------------------------------------------------------------
//  const Rmatrix& GetCoefDriftS()
//------------------------------------------------------------------------------
/**
 * This method returns the dSbar coefficient drift matrix for the body.  It
 * will read the potential file if that is requested.
 *
 * @return dSbar  coefficient drift matrix for the body.
 *
 * @exception <SolarSystemException> thown if there is an error getting the data.
 */
//------------------------------------------------------------------------------
//const Rmatrix& CelestialBody::GetCoefDriftS()
//{
//   if ((usePotentialFile == true) & (!potentialFileRead))
//   {
//      bool OK = ReadPotentialFile();
//      if (!OK) throw SolarSystemException("Unable to read potential file");
//   }
//   return dSbar;
//}

//------------------------------------------------------------------------------
//  const Rmatrix& GetCoefDriftC()
//------------------------------------------------------------------------------
/**
 * This method returns the dCbar coefficient drift matrix for the body.  It
 * will read the potential file if that is requested.
 *
 * @return dCbar  coefficient drift matrix for the body.
 *
 * @exception <SolarSystemException> thown if there is an error getting the data.
 */
//------------------------------------------------------------------------------
//const Rmatrix& CelestialBody::GetCoefDriftC()
//{
//   if ((usePotentialFile == true) & (!potentialFileRead))
//   {
//      bool OK = ReadPotentialFile();
//      if (!OK) throw SolarSystemException("Unable to read potential file");
//   }
//   return dCbar;
//}

//------------------------------------------------------------------------------
// Integer GetDegree()
//------------------------------------------------------------------------------
/**
 * This method returns the degree of the gravity coefficients for the body.  It
 * will read the potential file if that is requested.
 *
 * @return degree  degree of the coefficients for the body.
 *
 * @exception <SolarSystemException> thown if there is an error getting the data.
 */
//------------------------------------------------------------------------------
Integer CelestialBody::GetDegree()
{
   return degree;
}

//------------------------------------------------------------------------------
// Integer GetOrder()
//------------------------------------------------------------------------------
/**
 * This method returns the order of the gravity coefficients for the body.  It
 * will read the potential file if that is requested.
 *
 * @return degree  order of the coefficients for the body.
 *
 * @exception <SolarSystemException> thown if there is an error getting the data.
 */
//------------------------------------------------------------------------------
Integer CelestialBody::GetOrder()
{
   return order;
}

//------------------------------------------------------------------------------
//  std::string GetAtmosphereModelType()
//------------------------------------------------------------------------------
/**
 * This method returns the name (type) of the current atmosphere model for
 * the body.
 *
 * @return the name (type) of the current atmosphere model for the body.
 *
 */
//------------------------------------------------------------------------------
std::string  CelestialBody::GetAtmosphereModelType()
{
   if (!atmModel)
      return "Undefined";

   return atmModel->GetTypeName();  // or should I go through the AtmManager?
}

//------------------------------------------------------------------------------
//  AtmosphereModel* GetAtmosphereModel()
//------------------------------------------------------------------------------
/**
 * This method returns a pointer to the current atmosphere model for the body.
 *
 * @return a pointer to the current atmosphere model for the body.
 *
 */
//------------------------------------------------------------------------------
AtmosphereModel* CelestialBody::GetAtmosphereModel()
{
   return atmModel;
}

//------------------------------------------------------------------------------
//  bool GetDensity(Real *position, Real *density, Real epoch, Integer count)
//------------------------------------------------------------------------------
/**
 * Calculates the atmospheric density at a specified location.
 *
 * Density if the core calculation provided by classes derived from this one.
 * The outpur array, density, must contain the density at the requested
 * locations, expressed in kg / m^3.
 *
 *  @param position  The input vector of spacecraft states
 *  @param density   The array of output densities
 *  @param epoch     The current TAIJulian epoch
 *  @param count     The number of spacecraft contained in position
 */
//------------------------------------------------------------------------------
bool CelestialBody::GetDensity(Real *position, Real *density, Real epoch,
                               Integer count)
{
   if (!atmModel) return false;
   return atmModel->Density(position,density,epoch,count);
}


//------------------------------------------------------------------------------
// A1Mjd GetTwoBodyEpoch() const
//------------------------------------------------------------------------------
A1Mjd CelestialBody::GetTwoBodyEpoch() const
{
   return twoBodyEpoch;
}


//------------------------------------------------------------------------------
// Rvector6 GetTwoBodyElements() const
//------------------------------------------------------------------------------
Rvector6 CelestialBody::GetTwoBodyElements() const
{
   return twoBodyKepler;
}

//------------------------------------------------------------------------------
// Gmat::RotationDataSource GetRotationDataSource() const
//------------------------------------------------------------------------------
Gmat::RotationDataSource CelestialBody::GetRotationDataSource() const
{
   return rotationSrc;
}

//------------------------------------------------------------------------------
// StringArray GetRotationDataSourceList() const
//------------------------------------------------------------------------------
StringArray CelestialBody::GetRotationDataSourceList() const
{
   StringArray srcList;
   for (unsigned int ii = 0; ii < Gmat::RotationDataSrcCount; ii++)
   {
//      // exclude NOT_APPLICABLE for now
//      if (Gmat::ROTATION_DATA_SOURCE_STRINGS[ii] != "NotApplicable")
         srcList.push_back(Gmat::ROTATION_DATA_SOURCE_STRINGS[ii]);
   }
   
   return srcList;
}


//------------------------------------------------------------------------------
// bool IsUserDefined() const
//------------------------------------------------------------------------------
bool CelestialBody::IsUserDefined() const
{
   return userDefined;
}


//------------------------------------------------------------------------------
// StringArray GetEphemSourceList() const
//------------------------------------------------------------------------------
StringArray CelestialBody::GetEphemSourceList() const
{
   StringArray srcList;
   for (int jj = 0; jj < Gmat::PosVelSourceCount; jj++)
   {
      std::string src = Gmat::POS_VEL_SOURCE_STRINGS[jj];
         
      if (userDefined)
      {
      #ifdef __USE_SPICE__
         if (!(GmatStringUtil::StartsWith(src, "DE")))
            srcList.push_back(Gmat::POS_VEL_SOURCE_STRINGS[jj]);  
      #else
            if ((!(GmatStringUtil::StartsWith(src, "DE"))) &&
                  (src.find("SPICE") == std::string::npos))
               srcList.push_back(Gmat::POS_VEL_SOURCE_STRINGS[jj]);  
      #endif
      }
      else if (!allowSpice)
      {
         if (src.find("SPICE") == std::string::npos)
            srcList.push_back(Gmat::POS_VEL_SOURCE_STRINGS[jj]);
      }
      else
      {
      #ifdef __USE_SPICE__
         srcList.push_back(Gmat::POS_VEL_SOURCE_STRINGS[jj]);
      #else
      if (src.find("SPICE") == std::string::npos)
         srcList.push_back(Gmat::POS_VEL_SOURCE_STRINGS[jj]);
      #endif
      }
   }
   return srcList;
}

//------------------------------------------------------------------------------
// Rvector6 GetOrientationParameters() const
//------------------------------------------------------------------------------
Rvector6 CelestialBody::GetOrientationParameters() const
{
   return orientation;
}


//------------------------------------------------------------------------------
//  bool SetBodyType(Gmat::BodyType bType)
//------------------------------------------------------------------------------
/**
 * This method sets the body type for the body.
 *
 * @param <bType> body type for the body.
 *
 * @return flag indicating success of the method.
 *
 */
//------------------------------------------------------------------------------
bool CelestialBody::SetBodyType(Gmat::BodyType bType)
{
   bodyType            = bType;
   return true; // will need to change default parameters here too, if they
                // are set to values that make no sense for this type of body?
}

//------------------------------------------------------------------------------
//  bool SetCentralBody(const std::string &cBody)
//------------------------------------------------------------------------------
/**
 * This method sets the central body for the body.
 *
 * @param <cBody> central body name for the body.
 *
 * @return flag indicating success of the method.
 *
 */
//------------------------------------------------------------------------------
bool CelestialBody::SetCentralBody(const std::string &cBody)
{
   theCentralBodyName = cBody;
   return true;
}

//------------------------------------------------------------------------------
//  bool SetGravitationalConstant(Real newMu)
//------------------------------------------------------------------------------
/**
 * This method sets the gravitational constant for the body.
 *
 * @param <newMw> gravitational constant (km^3/s^2) for the body.
 *
 * @exception <SolarSystemException> thrown if value is out of range
 * 
 * @return flag indicating success of the method.
 *
 */
//------------------------------------------------------------------------------
bool CelestialBody::SetGravitationalConstant(Real newMu)
{
   #ifdef DEBUG_CB_SET
      MessageInterface::ShowMessage("In CB::SetGravitationalConstant, newMu = %.14f\n",
            newMu);
   #endif
   if (newMu <= 0.0)
   {
      SolarSystemException sse;
      sse.SetDetails(errorMessageFormat.c_str(),
                     GmatStringUtil::ToString(newMu, GetDataPrecision()).c_str(),
                     "Mu", "Real Number > 0.0");
      throw sse;
   }
   
   mu                         = newMu;
   mass                       = mu / GmatPhysicalConstants::UNIVERSAL_GRAVITATIONAL_CONSTANT;
   return true;
}

//------------------------------------------------------------------------------
//  bool SetEquatorialRadius(Real newEqRadius)
//------------------------------------------------------------------------------
/**
 * This method sets the equatorial radius for the body.
 *
 * @param <newEqRadius> equatorial radius (km) for the body.
 *
 * @exception <SolarSystemException> thrown if value is out of range
 *
 * @return flag indicating success of the method.
 *
 */
//------------------------------------------------------------------------------
bool CelestialBody::SetEquatorialRadius(Real newEqRadius)
{
   #ifdef DEBUG_CB_SET
      MessageInterface::ShowMessage("In CB::SetEquatorialRadius, newEqRadius = %.14f\n",
            newEqRadius);
   #endif
   if (newEqRadius <= 0.0)
   {
      SolarSystemException sse;
      sse.SetDetails(errorMessageFormat.c_str(),
                     GmatStringUtil::ToString(newEqRadius, GetDataPrecision()).c_str(),
                     "Equatorial Radius", "Real Number > 0.0");
      throw sse;
   }
   
   equatorialRadius                 = newEqRadius;
   polarRadius                      = (1.0 - flattening) * equatorialRadius;
   return true;
}

//------------------------------------------------------------------------------
//  bool SetFlattening(Real flat)
//------------------------------------------------------------------------------
/**
 * This method sets the flattening value for the body.
 *
 * @param <flat> flattening value for the body.
 *
 * @return flag indicating success of the method.
 *
 */
//------------------------------------------------------------------------------
bool CelestialBody::SetFlattening(Real flat) 
{
   #ifdef DEBUG_CB_SET
      MessageInterface::ShowMessage("In CB::SetFlattening, flat = %.14f\n",
         flat);
   #endif
   if (flat < 0.0)
   {
      SolarSystemException sse;
      sse.SetDetails(errorMessageFormat.c_str(),
                     GmatStringUtil::ToString(flat, GetDataPrecision()).c_str(),
                     "Flattening", "Real Number >= 0.0");
      throw sse;
   }
   flattening                          = flat;
   polarRadius                         = (1.0 - flattening) * equatorialRadius;
   return true;
}

//------------------------------------------------------------------------------
//  bool SetMass(Real newMass)
//------------------------------------------------------------------------------
/**
 * This method sets the mass for the body.
 *
 * @param <newMass> mass (kg) for the body.
 *
 * @return flag indicating success of the method.
 *
 */
//------------------------------------------------------------------------------
//bool CelestialBody::SetMass(Real newMass) 
//{
//   mass = newMass;
//   return true;
//}

//------------------------------------------------------------------------------
//  bool SetSource(Gmat::PosVelSource pvSrc)
//------------------------------------------------------------------------------
/**
 * This method sets the position/velocity source for the body.
 *
 * @param <pcSrc> position/velocity source for the body.
 *
 * @return flag indicating success of the method.
 *
 */
//------------------------------------------------------------------------------
bool CelestialBody::SetSource(Gmat::PosVelSource pvSrc)
{
   #ifdef DEBUG_EPHEM_SOURCE
   MessageInterface::ShowMessage
      ("CelestialBody::SetSource() <%p> %s, Setting source to %d(%s)\n", this,
       GetName().c_str(), pvSrc, Gmat::POS_VEL_SOURCE_STRINGS[pvSrc].c_str());
   #endif
   
   if (pvSrc == posVelSrc) return true;

   if (pvSrc == Gmat::DE405)
   {
      if (userDefined)
      {
         std::string errmsg = "DE405 file option not available for user-defined body ";
         errmsg += instanceName + "\n";
         throw SolarSystemException(errmsg);
      }
   }
   if (pvSrc == Gmat::SPICE)
   {
      if ((!userDefined) && (!allowSpice))
      {
         std::string errmsg = "SPICE file option not available for default body ";
         errmsg += instanceName + "\n";
         throw SolarSystemException(errmsg);
      }
      spiceSetupDone = false;
   }
   posVelSrc           = pvSrc;
   return true;
}

//------------------------------------------------------------------------------
//  bool SetSourceFile(PlanetaryEphem *src)
//------------------------------------------------------------------------------
/**
 * This method sets the position/velocity source file for the body.
 *
 * @param <src> position/velocity source file for the body.
 *
 * @return flag indicating success of the method.
 *
 */
//------------------------------------------------------------------------------
bool CelestialBody::SetSourceFile(PlanetaryEphem *src)
{
   
   // should I delete the old one here???
   theSourceFile = src;
   sourceFilename = theSourceFile->GetName();
   bodyNumber = theSourceFile->GetBodyID(instanceName);
   #ifdef DEBUG_EPHEM_SOURCE
      MessageInterface::ShowMessage
         ("CelestialBody::SetSourceFile() <%p> %s, Setting source file to %p\n",
          this, GetName().c_str(), src);
      MessageInterface::ShowMessage("    and bodyId from source is %d\n", bodyNumber);
   #endif
   return true;
}

bool CelestialBody::SetAllowSpice(const bool allow)
{
   #ifdef DEBUG_CB_SPICE
      if (userDefined)
         MessageInterface::ShowMessage("Cannot set allowSpice flag for body %s - it is user-defined.\n",
               instanceName.c_str());
      else
         MessageInterface::ShowMessage("Setting allowSpice flag for body %s to %s\n",
               instanceName.c_str(), (allow? "true" : "false"));
   #endif
   if (!userDefined) allowSpice = allow; // set for default bodies only
   if (allowSpice)   spiceSetupDone = false;
   return true;
}

////------------------------------------------------------------------------------
////  bool SetAnalyticMethod(Gmat::AnalyticMethod aM)
////------------------------------------------------------------------------------
///**
//* This method sets the analytic method for the body.
// *
// * @param <aM> analytic method for the body.
// *
// * @return flag indicating success of the method.
// *
// */
////------------------------------------------------------------------------------
//bool CelestialBody::SetAnalyticMethod(Gmat::AnalyticMethod aM)
//{
//   analyticMethod = aM;
//   return true; 
//}

//------------------------------------------------------------------------------
//  bool SetUsePotentialFile(bool useIt)
//------------------------------------------------------------------------------
/**
 * This method sets the flag indicating whether or not to get the mu, radius,
 * and harmonic coefficients from the potential file.
 *
 * @param <useIt> use the potential file?.
 *
 * @return flag indicating success of the method.
 *
 */
//------------------------------------------------------------------------------
bool CelestialBody::SetUsePotentialFile(bool useIt)
{
   #ifdef DEBUG_CB_SET
   MessageInterface::ShowMessage
      ("CelestialBody::SetUsePotentialFile() this=<%p> '%s' entered, useIt=%d\n",
       this, GetName().c_str(), useIt);
   #endif
   
   if ((usePotentialFile == false) && (useIt == true))
   {
      potentialFileRead = false;
      isFirstTimeMu = true;
      isFirstTimeRadius = true;
   }
   else if ((usePotentialFile == true) && (useIt == false))
   {
//      mu               = defaultMu;
//      equatorialRadius = defaultEqRadius;
      mu               = default_mu;
      equatorialRadius = default_equatorialRadius;
      // recompute polar radius
      polarRadius = (1.0 - flattening) * equatorialRadius;
      // recompute mass
      mass = mu / GmatPhysicalConstants::UNIVERSAL_GRAVITATIONAL_CONSTANT;
      isFirstTimeMu = true;
      isFirstTimeRadius = true;
   }
   
   usePotentialFile    = useIt;
   return true;
}

//------------------------------------------------------------------------------
//  bool SetOverrideTimeSystem(bool overrideIt)
//------------------------------------------------------------------------------
/**
 * This method sets the time system override flag for the body 
 * (i.e. if true, TDB and TCB times will be overridden with TT times).
 *
 * @param <overrideIt> overrride TDB or TCB time with TT?.
 *
 * @return flag indicating success of the method.
 *
 */
//------------------------------------------------------------------------------
bool CelestialBody::SetOverrideTimeSystem(bool overrideIt)
{
   #ifdef DEBUG_CB_SET
   MessageInterface::ShowMessage
      ("CelestialBody::SetOverrideTimeSystem() <%p> '%s' entered, overrideIt=%d\n",
       this, GetName().c_str(), overrideIt);
   #endif
   overrideTime        = overrideIt;
   return true;
}


//------------------------------------------------------------------------------
// bool SetEphemUpdateInterval(Real intvl)
//------------------------------------------------------------------------------
bool CelestialBody::SetEphemUpdateInterval(Real intvl)
{
   if (intvl < 0.0)
   {
      SolarSystemException sse;
      sse.SetDetails(errorMessageFormat.c_str(),
                     GmatStringUtil::ToString(intvl, GetDataPrecision()).c_str(),
                     "Ephemeris Update Interval", "Real Number >= 0.0");
      throw sse;
   }
   ephemUpdateInterval = intvl;
   return true;
}


//------------------------------------------------------------------------------
// bool AddValidModelName(Gmat::ModelType m, const std::string &newModel)
//------------------------------------------------------------------------------
bool CelestialBody::AddValidModelName(Gmat::ModelType m, 
                                      const std::string &newModel)
{
   // first, make sure it is not already on the list
   if (find(models[(Integer)m].begin(), models[(Integer)m].end(),
            newModel) == models[(Integer)m].end())
      models[(Integer)m].push_back(newModel);
   // @todo modify it so it adds it before an 'Other' in the list
   
   return true;
   
}


//------------------------------------------------------------------------------
// bool RemoveValidModelName(Gmat::ModelType m, const std::string &modelName)
//------------------------------------------------------------------------------
bool CelestialBody::RemoveValidModelName(Gmat::ModelType m, 
                                         const std::string &modelName)
{
   // remove it, if it's on the list
   bool found = false;
   for (StringArray::iterator i = models[(Integer)m].begin();
        i != models[(Integer)m].end(); ++i)
   {
      if (*i == modelName)
      {
         models[(Integer)m].erase(i);
         found = true;
         break;
      }
   }
   return true;  // found?
}
   
bool CelestialBody::SetValidModelList(Gmat::ModelType m, const StringArray &toList)
{
   models[(Integer)m].clear();
   for (unsigned int ii = 0; ii < toList.size(); ii++)
      models[(Integer)m].push_back(toList.at(ii));
      
   return true;     
}

bool CelestialBody::SetOrder(Integer toOrder)
{
   order               = toOrder;
   return true;
}

bool CelestialBody::SetDegree(Integer toDegree)
{
   degree              = toDegree;
   return true;
}

//bool CelestialBody::SetHarmonicCoefficientsSij(const Rmatrix &coeffSij)
//{
//   sij                 = coeffSij;
//   return true;
//}
//
//bool CelestialBody::SetHarmonicCoefficientsCij(const Rmatrix &coeffCij)
//{
//   cij                 = coeffCij;
//   return true;
//}



//------------------------------------------------------------------------------
//  bool SetAtmosphereModelType(std::string toAtmModelType)
//------------------------------------------------------------------------------
/**
* This method sets the atmosphere model type for the body.
 *
 * @param <toAtmModel> name (type) of the atmosphere model to use.
 *
 * @return flag indicating success of the method.
 *
 * @note This method no longer sets the actual atmosphere model pointer.  A call
 *       to SetAtmosphereModel must be executed for that to happen.
 *
 */
//------------------------------------------------------------------------------
bool CelestialBody::SetAtmosphereModelType(std::string toAtmModelType)
{
   atmModelType        = toAtmModelType;
   return true;
}


//------------------------------------------------------------------------------
//  bool SetAtmosphereModel(AtmosphereModel *toAtmModel)
//------------------------------------------------------------------------------
/**
 * This method sets the atmosphere model pointer for the body.
 *
 * @param <toAtmModel> pointer to the atmosphere model to use.
 *
 * @return flag indicating success of the method.
 *
 */
//------------------------------------------------------------------------------
bool CelestialBody::SetAtmosphereModel(AtmosphereModel *toAtmModel)
{
   if (atmModel)
   {
      #ifdef DEBUG_MEMORY
      MemoryTracker::Instance()->Remove
         (atmModel, atmModel->GetName(), "CelestialBody::SetAtmosphereModel()",
          "deleting atmModel");
      #endif
      delete atmModel;
   }
   atmModel            = toAtmModel;
   return true;
}


//------------------------------------------------------------------------------
//  bool SetPotentialFilename(const std::string &fn)
//------------------------------------------------------------------------------
/**
 * This method sets potential file name for this HarmonicField object.
 *
 * @param <fn> full path name of the potential file name to use.
 *
 * @return flag indicating success of the operation.
 */
//------------------------------------------------------------------------------
bool CelestialBody::SetPotentialFilename(const std::string &fn)
{
   if (potentialFileName != fn)
   {
      potentialFileRead = false;
      isFirstTimeMu = true;
      isFirstTimeRadius = true;
   }
   
   potentialFileName   = fn;
   return true;
}


//------------------------------------------------------------------------------
// bool SetTwoBodyEpoch(const A1Mjd &toTime)
//------------------------------------------------------------------------------
bool CelestialBody::SetTwoBodyEpoch(const A1Mjd &toTime)
{
   #ifdef DEBUG_TWO_BODY
      MessageInterface::ShowMessage(
         "In CB::SetTwoBodyEpoch, setting epoch to %.12f\n", toTime.Get());
//      "In CB::SetAnalyticEpoch, setting epoch to %.12f\n", toTime.Get());
   #endif
   twoBodyEpoch        = toTime;
   newTwoBody          = true;
   return true;
}


//------------------------------------------------------------------------------
// bool SetSMA(Real value)
//------------------------------------------------------------------------------
/*
 * Sets SemimajorAxis of twoBody model state.
 *
 * @param  value  value of semimajor axis
 *
 * @exception <SolarSystemException> thrown if new value is out of range
 *
 */
//------------------------------------------------------------------------------
bool CelestialBody::SetSMA(Real value)
{
   if (value == 0.0)
   {
      SolarSystemException sse;
      sse.SetDetails(errorMessageFormat.c_str(),
                     GmatStringUtil::ToString(value, GetDataPrecision()).c_str(),
                     PARAMETER_TEXT[TWO_BODY_SMA - SpacePointParamCount].c_str(),
                     "Real Number != 0.0");
      throw sse;
   }
   
   twoBodyKepler[0]    = value;
   return true;
}


//------------------------------------------------------------------------------
// bool SetECC(Real value)
//------------------------------------------------------------------------------
/*
 * Sets Eccentricity of twoBody model state.
 *
 * @param  value  eccentricity value
 *
 * @exception <SolarSystemException> thrown if value is out of range
 *
 */
//------------------------------------------------------------------------------
bool CelestialBody::SetECC(Real value)
{
   if (value < 0.0)
   {
      SolarSystemException sse;
      sse.SetDetails(errorMessageFormat.c_str(),
                     GmatStringUtil::ToString(value, GetDataPrecision()).c_str(),
                     PARAMETER_TEXT[TWO_BODY_ECC - SpacePointParamCount].c_str(),
                     "Real Number >= 0.0");
      throw sse;
   }
   
   twoBodyKepler[1] = value;
   return true;
}


//------------------------------------------------------------------------------
// bool SetTwoBodyElements(const Rvector6 &kepl)
//------------------------------------------------------------------------------
bool CelestialBody::SetTwoBodyElements(const Rvector6 &kepl)
{
   #ifdef DEBUG_TWO_BODY
      MessageInterface::ShowMessage(
         "In CB::SetTwoBodyElements, setting elements to\n%.12f %.12f %.12f %.12f"
         " %.12f %.12f\n", kepl[0],kepl[1],kepl[2],kepl[3],kepl[4],kepl[5]);
//      "In CB::SetAnalyticElements, setting elements to\n%.12f %.12f %.12f %.12f"
//      " %.12f %.12f\n", kepl[0],kepl[1],kepl[2],kepl[3],kepl[4],kepl[5]);
   #endif
      
   SetSMA(kepl[0]);
   SetECC(kepl[1]);
   
//    if (kepl[0] == 0.0)
//    {
//       //std::string errMsg = "For body " + instanceName + 
//       //   ", SMA value must be non-zero"; 
//       std::stringstream buffer;
//       buffer << kepl[0];
//       std::string errMsg = "The value of \"" + buffer.str() + "\" for field \"" + 
//          PARAMETER_TEXT[TWO_BODY_SMA - SpacePointParamCount] + "\" on object \"" + instanceName +
//          "\" is not an allowed value.  \nThe allowed values are: " +
//          " [Real number non-zero]."; 
//       throw SolarSystemException(errMsg);
//    }
   
//    if (kepl[1] < 0.0)
//    {
//       //std::string errMsg = "For body " + instanceName + 
//       //   ", ECC value must be greater than or equal to zero"; 
//       std::stringstream buffer;
//       buffer << kepl[1];
//       std::string errMsg = "The value of \"" + buffer.str() + "\" for field " + 
//          PARAMETER_TEXT[TWO_BODY_ECC - SpacePointParamCount] + "\" on object \"" + instanceName +
//          "\" is not an allowed value.  \nThe allowed values are: " +
//          " [Real number >= zero]."; 
//       throw SolarSystemException(errMsg);
//    }
   
   twoBodyKepler       = kepl;
   newTwoBody          = true;
   return true;
}


//------------------------------------------------------------------------------
// bool SetRotationDataSource(Gmat::RotationDataSource src)
//------------------------------------------------------------------------------
bool CelestialBody::SetRotationDataSource(Gmat::RotationDataSource src)
{
   rotationSrc         = src;
   return true;
}

//------------------------------------------------------------------------------
// bool SetUserDefined(bool userDefinedBody)
//------------------------------------------------------------------------------
bool CelestialBody::SetUserDefined(bool userDefinedBody)
{
   // make sure source makes sense
   if ((userDefinedBody) && (posVelSrc == Gmat::DE405)) posVelSrc = Gmat::TWO_BODY_PROPAGATION;
   else if ((!userDefinedBody) && (!allowSpice) && (posVelSrc == Gmat::SPICE)) posVelSrc = Gmat::DE405;
   userDefined         = userDefinedBody;
   if (userDefined) allowSpice = true;
   #ifdef DEBUG_CB_USER_DEFINED
      MessageInterface::ShowMessage(
            "In CB::SetUserDefined, body %s has been set to userDefined = %s and allowSpice = %s\n",
            instanceName.c_str(), (userDefined? "true" : "false"),
            (allowSpice? "true" : "false"));
   #endif
   // we DO want to show the all parameters and the Create line when writing the user-defined 
   // Celestial Body data out to a script
   cloaking = false;

   return true;
}


//------------------------------------------------------------------------------
// const Rvector6 GetMJ2000State(const A1Mjd &atTime)
//------------------------------------------------------------------------------
const Rvector6 CelestialBody::GetMJ2000State(const A1Mjd &atTime)
{
   #ifdef DEBUG_CB_GET_MJ2000_STATE
   MessageInterface::ShowMessage("In GetMJ2000State, body is %s, time is %12.10f\n",
         instanceName.c_str(), atTime.Get());
   MessageInterface::ShowMessage("In GetMJ2000State, j2000Body is %s\n",
         (j2000Body->GetName()).c_str());
   #endif
   if (j2000Body == NULL)
      throw SolarSystemException
         ("CelestialBody::GetMJ2000State() j2000Body is NULL for " + instanceName);
   
   // If j2000Body is this body, return the zero state vector
   if(j2000Body->GetName() == instanceName) 
      return Rvector6(0.0, 0.0, 0.0, 0.0, 0.0, 0.0);
   
   Rvector6         stateEphem    = GetState(atTime);
   Rvector6         j2kEphemState;
   Gmat::ObjectType ot            = j2000Body->GetType();
   if (ot == Gmat::CELESTIAL_BODY)
   {
      j2kEphemState = ((CelestialBody*)j2000Body)->GetState(atTime);
   }
   else if (ot == Gmat::CALCULATED_POINT)
   {
      // @todo fill in with calculated point stuff when it's done
      //j2kEphemState = ((CalculatedPoint*)j2000Body)->GetState(atTime);
   }
   else
   {
      throw SolarSystemException("j2000Body is of incorrect type.");
   }
   
   #ifdef DEBUG_GET_STATE
   MessageInterface::ShowMessage
      ("CelestialBody::GetMJ2000State() stateEphem =\n   %s\n",
       stateEphem.ToString().c_str());
   MessageInterface::ShowMessage
      ("CelestialBody::GetMJ2000State() j2kEphemState =\n   %s\n",
       j2kEphemState.ToString().c_str());
   #endif
#ifdef DEBUG_CB_GET_MJ2000_STATE
   Rvector6 theState = stateEphem - j2kEphemState;
//   Real utcTime   = TimeConverterUtil::Convert(atTime.Get(), TimeConverterUtil::A1MJD, 
//                    TimeConverterUtil::UTCMJD, GmatTimeConstants::JD_JAN_5_1941);
   Real ttTime    = TimeConverterUtil::Convert(atTime.Get(), TimeConverterUtil::A1MJD, 
                    TimeConverterUtil::TTMJD, GmatTimeConstants::JD_JAN_5_1941);
   Real tdbTime   = TimeConverterUtil::Convert(atTime.Get(), TimeConverterUtil::A1MJD, 
                    TimeConverterUtil::TDBMJD, GmatTimeConstants::JD_JAN_5_1941);
   MessageInterface::ShowMessage(
         "Body: %s   TT(TDB) Time: %12.10f (%12.10f)   state:  %12.10f  %12.10f  %12.10f  %12.10f  %12.10f  %12.10f\n",
         instanceName.c_str(), ttTime, tdbTime, 
         theState[0], theState[1], theState[2], theState[3], theState[4], theState[5]);
#endif
   // SPICE does the subtraction itself
   if (posVelSrc == Gmat::SPICE)
      return stateEphem;
   else // DE or TwoBodyPropagation
      return (stateEphem - j2kEphemState);
}


//------------------------------------------------------------------------------
// const Rvector3 GetMJ2000Position(const A1Mjd &atTime)
//------------------------------------------------------------------------------
const Rvector3 CelestialBody::GetMJ2000Position(const A1Mjd &atTime)
{
   Rvector6 tmp = GetMJ2000State(atTime);
   return (tmp.GetR());
}


//------------------------------------------------------------------------------
// const Rvector3 GetMJ2000Velocity(const A1Mjd &atTime)
//------------------------------------------------------------------------------
const Rvector3 CelestialBody::GetMJ2000Velocity(const A1Mjd &atTime)
{
   Rvector6 tmp = GetMJ2000State(atTime);
   return (tmp.GetV());
}

bool CelestialBody::SetOrientationParameters(const Rvector6 &orient)
{
   orientation         = orient;
   return true;
}


//------------------------------------------------------------------------------
//  Rvector GetBodyCartographicCoordinates(const A1Mjd &forTime) const
//------------------------------------------------------------------------------
/**
 * This method returns the cartographic coordinates for the body.
 *
 * @return vector containing alpha, delta, W, Wdot, where:
 *         alpha is the right ascension of the north pole of rotation
 *         delta is the declination of the north pole of rotation
 *         W specifies the ephemeris position of the prime meridian
 *         Wdot specifies the time derivative of W
 *
 * @note currently only implemented for the Star, Planets, and Major Moons of
 *       our Solar System.
 * @note currently, this method only handles the IAU_SIMPLIFIED option; others 
 *       are handled in the child classes, e.g. Luna in Moon class, etc.
 *
 */
//------------------------------------------------------------------------------
Rvector CelestialBody::GetBodyCartographicCoordinates(const A1Mjd &forTime) const
{
   if (rotationSrc == Gmat::IAU_SIMPLIFIED)
   {
      bool orientationDefined = false;
      for (unsigned int ii = 0; ii < 6; ii++)
         if (orientation[ii] != 0.0)  
         {
            orientationDefined = true;
            break;
         }
      if (!orientationDefined)
         throw SolarSystemException(
            "Orientation parameters not yet set for body " + instanceName);
      Real alpha = 0;
      Real delta = 0;
      Real W     = 0;
      Real Wdot  = 0.0; 
      Real d = GetJulianDaysFromTCBEpoch(forTime); // interval in Julian days
      Real T = d / GmatTimeConstants::DAYS_PER_JULIAN_CENTURY; // interval in Julian centuries
      
      alpha = orientation[0]  + orientation[1] * T;
      delta = orientation[2]  + orientation[3] * T;
      W     = orientation[4]  + orientation[5] * d;
      Wdot  = orientation[5]  * CelestialBody::dDot;
      #ifdef DEBUG_CB_CARTOGRAPHIC
//      if ((forTime.Get() > 23158.005) && (forTime.Get() < 23158.006))
//      {
         MessageInterface::ShowMessage("returning cartographic coordinates for body %s at time %12.10f:\n",
                                       instanceName.c_str(), forTime.Get());
         MessageInterface::ShowMessage("   alpha = %12.10f    delta = %12.10f    W = %12.10f    Wdot = %12.10f    d = %12.10f    T = %12.10f  dDot = %12.10f\n",
                                       alpha, delta, W, Wdot, d, T, CelestialBody::dDot);
         MessageInterface::ShowMessage("   orientation array = %s\n", orientation.ToString().c_str());
//      }
      #endif
      return Rvector(4, alpha, delta, W, Wdot);
   }
   else
   {
      std::string errmsg = "Cannot compute cartographic coordinates for body ";
      errmsg += instanceName + "\n";
      throw SolarSystemException(errmsg);
   }
}


//------------------------------------------------------------------------------
//  bool SetPhysicalParameters(Real bodyMass, Real bodyEqRad,
//                             Real bodyPolarRad, Real bodyMu,
//                             Integer coeffSize, Rmatrix& bodySij,
//                             Rmatrix& bodyCij);
//------------------------------------------------------------------------------
/**
 * This method sets the physical parameters for the body.
 *
 * @param <bodyMass>     mass (kg) of the body.
 * @param <bodyMEqRad>   equatorial radius (km) of the body.
 * @param <bodyPolarRad> polar radius (km) of the body.
 * @param <bodyMu>       gravitational constant (km^3/s^2) of the body.
 * @param <coeffSize>    size of Sij and Cij for the body.
 * @param <bodySij>      coefficients Sij for the body (coeffSize x coeffSize).
 * @param <bodyCij>      coefficients Cij for the body (coeffSize x coeffSize).
 *
 * @return flag indicating success of the method.
 *
 * @exception <SolarSystemException> thrown if there is an error in the
 *                                   input data.
 */
//------------------------------------------------------------------------------
//bool CelestialBody::SetPhysicalParameters(Real bodyMass, Real bodyEqRad,
//                                          Real bodyPolarRad, Real bodyMu,
//                                          Integer coeffSize, Rmatrix &bodySij,
//                                          Rmatrix &bodyCij)
//{
//   // add data checks later <-
//   mass             = bodyMass;
//   equatorialRadius = bodyEqRad;
//   polarRadius      = bodyPolarRad;
//   mu               = bodyMu;
//   coefficientSize  = coeffSize;
//   Integer r,c;
//   try
//   {
//      bodySij.GetSize(r,c);
//      sij = bodySij;
//   }
//   catch (TableTemplateExceptions::IllegalSize& tte)
//   {
//      throw SolarSystemException("Sij input to body has no dimensions.");
//   }
//   try
//   {
//      bodyCij.GetSize(r,c);
//      cij = bodyCij;
//   }
//   catch (TableTemplateExceptions::IllegalSize& tte)
//   {
//      throw SolarSystemException("Cij input to body has no dimensions.");
//   }
//   return true;
//}
//------------------------------------------------------------------------------
//  std::string  GetParameterText(const Integer id) const
//------------------------------------------------------------------------------
/**
 * This method returns the parameter text, given the input parameter ID.
 *
 * @param <id> Id for the requested parameter text.
 *
 * @return parameter text for the requested parameter.
 *
 */
//------------------------------------------------------------------------------
std::string CelestialBody::GetParameterText(const Integer id) const
{
   if (id >= SpacePointParamCount && id < CelestialBodyParamCount)
      return PARAMETER_TEXT[id - SpacePointParamCount];
   return SpacePoint::GetParameterText(id);
}

//------------------------------------------------------------------------------
//  Integer  GetParameterID(const std::string &str) const
//------------------------------------------------------------------------------
/**
 * This method returns the parameter ID, given the input parameter string.
 *
 * @param <str> string for the requested parameter.
 *
 * @return ID for the requested parameter.
 *
 */
//------------------------------------------------------------------------------
Integer     CelestialBody::GetParameterID(const std::string &str) const
{
   for (Integer i = SpacePointParamCount; i < CelestialBodyParamCount; i++)
   {
      if (str == PARAMETER_TEXT[i - SpacePointParamCount])
         return i;
   }
   
   return SpacePoint::GetParameterID(str);
}

//------------------------------------------------------------------------------
//  Gmat::ParameterType  GetParameterType(const Integer id) const
//------------------------------------------------------------------------------
/**
 * This method returns the parameter type, given the input parameter ID.
 *
 * @param <id> ID for the requested parameter.
 *
 * @return parameter type of the requested parameter.
 *
 */
//------------------------------------------------------------------------------
Gmat::ParameterType CelestialBody::GetParameterType(const Integer id) const
{
   if (id >= SpacePointParamCount && id < CelestialBodyParamCount)
      return PARAMETER_TYPE[id - SpacePointParamCount];
      
   return SpacePoint::GetParameterType(id);
}

//------------------------------------------------------------------------------
//  std::string  GetParameterTypeString(const Integer id) const
//------------------------------------------------------------------------------
/**
 * This method returns the parameter type string, given the input parameter ID.
 *
 * @param <id> ID for the requested parameter.
 *
 * @return parameter type string of the requested parameter.
 *
 */
//------------------------------------------------------------------------------
std::string CelestialBody::GetParameterTypeString(const Integer id) const
{
   return SpacePoint::PARAM_TYPE_STRING[GetParameterType(id)];
}

//------------------------------------------------------------------------------
//  Real  GetRealParameter(const Integer id) const
//------------------------------------------------------------------------------
/**
 * This method returns the Real parameter value, given the input parameter ID.
 *
 * @param <id> ID for the requested parameter value.
 *
 * @return  Real value of the requested parameter.
 *
 */
//------------------------------------------------------------------------------
Real        CelestialBody::GetRealParameter(const Integer id) const
{
   if (id == MASS)               return mass;
   if (id == EQUATORIAL_RADIUS)  return equatorialRadius;
   if (id == FLATTENING)         return flattening;
   if (id == POLAR_RADIUS)       return polarRadius;
   if (id == MU)                 return mu;
   if (id == HOUR_ANGLE)         return hourAngle;

   // DJC, 06/15/05: Temporarily put an accessor in place to help debug the
   // force model.  This piece may be replaced by a different call when epoch
   // issues are updated in the Spacecraft/SpaceObject code.
   if (id == STATE_TIME)              return stateTime.Get();
   
   if (id == TWO_BODY_INITIAL_EPOCH)  return twoBodyEpoch.Get();
   if (id == TWO_BODY_SMA)            return twoBodyKepler[0];
   if (id == TWO_BODY_ECC)            return twoBodyKepler[1];
   if (id == TWO_BODY_INC)            return twoBodyKepler[2];
   if (id == TWO_BODY_RAAN)           return twoBodyKepler[3];
   if (id == TWO_BODY_AOP)            return twoBodyKepler[4];
   if (id == TWO_BODY_TA)             return twoBodyKepler[5];

   if (id == ORIENTATION_EPOCH)       return orientationEpoch.Get();
   if (id == SPIN_AXIS_RA_CONSTANT)   return orientation[0];
   if (id == SPIN_AXIS_RA_RATE)       return orientation[1];
   if (id == SPIN_AXIS_DEC_CONSTANT)  return orientation[2];
   if (id == SPIN_AXIS_DEC_RATE)      return orientation[3];
   if (id == ROTATION_CONSTANT)       return orientation[4];
   if (id == ROTATION_RATE)           return orientation[5];

   return SpacePoint::GetRealParameter(id);
}

//------------------------------------------------------------------------------
//  Real  SetRealParameter(const Integer id, const Real value)
//------------------------------------------------------------------------------
/**
 * This method sets the Real parameter value, given the input parameter ID.
 *
 * @param <id> ID for the parameter whose value to change.
 * @param <value> value for the parameter.
 *
 * @return  Real value of the requested parameter.
 *
 */
//------------------------------------------------------------------------------
Real CelestialBody::SetRealParameter(const Integer id, const Real value)
{
   Rvector6 tmpKepl = twoBodyKepler;
   #ifdef DEBUG_CB_SET
      MessageInterface::ShowMessage("In CB::SetReal with id = %d, and value = %.14f\n",
      id, value);
   #endif
      
   //if (id == MASS)              return (mass               = value); // make sense?
   if (id == EQUATORIAL_RADIUS)
   {
      return SetEquatorialRadius(value);
   }
   if (id == FLATTENING)
   {
//      flattening          = value;
//      polarRadius         = (1.0 - flattening) * equatorialRadius;
      return SetFlattening(value);
//      return true;
   }
   //if (id == POLAR_RADIUS)      return (polarRadius        = value); // make sense?
   if (id == MU)
   {
      return SetGravitationalConstant(value);
   }
   if (id == HOUR_ANGLE) // does this even make sense?
   { 
      hourAngle           = value;
      return true;
   }
   if (id == TWO_BODY_INITIAL_EPOCH)
   {
//      if (SetAnalyticEpoch(A1Mjd(value)))
      if (SetTwoBodyEpoch(A1Mjd(value)))
      {
         newTwoBody          = true;
         return true;
      }
      else return false;
   }
   if (id == TWO_BODY_SMA)
   {
      tmpKepl[0] = value;
//      if (SetAnalyticElements(tmpKepl)) 
      if (SetTwoBodyElements(tmpKepl)) 
      {
         newTwoBody          = true;
         return true;
      }
      else return false;
   }
   if (id == TWO_BODY_ECC)
   {
      tmpKepl[1] = value;
//      if (SetAnalyticElements(tmpKepl)) 
      if (SetTwoBodyElements(tmpKepl)) 
      {
         newTwoBody          = true;
         return true;
      }
      else return false;
   }
   if (id == TWO_BODY_INC)
   {
      tmpKepl[2] = value;
//      if (SetAnalyticElements(tmpKepl)) 
      if (SetTwoBodyElements(tmpKepl)) 
      {
         newTwoBody          = true;
         return true;
      }
      else return false;
   }
   if (id == TWO_BODY_RAAN)
   {
      tmpKepl[3] = value;
//      if (SetAnalyticElements(tmpKepl)) 
      if (SetTwoBodyElements(tmpKepl)) 
      {
         newTwoBody          = true;
         return true;
      }
      else return false;
   }
   if (id == TWO_BODY_AOP)
   {
      tmpKepl[4] = value;
//      if (SetAnalyticElements(tmpKepl)) 
      if (SetTwoBodyElements(tmpKepl)) 
      {
         newTwoBody          = true;
         return true;
      }
      else return false;
   }
   if (id == TWO_BODY_TA)
   {
      tmpKepl[5] = value;
//      if (SetAnalyticElements(tmpKepl)) 
      if (SetTwoBodyElements(tmpKepl)) 
      {
         newTwoBody          = true;
         return true;
      }
      else return false;
   }

   // for now, don't allow user to modify orientation parameters for default bodies
   if (userDefined)
   {
      if (id == ORIENTATION_EPOCH)
      {
         orientationEpoch    = value;
         return true;
      }
      if (id == SPIN_AXIS_RA_CONSTANT)
      {
         orientation[0]      = value;
         return true;
      }
      if (id == SPIN_AXIS_RA_RATE)
      {
         orientation[1]      = value;
         return true;
      }
      if (id == SPIN_AXIS_DEC_CONSTANT)
      {
         orientation[2]      = value;
         return true;
      }
      if (id == SPIN_AXIS_DEC_RATE)
      {
         orientation[3]      = value;
         return true;
      }
      if (id == ROTATION_CONSTANT)
      {
         orientation[4]      = value;
         return true;
      }
      if (id == ROTATION_RATE)
      {
         orientation[5]      = value;
         return true;
      }
   }
   else // for default bodies, we are currently not allowing the user to modify these
   {
      if ((id == ORIENTATION_EPOCH)      || 
          (id == SPIN_AXIS_RA_CONSTANT)  || (id == SPIN_AXIS_RA_RATE)  ||
          (id == SPIN_AXIS_DEC_CONSTANT) || (id == SPIN_AXIS_DEC_RATE) ||
          (id == ROTATION_CONSTANT)      || (id == ROTATION_RATE))
      {
         std::string errmsg = "Modification of orientation parameters for default body ";
         errmsg += instanceName + " is not allowed.\n";
         throw SolarSystemException(errmsg);
      }
   }

   #ifdef DEBUG_TWO_BODY
      MessageInterface::ShowMessage(
      "At end of CB::SetReal, Keplerian elements are %.14f %.14f %.14f %.14f %.14f %.14f\n",
      twoBodyKepler[0],twoBodyKepler[1],twoBodyKepler[2],twoBodyKepler[3],
      twoBodyKepler[4],twoBodyKepler[5]);
      MessageInterface::ShowMessage(
      "..... and epoch is: %.14f\n",twoBodyEpoch.Get());
   #endif
   
   return SpacePoint::SetRealParameter(id, value);
}

//------------------------------------------------------------------------------
//  Integer  GetIntegerParameter(const Integer id) const
//------------------------------------------------------------------------------
/**
 * This method returns the Integer parameter value, given the input
 * parameter ID.
 *
 * @param <id> ID for the requested parameter.
 *
 * @return  Integer value of the requested parameter.
 *
 */
//------------------------------------------------------------------------------
Integer CelestialBody::GetIntegerParameter(const Integer id) const
{
   if (id == ORDER)                return order;
   if (id == DEGREE)               return degree;
   if (id == BODY_NUMBER)          return bodyNumber;
   if (id == REF_BODY_NUMBER)      return referenceBodyNumber;
   if (id == ROTATION_DATA_SRC)    return (Integer) rotationSrc;
//   if (id == NAIF_ID)              return naifId;   // moved to SpacePoint  wcs  2009.12.28
   
   return SpacePoint::GetIntegerParameter(id); // add others in later?
}

//------------------------------------------------------------------------------
//  Integer  SetIntegerParameter(const Integer id, const Integer value)
//------------------------------------------------------------------------------
/**
 * This method sets the Integer parameter value, given the input
 * parameter ID.
 *
 * @param <id> ID for the requested parameter.
 * @param <value> Integer value for the requested parameter.
 *
 * @return  Integer value of the requested parameter.
 *
 */
//------------------------------------------------------------------------------
Integer CelestialBody::SetIntegerParameter(const Integer id,
                                           const Integer value)
{
   if (id == ORDER)
   {
      order               = value;
      return true;
   }
   if (id == DEGREE)
   {
      degree              = value;
      return true;
   }
   if (id == BODY_NUMBER)
   {
      bodyNumber          = value;
      return true;
   }
   if (id == REF_BODY_NUMBER)
   {
      referenceBodyNumber = value;
      return true;
   }
//   if (id == NAIF_ID)    // moved to SpacePoint  wcs  2009.12.28
//   {
//      naifId              = value;
//      return true;
//   }
   
   return SpacePoint::SetIntegerParameter(id,value);  // add others in later
}

//------------------------------------------------------------------------------
//  std::string  GetStringParameter(const Integer id) const
//------------------------------------------------------------------------------
/**
 * This method returns the string parameter value, given the input
 * parameter ID.
 *
 * @param <id> ID for the requested parameter.
 *
 * @return  string value of the requested parameter.
 *
 */
//------------------------------------------------------------------------------
std::string CelestialBody::GetStringParameter(const Integer id) const
{
   if (id == BODY_TYPE)             return Gmat::BODY_TYPE_STRINGS[bodyType];
   if (id == POS_VEL_SOURCE)        return Gmat::POS_VEL_SOURCE_STRINGS[posVelSrc];
//   if (id == ANALYTIC_METHOD)       return Gmat::TWO_BODY_METHOD_STRINGS[analyticMethod];
   if (id == SOURCE_FILENAME)       return sourceFilename;
   if (id == SOURCE_FILE)           return sourceFilename;

   if (id == POTENTIAL_FILE_NAME)   return potentialFileName;
   if (id == ATMOS_MODEL_NAME)
   {
      if (atmModel == NULL) return "";
      return atmModel->GetTypeName();
   }
   if (id == CENTRAL_BODY)          return theCentralBodyName;
   if (id == TWO_BODY_DATE_FORMAT)  return twoBodyFormat;
   if (id == TWO_BODY_STATE_TYPE)   return twoBodyStateType;
   if (id == ROTATION_DATA_SRC)     return Gmat::ROTATION_DATA_SOURCE_STRINGS[rotationSrc];

   if (id == ORIENTATION_DATE_FORMAT)  return orientationDateFormat;
   
   if (id == TEXTURE_MAP_FILE_NAME)    return textureMapFileName;

   return SpacePoint::GetStringParameter(id);
}

std::string CelestialBody::GetStringParameter(const Integer id,
                                              const Integer index) const
{   
   return SpacePoint::GetStringParameter(id, index);
}


//------------------------------------------------------------------------------
//  bool  SetStringParameter(const Integer id, const std::string value)
//------------------------------------------------------------------------------
/**
 * This method sets the string parameter value, given the input
 * parameter ID.
 *
 * @param <id> ID for the requested parameter.
 * @param <value> string value for the requested parameter.
 *
 * @exception <SolarSystemException> thrown if value is out of range
 *
 * @return  success flag.
 *
 */
//------------------------------------------------------------------------------
bool CelestialBody::SetStringParameter(const Integer id,
                                       const std::string &value) // const?
{
   #ifdef DEBUG_CB_SET_STRING
   std::string idString = GetParameterText(id);
   MessageInterface::ShowMessage
      ("CelestialBody::SetStringP:: id = %d (%s), value = %s\n",
       id, idString.c_str(), value.c_str());
   #endif
   int i;
   if (id == BODY_TYPE)
   {
      for (i=0;i<Gmat::BodyTypeCount;i++)
         if (value == Gmat::BODY_TYPE_STRINGS[i])
         {
            bodyType = (Gmat::BodyType) i;
            return true;
         }
      return false;
   }
   if (id == POS_VEL_SOURCE)
   {
      if (userDefined && (value == "DE405"))
      {
         std::string errmsg = "DE405 not allowed as ephemeris source for user-defined body \"";
         errmsg += instanceName + "\"\n";
         throw SolarSystemException(errmsg);
      }
      else if ((!userDefined) && !allowSpice && (value == "SPICE"))
      {
         std::string errmsg = "SPICE not allowed as ephemeris source for default body \"";
         errmsg += instanceName + "\"\n";
         throw SolarSystemException(errmsg);
      }
      for (i=0;i<Gmat::PosVelSourceCount;i++)
         if (value == Gmat::POS_VEL_SOURCE_STRINGS[i])
         {
            posVelSrc = (Gmat::PosVelSource) i;
            return true;
         }
      return false;
   }
   if (id == SOURCE_FILENAME)
   {
      if (!(GmatFileUtil::DoesFileExist(value)))
      {
         SolarSystemException sse;
         sse.SetDetails(errorMessageFormat.c_str(),
                        value.c_str(), "SourceFilename", "File must exist");
         throw sse;
      }
      sourceFilename = value;
      return true;
   }
   if (id == POTENTIAL_FILE_NAME)
   {
      if (!(GmatFileUtil::DoesFileExist(value)))
      {
         SolarSystemException sse;
         sse.SetDetails(errorMessageFormat.c_str(),
                        value.c_str(), "PotentialFileName", "File must exist");
         throw sse;
      }
      potentialFileName = value;
      return true;
   }
   if (id == ATMOS_MODEL_NAME)
   {
      atmModelType = value;
      return true;
   }
   if (id == CENTRAL_BODY)
   {
      theCentralBodyName = value;
      return true;
   }
   if (id == TWO_BODY_DATE_FORMAT)
   {
      #ifdef DEBUG_TWO_BODY
         MessageInterface::ShowMessage(
         "In CB::SetString (TWO_BODY_DATE_FORMAT) with id = %d, and value = %s\n",
         id, value.c_str());
      #endif
      if (value != "TAIModJulian")
      {
         SolarSystemException sse;
         sse.SetDetails(errorMessageFormat.c_str(), value.c_str(),
                        PARAMETER_TEXT[TWO_BODY_DATE_FORMAT - SpacePointParamCount].c_str(),
                        "TAIModJulian");
         throw sse;
      }
      twoBodyFormat = value;
      return true;
   }
   if (id == TWO_BODY_STATE_TYPE)
   {
      #ifdef DEBUG_TWO_BODY
         MessageInterface::ShowMessage(
         "In CB::SetString (TWO_BODY_STATE_TYPE) with id = %d, and value = %s\n",
         id, value.c_str());
      #endif
      if (value != "Keplerian")
      {
         SolarSystemException sse;
         sse.SetDetails(errorMessageFormat.c_str(), value.c_str(),
                        PARAMETER_TEXT[TWO_BODY_STATE_TYPE - SpacePointParamCount].c_str(),
                        "Keplerian");
         
         throw sse;
      }
      twoBodyStateType = value;
      return true;
   }
   
   if (id == ROTATION_DATA_SRC)
   {
      if (value == Gmat::ROTATION_DATA_SOURCE_STRINGS[Gmat::DE_405_FILE])
         SetRotationDataSource(Gmat::DE_405_FILE);
      else if (value == Gmat::ROTATION_DATA_SOURCE_STRINGS[Gmat::IAU_2002])
         SetRotationDataSource(Gmat::IAU_2002);
      else if (value == Gmat::ROTATION_DATA_SOURCE_STRINGS[Gmat::FK5_IAU_1980])
         SetRotationDataSource(Gmat::FK5_IAU_1980);
      else if (value == Gmat::ROTATION_DATA_SOURCE_STRINGS[Gmat::IAU_SIMPLIFIED])
         SetRotationDataSource(Gmat::IAU_SIMPLIFIED);
      else
      {
         std::string errmsg = "Unrecognized Rotation Data Source \"";
         errmsg += value + "\" for body ";
         errmsg += instanceName + "\n";
         throw SolarSystemException(errmsg);
      }
      return true;
   }

   if (id == ORIENTATION_DATE_FORMAT)
   {
      if (value != "TAIModJulian")
      {
         SolarSystemException sse;
         sse.SetDetails(errorMessageFormat.c_str(), value.c_str(),
                        PARAMETER_TEXT[ORIENTATION_DATE_FORMAT - SpacePointParamCount].c_str(),
                        "TAIModJulian");
         throw sse;
      }
      orientationDateFormat = value;;
      return true;
   }

   if (id == TEXTURE_MAP_FILE_NAME)
   {
      textureMapFileName = value;
      return true;
   }

   return SpacePoint::SetStringParameter(id, value);
}
   
bool CelestialBody::SetStringParameter(const Integer id, const std::string &value,
                                       const Integer index)
{
   return SpacePoint::SetStringParameter(id, value, index);
}


//------------------------------------------------------------------------------
//  bool  GetBooleanParameter(const Integer id) const
//------------------------------------------------------------------------------
/**
 * This method returns the bool parameter value, given the input
 * parameter ID.
 *
 * @param <id> ID for the requested parameter.
 *
 * @return  bool value of the requested parameter.
 *
 */
//------------------------------------------------------------------------------
bool CelestialBody::GetBooleanParameter(const Integer id) const
{
   if (id == USE_POTENTIAL_FILE_FLAG)       return usePotentialFile;

   return SpacePoint::GetBooleanParameter(id);
}

//------------------------------------------------------------------------------
//  bool  SetBooleanParameter(const Integer id, const std::string value)
//------------------------------------------------------------------------------
/**
 * This method sets the bool parameter value, given the input
 * parameter ID.
 *
 * @param <id> ID for the requested parameter.
 * @param <value> bool value for the requested parameter.
 *
 * @return  success flag.
 *
 */
//------------------------------------------------------------------------------
bool CelestialBody::SetBooleanParameter(const Integer id,
                                        const bool value) // const?
{
   if (id == USE_POTENTIAL_FILE_FLAG)
   {
      if ((usePotentialFile == false) && (value == true))
      {
         potentialFileRead = false;
         isFirstTimeMu = true;
         isFirstTimeRadius = true;
      }
      else if ((usePotentialFile == true) && (value == false))
      {
//         mu               = defaultMu;
//         equatorialRadius = defaultEqRadius;
         mu               = default_mu;
         equatorialRadius = default_equatorialRadius;
         // recompute polar radius
         polarRadius = (1.0 - flattening) * equatorialRadius;
         // recompute mass
         mass = mu / GmatPhysicalConstants::UNIVERSAL_GRAVITATIONAL_CONSTANT;
         isFirstTimeMu = true;
         isFirstTimeRadius = true;
      }
   
      usePotentialFile = value;
      return true; 
   }

   return SpacePoint::SetBooleanParameter(id,value);
}

//------------------------------------------------------------------------------
//  const Rvector&  GetRvectorParameter(const Integer id)
//------------------------------------------------------------------------------
/**
 * This method gets the Rvector parameter value, given the input
 * parameter ID.
 *
 * @param <id> ID for the requested parameter.
 *
 * @return  success flag.
 *
 */
//------------------------------------------------------------------------------
const Rvector&  CelestialBody::GetRvectorParameter(const Integer id) const
{
   if (id == STATE)               return state;
   if (id == ANGULAR_VELOCITY)    return angularVelocity;

   return SpacePoint::GetRvectorParameter(id);
}

//------------------------------------------------------------------------------
//  const Rvector&  SetRvectorParameter(const Integer id, const Rvector& value)
//------------------------------------------------------------------------------
/**
 * This method sets the Rvector parameter value, given the input
 * parameter ID.
 *
 * @param <id> ID for the requested parameter.
 * @param <value> Rvector value for the requested parameter.
 *
 * @return  success flag.
 *
 */
//------------------------------------------------------------------------------
const Rvector&  CelestialBody::SetRvectorParameter(const Integer id,
                                              const Rvector &value)
{
   Integer sz = value.GetSize();
   Integer i;
   
   if (id == STATE)
   {
      if (sz != 6) throw SolarSystemException(
                  "Incorrectly sized Rvector passed in for state.");
      for (i=0;i<6;i++) state(i) = value(i);
      return state;
   }
   if (id == ANGULAR_VELOCITY)
   {
      if (sz != 3) throw SolarSystemException(
                   "Incorrectly sized Rvector passed in for angular velocity.");
      for (i=0;i<3;i++) angularVelocity(i) = value(i);
      return angularVelocity;
   }

   return SpacePoint::SetRvectorParameter(id,value);
}

//------------------------------------------------------------------------------
//  const Rvector&  GetRvectorParameter(const std::string &label)
//------------------------------------------------------------------------------
/**
 * This method gets the Rvector parameter value, given the input
 * parameter ID.
 *
 * @param <label> string ID for the requested parameter.
 *
 * @return  success flag.
 *
 */
//------------------------------------------------------------------------------
const Rvector& CelestialBody::GetRvectorParameter(const std::string &label) const
{
   return GetRvectorParameter(GetParameterID(label));
}

//------------------------------------------------------------------------------
//  const Rvector&  SetRvectorParameter(const std::string &label,
//                                      const Rvector& value)
//------------------------------------------------------------------------------
/**
 * This method sets the Rvector parameter value, given the input
 * parameter ID.
 *
 * @param <label> string ID for the requested parameter.
 * @param <value> Rvector value for the requested parameter.
 *
 * @return  success flag.
 *
 */
//------------------------------------------------------------------------------
const Rvector& CelestialBody::SetRvectorParameter(const std::string &label,
                                              const Rvector &value)
{
   return SetRvectorParameter(GetParameterID(label), value);
}

//------------------------------------------------------------------------------
//  const Rmatrix&  GetRmatrixParameter(const Integer id)
//------------------------------------------------------------------------------
/**
 * This method gets the Rmatrix parameter value, given the input
 * parameter ID.
 *
 * @param <id> ID for the requested parameter.
 *
 * @return  success flag.
 *
 */
//------------------------------------------------------------------------------
//const Rmatrix& CelestialBody::GetRmatrixParameter(const Integer id) const
//{
//   if (id == SIJ)               return sij;
//   if (id == CIJ)               return cij;
//   
//   return SpacePoint::GetRmatrixParameter(id);
//}

//------------------------------------------------------------------------------
//  const Rmatrix&  SetRmatrixParameter(const Integer id, const Rmatrix& value)
//------------------------------------------------------------------------------
/**
 * This method sets the Rmatrix parameter value, given the input
 * parameter ID.
 *
 * @param <id> ID for the requested parameter.
 * @param <value> Rmatrix value for the requested parameter.
 *
 * @return  success flag.
 *
 */
//------------------------------------------------------------------------------
//const Rmatrix& CelestialBody::SetRmatrixParameter(const Integer id,
//                                                  const Rmatrix &value)
//{
//   if (id == SIJ) 
//   {
//      sij = value;
//      return true;
//   }
//   if (id == CIJ)
//   {
//      cij = value;
//      return true;
//   }
//
//   return SpacePoint::SetRmatrixParameter(id,value);
//}

//------------------------------------------------------------------------------
//  const Rmatrix&  GetRmatrixParameter(const std::string &label)
//------------------------------------------------------------------------------
/**
 * This method gets the Rmatrix parameter value, given the input
 * parameter ID.
 *
 * @param <label> string ID for the requested parameter.
 *
 * @return  success flag.
 *
 */
//------------------------------------------------------------------------------
//const Rmatrix& CelestialBody::GetRmatrixParameter(const std::string &label) const
//{
//   return GetRmatrixParameter(GetParameterID(label));
//}

//------------------------------------------------------------------------------
//  const Rmatrix&  SetRmatrixParameter(const std::string &label,
//                                      const Rmatrix& value)
//------------------------------------------------------------------------------
/**
 * This method sets the Rmatrix parameter value, given the input
 * parameter ID.
 *
 * @param <label> string ID for the requested parameter.
 * @param <value> Rmatrix value for the requested parameter.
 *
 * @return  success flag.
 *
 */
//------------------------------------------------------------------------------
//const Rmatrix& CelestialBody::SetRmatrixParameter(const std::string &label,
//                                                  const Rmatrix &value)
//{
//   return SetRmatrixParameter(GetParameterID(label), value);
//}

//------------------------------------------------------------------------------
//  const StringArray&   GetStringArrayParameter((const Integer id) const
//------------------------------------------------------------------------------
/**
 * This method returns the StringArray parameter value, given the input
 * parameter ID.
 *
 * @param <id> ID for the requested parameter.
 *
 * @return  StringArray value of the requested parameter.
 *
 */
//------------------------------------------------------------------------------
const StringArray& CelestialBody::GetStringArrayParameter(const Integer id) const
{
   return SpacePoint::GetStringArrayParameter(id);
}


//------------------------------------------------------------------------------
//  GmatBase* GetRefObject(const Gmat::ObjectType type,
//                         const std::string &name)
//------------------------------------------------------------------------------
/**
 * This method returns a reference object from the CelestialBody class.
 *
 * @param type  type of the reference object requested
 * @param name  name of the reference object requested
 *
 * @return pointer to the reference object requested.
 *
 */
//------------------------------------------------------------------------------
GmatBase* CelestialBody::GetRefObject(const Gmat::ObjectType type,
                                      const std::string &name)
{
   switch (type)
   {
      case Gmat::SPACE_POINT:
      case Gmat::CELESTIAL_BODY:
         if ((theCentralBody) && (name == theCentralBodyName)) return theCentralBody;
         break;
      default:
         break;
   }
   
   // Not handled here -- invoke the next higher GetRefObject call
   return SpacePoint::GetRefObject(type, name);
}


//------------------------------------------------------------------------------
//  const StringArray& GetRefObjectNameArray(const Gmat::ObjectType type)
//------------------------------------------------------------------------------
/**
 * Returns the names of the reference object. (Derived classes should implement
 * this as needed.)
 *
 * @param <type> reference object type.  Gmat::UnknownObject returns all of the
 *               ref objects.
 *
 * @return The names of the reference object.
 */
//------------------------------------------------------------------------------
const StringArray& CelestialBody::GetRefObjectNameArray(
                                  const Gmat::ObjectType type)
{
   if ((type == Gmat::UNKNOWN_OBJECT) ||
       (type == Gmat::CELESTIAL_BODY) ||
       (type == Gmat::SPACE_POINT) )
   {

      static StringArray refs;
      refs.clear();

      refs.push_back(theCentralBodyName);

      #ifdef DEBUG_REFERENCE_SETTING
         MessageInterface::ShowMessage("+++ReferenceObjects:\n");
         for (StringArray::iterator i = refs.begin(); i != refs.end(); ++i)
            MessageInterface::ShowMessage("   %s\n", i->c_str());
      #endif

      return refs;
   }

   #ifdef DEBUG_REFERENCE_SETTING
      MessageInterface::ShowMessage("Calling SpacePoint::GetRefObjectNameArray for body %s\n",
            instanceName.c_str());
   #endif
   // Not handled here -- invoke the next higher GetRefObject call
   return SpacePoint::GetRefObjectNameArray(type);
}


//------------------------------------------------------------------------------
//  bool SetRefObject(GmatBase *obj, const Gmat::ObjectType type,
//                    const std::string &name)
//------------------------------------------------------------------------------
/**
 * This method sets a reference object for the CelestialBody class.
 *
 * @param obj   pointer to the reference object
 * @param type  type of the reference object
 * @param name  name of the reference object
 *
 * @return true if successful; otherwise, false.
 *
 */
//------------------------------------------------------------------------------
bool CelestialBody::SetRefObject(GmatBase *obj,
                                 const Gmat::ObjectType type,
                                 const std::string &name)
{
   #ifdef DEBUG_REFERENCE_SETTING
   MessageInterface::ShowMessage
      ("CelestialBody::SetRefObject() this=<%p> %s, obj=%p, name=%s\n",
       this, GetName().c_str(), obj, name.c_str());
//   MessageInterface::ShowMessage("RefObjectNameArray for %s is:\n", instanceName.c_str());
//   StringArray names = GetRefObjectNameArray(Gmat::UNKNOWN_OBJECT);
//   for (unsigned int ii = 0; ii < name.size(); ii++)
//      MessageInterface::ShowMessage("    %s\n", name.at(ii));
   #endif
   
   if (this == obj)
      return true;
   
   bool foundHere = false;
   bool trySP     = false;
   if (obj->IsOfType("CelestialBody"))
   {
      if (name == theCentralBodyName)
      {
         CelestialBody *cb = (CelestialBody*) obj;
         if ((theCentralBody == NULL) || (theCentralBody != cb))
         {
            #ifdef DEBUG_REFERENCE_SETTING
               MessageInterface::ShowMessage("   Setting %s as central body for %s\n",
                                             name.c_str(), instanceName.c_str());
            #endif
            theCentralBody  = cb;
            centralBodySet  = true;
            foundHere = true;
         }
     }
   }
   
   // may also be the right object for a higher level parameter ...
   try
   {
      trySP = SpacePoint::SetRefObject(obj, type, name);
   }
   catch (GmatBaseException &)
   {
      //loj: We don't want to throw an exception here. (2007.12.05)
      //if (!foundHere) throw;
      #ifdef DEBUG_REFERENCE_SETTING
      MessageInterface::ShowMessage(e.GetFullMessage() + "\n");
      #endif
   }
   if (foundHere || trySP) 
   {
      return true;
   }
   return false;
}


//------------------------------------------------------------------------------
// bool IsParameterReadOnly(const Integer id) const
//------------------------------------------------------------------------------
bool CelestialBody::IsParameterReadOnly(const Integer id) const
{
//   #ifdef DEBUG_CB_READ_ONLY
//      MessageInterface::ShowMessage("CB::IsParameterReadOnly (%s) called with id = %d (%s)\n",
//            instanceName.c_str(), id, (GetParameterText(id)).c_str());
//   #endif
   // if we're not using an twoBody model, those parameters are read-only
//   if (posVelSrc != Gmat::ANALYTIC)
//   if (posVelSrc != Gmat::TWO_BODY_PROPAGATION)
//   {
//      if ((id == TWO_BODY_DATE_FORMAT)   || (id == TWO_BODY_STATE_TYPE) ||
//          (id == TWO_BODY_INITIAL_EPOCH) || (id == TWO_BODY_SMA)        ||
//          (id == TWO_BODY_ECC)           || (id == TWO_BODY_INC)        ||
//          (id == TWO_BODY_RAAN)          || (id == TWO_BODY_AOP)        ||
//          (id == TWO_BODY_TA) )
////         (id == TWO_BODY_TA)            || (id == ANALYTIC_METHOD)      )
//      {
//         #ifdef DEBUG_TWO_BODY
////            MessageInterface::ShowMessage(
////            "In CB::IParameterReadOnly, id = %d, returning TRUE\n",
////            id);
//         #endif
////         return true; // 2009.01.11 WCS - always write out elements, no matter the source
//      }
//   }
   // do not write out computed and some other items
   if ((id == BODY_TYPE)               || (id == MASS)                    || (id == POLAR_RADIUS)        || 
       (id == STATE)                   || (id == STATE_TIME)              || (id == HOUR_ANGLE)          ||
       (id == REF_BODY_NUMBER)         || (id == SOURCE_FILE)             || (id == ORDER)               ||
       (id == DEGREE)                  || (id == ATMOS_MODEL_NAME)        || (id == BODY_NUMBER)         ||
       (id == ANGULAR_VELOCITY)        || (id == TWO_BODY_DATE_FORMAT)    || (id == TWO_BODY_STATE_TYPE) ||
       (id == ORIENTATION_DATE_FORMAT) || (id == USE_POTENTIAL_FILE_FLAG) || (id == POTENTIAL_FILE_NAME)  )
      return true;
   // the ephem source for default bodies is set on the Solar System 
   if ((!userDefined) && (id == POS_VEL_SOURCE)) return true;
   // for now, don't allow user to modify orientation parameters for default bodies
   if (!userDefined && ((id == ORIENTATION_EPOCH)      || 
       (id == SPIN_AXIS_RA_CONSTANT)  || (id == SPIN_AXIS_RA_RATE) ||
       (id == SPIN_AXIS_DEC_CONSTANT) || (id == SPIN_AXIS_DEC_RATE) ||
       (id == ROTATION_CONSTANT)      || (id == ROTATION_RATE)))
      return true;

   // NAIF ID is not read-only for celestial bodies
   if (id == NAIF_ID)  return false;
   // NAIF ID for the spacecraft reference frame is currently read-only for spacecraft BUT
   // that may change when/if we add the reading of PCK kernels for body orientation data
//   if (id == NAIF_ID_REFERENCE_FRAME)  return false;

   if (id == ATTITUDE_SPICE_KERNEL_NAME)  return true;  // attitude for bodies (PCK) are TBD
   if (id == SC_CLOCK_SPICE_KERNEL_NAME)  return true;
   if (id == FRAME_SPICE_KERNEL_NAME)     return true;  // for now

   // leap second file is set on the Solar System, not on each celestial body

   return SpacePoint::IsParameterReadOnly(id);
}


//------------------------------------------------------------------------------
// bool CelestialBody::IsParameterCloaked(const Integer id) const
//------------------------------------------------------------------------------
bool CelestialBody::IsParameterCloaked(const Integer id) const
{
   if (!cloaking) return false;
   // if it's read-only, we'll cloak it
   if (IsParameterReadOnly(id)) return true;

   if (id >= SpacePointParamCount && id < CelestialBodyParamCount)
      return IsParameterEqualToDefault(id);
   
   return SpacePoint::IsParameterCloaked(id);
}


bool CelestialBody::IsParameterEqualToDefault(const Integer id) const
{
   if (id == EQUATORIAL_RADIUS)
   {
      return GmatMathUtil::IsEqual(default_equatorialRadius,equatorialRadius);
   }
   if (id == FLATTENING)
   {
      return GmatMathUtil::IsEqual(default_flattening,flattening);
   }
   if (id == MU)
   {
      return GmatMathUtil::IsEqual(default_mu,mu);
   } 
   if (id == POS_VEL_SOURCE)
   {
      #ifdef DEBUG_CB_CLOAKING
            MessageInterface::ShowMessage("In IsPEqual ... posVelSrc = %s & default = %s\n",
                  (Gmat::POS_VEL_SOURCE_STRINGS[posVelSrc]).c_str(), default_posVelSrc.c_str());
      #endif
      if (userDefined)
         return (default_posVelSrc == Gmat::POS_VEL_SOURCE_STRINGS[posVelSrc]);
      else  // for default, mods are made at the SolarSystem level
         return true;
   }
   if (id == CENTRAL_BODY)
   {
      return (default_centralBodyName == theCentralBodyName);
   }
//   if (id == BODY_NUMBER)
//   {
//      return (default_bodyNumber == bodyNumber);
//   }
   if (id == SOURCE_FILENAME)
   {
      if (userDefined)
         return (default_sourceFilename == sourceFilename);
      else  // for default, mods are made at the SolarSystem level
         return true;
   }
   if (id == ORBIT_SPICE_KERNEL_NAME)
   {
      if (default_orbitSpiceKernelNames.size() != orbitSpiceKernelNames.size()) return false;
      for (unsigned int ii = 0; ii < default_orbitSpiceKernelNames.size(); ii++)
      {
         if (default_orbitSpiceKernelNames.at(ii) != orbitSpiceKernelNames.at(ii)) return false;
      }
      return true;
   }
//   if (id == USE_POTENTIAL_FILE_FLAG)
//   {
//      if (default_usePotentialFile == usePotentialFile)           return true;
//      else                                                        return false;
//   }
//   if (id == POTENTIAL_FILE_NAME)
//   {
//      if (default_potentialFileName == potentialFileName)         return true;
//      else                                                        return false;
//   }
//   if (id == ANGULAR_VELOCITY)
//   {
//      if (default_angularVelocity == angularVelocity)             return true;
//      else                                                        return false;
//   }
//   if (id == ATMOS_MODEL_NAME)
//   {
//      if (default_atmModel == atmModel)                           return true;
//      else                                                        return false;
//   }
   if (id == ROTATION_DATA_SRC)
   {
      return (default_rotationSrc == rotationSrc);
   }
//   if (id == TWO_BODY_DATE_FORMAT)
//   {
//      return (default_twoBodyFormat == twoBodyFormat);
//   }
//   if (id == TWO_BODY_STATE_TYPE)
//   {
//      return (default_twoBodyStateType == twoBodyStateType);
//   }
   if (id == TWO_BODY_INITIAL_EPOCH)
   {
      #ifdef DEBUG_CB_CLOAKING_EPOCH
            MessageInterface::ShowMessage(
                  "In CB::IsParameterEqualToDefault (%s), twoBody epoch,  time %12.10f == time %12.10f ?  %s\n",
                  instanceName.c_str(), default_twoBodyEpoch.Get(), twoBodyEpoch.Get(),
                  (GmatMathUtil::IsEqual(default_twoBodyEpoch.Get(),twoBodyEpoch.Get())? "TRUE" : "FALSE"));
      #endif
      return (default_twoBodyEpoch == twoBodyEpoch);
//      return GmatMathUtil::IsEqual(default_twoBodyEpoch.Get(),twoBodyEpoch.Get());
   }
   if ((id == TWO_BODY_SMA)  || (id == TWO_BODY_ECC) || (id == TWO_BODY_INC) ||
       (id == TWO_BODY_RAAN) || (id == TWO_BODY_AOP) || (id == TWO_BODY_TA) )
   {
      return (default_twoBodyKepler == twoBodyKepler); // do we need an IsEqual for vectors?
   }
//   if (id == ORIENTATION_DATE_FORMAT)
//   {
//      return (default_orientationDateFormat == orientationDateFormat);
//   }
   if (id == ORIENTATION_EPOCH)
   {
      #ifdef DEBUG_CB_CLOAKING_EPOCH
            MessageInterface::ShowMessage(
                  "In CB::IsParameterEqualToDefault (%s), orientation epoch,  time %12.10f == time %12.10f ?  %s\n",
                  instanceName.c_str(), default_orientationEpoch.Get(), orientationEpoch.Get(),
                  (GmatMathUtil::IsEqual(default_orientationEpoch.Get(),orientationEpoch.Get())? "TRUE" : "FALSE"));
      #endif
      return (default_orientationEpoch == orientationEpoch);
//      return GmatMathUtil::IsEqual(default_orientationEpoch.Get(),orientationEpoch.Get());
   }
   if ((id == SPIN_AXIS_RA_CONSTANT)  || (id == SPIN_AXIS_RA_RATE) || (id == SPIN_AXIS_DEC_CONSTANT) ||
       (id == SPIN_AXIS_DEC_RATE)     || (id == ROTATION_CONSTANT) || (id == ROTATION_RATE) )
   {
      return (default_orientation == orientation);
   }
   if (id == TEXTURE_MAP_FILE_NAME)
   {
      return (default_textureMapFileName == textureMapFileName);
   }
   
   return SpacePoint::IsParameterEqualToDefault(id);
}

bool CelestialBody::SaveAllAsDefault()
{
   SpacePoint::SaveAllAsDefault();
   
   default_equatorialRadius       = equatorialRadius;
   default_flattening             = flattening;
   default_mu                     = mu;
   default_posVelSrc              = Gmat::POS_VEL_SOURCE_STRINGS[posVelSrc];
   default_centralBodyName        = theCentralBodyName;
//   default_bodyNumber             = bodyNumber;
   default_sourceFilename         = sourceFilename;
   default_orbitSpiceKernelNames       = orbitSpiceKernelNames;
//   default_usePotentialFile       = usePotentialFile;
//   default_potentialFileName      = potentialFileName;
//   default_angularVelocity        = angularVelocity;
//   default_atmModel               = atmModel;
   default_rotationSrc            = rotationSrc; 
//   default_twoBodyFormat          = twoBodyFormat;
//   default_twoBodyStateType       = twoBodyStateType;
   default_twoBodyEpoch           = twoBodyEpoch;
   default_twoBodyKepler          = twoBodyKepler;
//   default_orientationDateFormat  = orientationDateFormat;
   default_orientationEpoch       = orientationEpoch;
   default_orientation            = orientation;
//   default_naifId                 = naifId;
   default_textureMapFileName     = textureMapFileName;
   
   return true;
}

bool CelestialBody::SaveParameterAsDefault(const Integer id)
{
   if (id == EQUATORIAL_RADIUS)
   {
      default_equatorialRadius = equatorialRadius;
      return true;
   }
   if (id == FLATTENING)
   {
      default_flattening = flattening;
      return true;
   }
   if (id == MU)
   {
      default_mu = mu;
      return true;
   } 
   if (id == POS_VEL_SOURCE)
   {
      default_posVelSrc = Gmat::POS_VEL_SOURCE_STRINGS[posVelSrc];
      return true;
   }
   if (id == CENTRAL_BODY)
   {
      default_centralBodyName = theCentralBodyName;
      return true;
   }
//   if (id == BODY_NUMBER)
//   {
//      default_bodyNumber = bodyNumber;
//      return true;
//   }
   if (id == SOURCE_FILENAME)
   {
      default_sourceFilename = sourceFilename;
      return true;
   }
   if (id == ORBIT_SPICE_KERNEL_NAME)
   {
      default_orbitSpiceKernelNames = orbitSpiceKernelNames;
      return true;
   }
//   if (id == USE_POTENTIAL_FILE_FLAG)
//   {
//      default_usePotentialFile = usePotentialFile;
//      return true;
//   }
//   if (id == POTENTIAL_FILE_NAME)
//   {
//      default_potentialFileName = potentialFileName;
//      return true;
//   }
//   if (id == ANGULAR_VELOCITY)
//   {
//      default_angularVelocity = angularVelocity;
//      return true;
//   }
//   if (id == ATMOS_MODEL_NAME)
//   {
//      default_atmModel = atmModel;
//      return true;
//   }
   if (id == ROTATION_DATA_SRC)
   {
      default_rotationSrc = rotationSrc;
      return true;
   }
//   if (id == TWO_BODY_DATE_FORMAT)
//   {
//      default_twoBodyFormat = twoBodyFormat;
//      return true;
//   }
//   if (id == TWO_BODY_STATE_TYPE)
//   {
//      default_twoBodyStateType = twoBodyStateType;
//      return true;
//   }
   if (id == TWO_BODY_INITIAL_EPOCH)
   {
      default_twoBodyEpoch = twoBodyEpoch;
      return true;
   }
   if ((id == TWO_BODY_SMA)  || (id == TWO_BODY_ECC) || (id == TWO_BODY_INC) ||
       (id == TWO_BODY_RAAN) || (id == TWO_BODY_AOP) || (id == TWO_BODY_TA) )
   {
      default_twoBodyKepler = twoBodyKepler;
      return true;
   }
//   if (id == ORIENTATION_DATE_FORMAT)
//   {
//      default_orientationDateFormat = orientationDateFormat;
//      return true;
//   }
   if (id == ORIENTATION_EPOCH)
   {
      default_orientationEpoch = orientationEpoch;
      return true;
   }
   if ((id == SPIN_AXIS_RA_CONSTANT)  || (id == SPIN_AXIS_RA_RATE) || (id == SPIN_AXIS_DEC_CONSTANT) ||
       (id == SPIN_AXIS_DEC_RATE)     || (id == ROTATION_CONSTANT) || (id == ROTATION_RATE) )
   {
      default_orientation = orientation;
      return true;
   }
   if (id == TEXTURE_MAP_FILE_NAME)
   {
      default_textureMapFileName = textureMapFileName;
      return true;
   }
   
   return SpacePoint::SaveParameterAsDefault(id);
}



//---------------------------------------------------------------------------
//  void Copy(const GmatBase* orig)
//---------------------------------------------------------------------------
/**
 * Set this instance to match the one passed in.
 * 
 * @param <orig> The object that is being copied.
 */
//---------------------------------------------------------------------------
//void CelestialBody::Copy(const GmatBase* orig)
//{
//   #ifdef DEBUG_CB_COPY
//      MessageInterface::ShowMessage("Entering CB::Copy: copying from %p to %p\n",
//            orig, this);
//   #endif
//   operator=(*((CelestialBody *)(orig)));
//}


//------------------------------------------------------------------------------
// protected methods
//------------------------------------------------------------------------------
//------------------------------------------------------------------------------
//  void  InitializeBody(std::string withBodyType)
//------------------------------------------------------------------------------
/**
 * This method initializes the data values for the body.
 *
 * @param <withBodyType> string representation of the body type.
 *
 */
//------------------------------------------------------------------------------
void CelestialBody::InitializeBody(std::string withBodyType)
{
   #ifdef DEBUG_CB_INIT
   MessageInterface::ShowMessage
      ("CelestialBody::InitializeBody(%s) entered\n", withBodyType.c_str());
   #endif
   
   // assuming derived classes will fill in all the specific things with
   // appropriate default values
   usePotentialFile  = false;
   potentialFileName = "";
   sourceFilename    = "";
   theSourceFile     = NULL;
   stateTime         = 0.0;
   state             = Rvector6(0.0,0.0,0.0,0.0,0.0,0.0);
   angularVelocity   = Rvector3(0.0,0.0,7.29211585530e-5); // correct, for a default?
   potentialFileRead = false;
   atmModel          = NULL;
   for (Integer i = 0; i < (Integer) Gmat::BodyTypeCount; i++)
      if (withBodyType == Gmat::BODY_TYPE_STRINGS[i]) bodyType = (Gmat::BodyType) i;

   isFirstTimeMu = true;
   isFirstTimeRadius = true;
   rotationSrc = Gmat::IAU_SIMPLIFIED;
}

bool CelestialBody::DeterminePotentialFileNameFromStartup()
{
   //loj: 3/23/06 set default potential file name from the startup file.
   try
   {
      FileManager *fm = FileManager::Instance();
      std::string potfile = GmatStringUtil::ToUpper(instanceName) + "_POT_FILE";
      std::string filename = fm->GetFullPathname(potfile);
      
      #if DEBUG_CELESTIAL_BODY
      MessageInterface::ShowMessage
         ("Planet::DeterminePotentialFileNameFromStartup() body=%s, potfilename=%s\n", instanceName.c_str(),
          filename.c_str());
      #endif
      
      potentialFileName = filename;
   }
   catch (BaseException &e)
   {
      MessageInterface::ShowMessage(e.GetFullMessage());
   }
   return true;
}



//------------------------------------------------------------------------------
//  bool  ReadPotentialFile()
//------------------------------------------------------------------------------
/**
 * This method reads the potential file, if requested, and gets the mu, radius,
 * and spherical harmonic coefficients, sij and cij, from the file.
 *
 * @return flag indicating success of the file-reading.
 *
 */
//------------------------------------------------------------------------------
bool CelestialBody::ReadPotentialFile()
{
   if (potentialFileRead) return true;
   if (potentialFileName == "") return false;
   
   GravityFile gf;
   Integer fileDeg, fileOrd;
   try
   {
      if (!gf.GetFileInfo(potentialFileName, fileDeg, fileOrd, mu,
                          equatorialRadius))
      {
         throw SolarSystemException
            ("Error reading mu and equatorial radius of " + instanceName
             + " from "+ potentialFileName);
      }
   }
   catch (BaseException &e)
   {
      throw SolarSystemException(e.GetFullMessage());
   }
   
   
   potentialFileRead = true;
   // recompute polar radius
   polarRadius = (1.0 - flattening) * equatorialRadius;
   // recompute mass
   mass = mu / GmatPhysicalConstants::UNIVERSAL_GRAVITATIONAL_CONSTANT;
   return true;
}


//------------------------------------------------------------------------------
//  bool IsBlank(char* aLine)
//------------------------------------------------------------------------------
/**
 * This method returns true if the string is empty or is all white space.
 *
 * @return success flag.
 */
//------------------------------------------------------------------------------
bool CelestialBody::IsBlank(char* aLine)
{
   Integer i;
   for (i=0;i<(int)strlen(aLine);i++)
   {
      if (!isspace(aLine[i])) return false;
   }
   return true;
}


//------------------------------------------------------------------------------
//  Real GetJulianDaysFromTCBEpoch(const A1Mjd &forTime)
//------------------------------------------------------------------------------
/**
 * This method computes the Julian days from the TCB Epoch.
 *
 * @return number of Julian days since the TCB epoch.
 *
 * @note If the overrideTime flag is set, this actually computes the Julian Days
 *       from TT epoch.
 */
//------------------------------------------------------------------------------
Real CelestialBody::GetJulianDaysFromTCBEpoch(const A1Mjd &forTime) const
{
   Real jdTime = 0.0;
   Real mjdTT  = TimeConverterUtil::Convert(forTime.Get(),
                                            TimeConverterUtil::A1MJD,
                                            TimeConverterUtil::TTMJD, 
                                            GmatTimeConstants::JD_JAN_5_1941);
   jdTime      = mjdTT + GmatTimeConstants::JD_JAN_5_1941; 
   return (jdTime - JD_EPOCH_2000_TT);
}

//------------------------------------------------------------------------------
//  Rvector6 ComputeTwoBody(const A1Mjd &forTime)
//------------------------------------------------------------------------------
/**
 * This method computes the position and velocity at time forTime
 *
 * @return body state (position, velocity) at time forTime, with respect to
 *         the Earth.
 *
 */
//------------------------------------------------------------------------------
Rvector6 CelestialBody::ComputeTwoBody(const A1Mjd &forTime)
{
   #ifdef DEBUG_TWO_BODY

   MessageInterface::ShowMessage
      ("CelestialBody::ComputeTwoBody() this=<%p> %s, "
       "theCentralBody=<%p> %s\n", this, GetName().c_str(), theCentralBody,
       theCentralBodyName.c_str());
   #endif
   
   // Since we want the state in MJ2000Eq Earth-centered
   if (instanceName == SolarSystem::EARTH_NAME) 
      return Rvector6(0.0,0.0,0.0,0.0,0.0,0.0);
   #ifdef DEBUG_TWO_BODY
   MessageInterface::ShowMessage
      ("CelestialBody::ComputeTwoBody() before call to centralBody->GetState()\n");
   if (!theCentralBody) 
      MessageInterface::ShowMessage("The central body (%s) for %s is NULL!!!!\n", 
            theCentralBodyName.c_str(), instanceName.c_str());
   #endif
   
   Rvector6 cbState = theCentralBody->GetState(forTime);
   #ifdef DEBUG_TWO_BODY
   MessageInterface::ShowMessage
      ("CelestialBody::ComputeTwoBody() AFTER call to centralBody->GetState()\n");
   #endif
   
   return (KeplersProblem(forTime) + cbState);    
}


//------------------------------------------------------------------------------
//  Rvector6 KeplersProblem(const A1Mjd &forTime)
//------------------------------------------------------------------------------
/**
 * This method computes the position and velocity at time forTime
 *
 * @return body state (position, velocity) at time forTime, with respect to
 *         the central body.
 *
 * @note This is based on Algorithm 8 on pp. 101-2 (and algorithm 1 on
 *       p. 71) of "Fundamentals of Astrodynamics and Applications",
 *       Second Edition, by David A. Vallado.
 */
//------------------------------------------------------------------------------
Rvector6 CelestialBody::KeplersProblem(const A1Mjd &forTime)
{
   #ifdef DEBUG_TWO_BODY
         MessageInterface::ShowMessage
            ("CelestialBody::KeplersProblem() this=<%p> %s, "
             "theCentralBody=<%p> %s\n", this, GetName().c_str(), theCentralBody,
             theCentralBodyName.c_str());
         MessageInterface::ShowMessage("newTwoBody = %s\n", (newTwoBody? "TRUE" : "FALSE"));
         MessageInterface::ShowMessage("keplerian elements = %12.10f   %12.10f   %12.10f   %12.10f   %12.10f   %12.10f\n",
               twoBodyKepler[0],twoBodyKepler[1],twoBodyKepler[2],twoBodyKepler[3],twoBodyKepler[4],twoBodyKepler[5]); 
         MessageInterface::ShowMessage("epoch = %12.10f\n",twoBodyEpoch.Get()); 
         MessageInterface::ShowMessage("forTime = %12.10f\n",forTime.Get());         
   #endif

   Real     cbMu  = theCentralBody->GetGravitationalConstant() + mu;
   Rvector6 cart;  // or MA???
   Real     dTime;
   
   if ((!newTwoBody) && 
       (Abs(forTime.Subtract(prevTwoBodyEpoch) * GmatTimeConstants::SECS_PER_DAY) <= KEPLER_TOL))
      return prevTwoBodyState;
   cart  = StateConversionUtil::KeplerianToCartesian(cbMu, twoBodyKepler, "TA");  // or MA???
   dTime = forTime.Subtract(twoBodyEpoch) * GmatTimeConstants::SECS_PER_DAY;
   #ifdef DEBUG_TWO_BODY
      MessageInterface::ShowMessage("cbMu = %12.14f    dTime = %12.14f\n", cbMu, dTime);
   #endif

   //   // check for number of revs and reduce dTime if necessary (this does not work for the Sun)
   if (instanceName != SolarSystem::SUN_NAME)
   {
      Real sma = twoBodyKepler[0];   // SMA, which should be constant
      Real T = 2 * GmatMathConstants::PI * Sqrt(Abs(sma)*Abs(sma)*Abs(sma)/cbMu);
   
      Real revs = dTime/T;
      dTime = dTime - T * Fix(revs);
      #ifdef DEBUG_TWO_BODY
         MessageInterface::ShowMessage("After Fix, sma = %12.14f    T = %12.14f     revs = %12.14f    dTime = %12.14f\n", 
               sma, T, revs, dTime);
      #endif
   }


   #ifdef DEBUG_TWO_BODY
      MessageInterface::ShowMessage("r0 = %12.16f   %12.16f   %12.16f  & v0 = %12.16f   %12.16f   %12.16f\n",
            cart[0], cart[1], cart[2], cart[3], cart[4], cart[5]);
   #endif
   Rvector3 r0     = cart.GetR();
   Rvector3 v0     = cart.GetV();

   Real     rMag0  = r0.GetMagnitude();
   Real     vMag0  = v0.GetMagnitude();
   Real     alpha = (-(vMag0 * vMag0) / cbMu) + (2.0 / rMag0);
   Real     x0    = -999.999;
   Real     rDotv = r0 * v0;  // dot product
   
   #ifdef DEBUG_TWO_BODY
      MessageInterface::ShowMessage("alpha = %12.14f    rDotv = %12.14f\n", alpha, rDotv);
      MessageInterface::ShowMessage("KEPLER_TOL = %12.14f\n", KEPLER_TOL);
   #endif
   // Determine initial guess .......
   // for a circle or ellipse
   if (alpha > KEPLER_TOL)  
   {
      #ifdef DEBUG_TWO_BODY
         MessageInterface::ShowMessage(" -------- circle or ellipse\n");
      #endif
      x0 = Sqrt(cbMu) * dTime * alpha;

      if (Abs(alpha - 1.0) <= KEPLER_TOL)
      {
         // match Vallado matlab code 
         x0 = x0 * 0.97;
      }
   }
   // for a parabola
   else if (Abs(alpha) < KEPLER_TOL)
   {
      #ifdef DEBUG_TWO_BODY
         MessageInterface::ShowMessage(" -------- parabola\n");
      #endif
      Rvector3 h     = Cross(r0, v0);
      Real     hMag0 = h.GetMagnitude();
      Real     p     = (hMag0 * hMag0) / cbMu;
      Real     s     = (1.0 / 2.0) * (GmatMathConstants::PI_OVER_TWO -
                       ATan(3.0 * Sqrt(cbMu / (p * p * p)) * dTime));
      Real     w     = ATan(Pow(Tan(s), (1.0 / 3.0)));
      x0             = Sqrt(p) * 2.0 / Tan(2.0 * w);
      alpha          = 0.0;   // per kepler function by Vallado
   }
   // for a hyperbola
   else if (alpha < -KEPLER_TOL)
   {
      #ifdef DEBUG_TWO_BODY
         MessageInterface::ShowMessage(" -------- hyperbola\n");
      #endif
      Real     a     = 1.0 / alpha;
      Integer  signT = SignOf(dTime);
      Real     num   = -2.0 * cbMu * alpha * dTime;
      Real     den   = rDotv + signT * Sqrt(-cbMu * a) * 
                       (1.0 - rMag0 * alpha);
      x0             = signT * Sqrt(-a) * Ln(num / den);
   }
   #ifdef DEBUG_TWO_BODY
      MessageInterface::ShowMessage("x0 = %12.14f\n", x0);
   #endif
   // Loop until difference falls within tolerance
   Real    rVal    = 0.0;
   Real    xNew    = 0.0;
   Real    xn      = x0;
   Real    psi     = xn * xn * alpha;
   Real    sqrtPsi = 0.0;
   bool    done    = false;
   Real    c2      = -999.99;
   Real    c3      = -999.99;
   Integer counter = 0;

   while (!done)
   {
      psi = xn * xn * alpha;
      
      // compute c2 and c3, per Algorithm 1, p. 71
      if (psi > KEPLER_TOL)
      {
         sqrtPsi = Sqrt(psi);
         c2      = (1.0 - Cos(sqrtPsi)) / psi;
         c3      = (sqrtPsi - Sin(sqrtPsi)) / Sqrt(psi * psi * psi);
      }
      else if (psi < -KEPLER_TOL)
      {
         sqrtPsi = Sqrt(-psi);
         c2      = (1.0 - Cosh(sqrtPsi)) / psi;
         c3      = (Sinh(sqrtPsi) - sqrtPsi) / Sqrt((-psi) * (-psi) * (-psi));
      }
      else
      {
         c2      = 1.0 / 2.0;
         c3      = 1.0 / 6.0;
      }
      rVal = (xn * xn * c2) + (rDotv / Sqrt(cbMu)) * xn * (1.0 - psi * c3) +
              rMag0 * (1.0 - psi * c2);
      #ifdef DEBUG_TWO_BODY
         MessageInterface::ShowMessage(" at start of loop,xn = %12.14f and psi = %12.14f\n",  xn, psi);
         MessageInterface::ShowMessage("                  c2 = %12.14f and c3 = %12.14f\n",  c2, c3);
         MessageInterface::ShowMessage("                  rVal = %12.14ff\n",  rVal);
      #endif
                
      xNew = xn + ((Sqrt(cbMu) * dTime) - (xn * xn * xn * c3) - 
                   (rDotv / Sqrt(cbMu)) * (xn * xn * c2) -
                   rMag0 * xn * (1.0 - psi *c3)) / rVal;
      
      if (Abs(xn - xNew) < KEPLER_TOL) done = true;
      xn = xNew;
      counter++;
   }
   #ifdef DEBUG_TWO_BODY
      MessageInterface::ShowMessage(" after loop is done, xNew = %12.14f    xn = %12.14f\n", xNew, xn);
   #endif

   if (counter >= KEPLER_MAX_ITERATIONS)
   {
      std::stringstream ss("");
      ss << "Kepler's Problem (TwoBodyPropagation) for Body \"" << instanceName <<
            "\" is not converging after " << KEPLER_MAX_ITERATIONS << "iterations.";
      throw SolarSystemException(ss.str());
   }
   
   Real f     = 1.0 - ((xn * xn) / rMag0) * c2;
   Real g     = dTime - ((xn * xn * xn) / Sqrt(cbMu)) * c3;
   Rvector3 r = f * r0 + g * v0;
   // recompute magnitude, etc. (per Vallado matlab code)
   Real rMagNew = r.GetMagnitude();
   // Mods to this computation per Vallado matlab code
   Real gDot  = 1.0 - ((xn * xn) / rMagNew) * c2;
   Real fDot  = (Sqrt(cbMu) / (rMagNew * rMag0)) * xn * (psi * c3 - 1.0);
   Rvector3 v = fDot * r0 + gDot * v0;

   
   #ifdef DEBUG_TWO_BODY
      MessageInterface::ShowMessage("f    = %12.14f, g    = %12.14f\n", f, g);
      MessageInterface::ShowMessage("fDot = %12.14f, gDot = %12.14f\n", fDot, gDot);
      MessageInterface::ShowMessage("Computed quantity (f*gDot - fDot * g) = %12.14f\n", (Abs(f * gDot - g * fDot)));
   #endif

   if (!IsEqual(Abs(f * gDot - g * fDot), 1.0, 1.0e-5))  // e-5 per S. Hughes 2009.02.19
      throw SolarSystemException(
            "Error performing two body propagation for body "
            + instanceName);
   
   Rvector6 newState(r,v);
   prevTwoBodyEpoch = forTime;
   prevTwoBodyState = newState;
   newTwoBody       = false;
   // debug stuff
   #ifdef DEBUG_TWO_BODY
      MessageInterface::ShowMessage("At end of TwoBody computation, new r  = %12.14f    %12.14f    %12.14f\n",
            newState[0], newState[1], newState[2]);
      MessageInterface::ShowMessage("At end of TwoBody computation, new v  = %12.14f    %12.14f    %12.14f\n",
            newState[3], newState[4], newState[5]);
   #endif
   
   return newState;
}

bool CelestialBody::SetUpSPICE()
{
#ifdef __USE_SPICE__
   #ifdef DEBUG_CB_SPICE
      MessageInterface::ShowMessage(
            "Entering SetUpSpice for body %s with source = %s and orbitSpiceKernelNames:\n",
            instanceName.c_str(), Gmat::POS_VEL_SOURCE_STRINGS[posVelSrc].c_str());
      for (unsigned int ii = 0; ii < orbitSpiceKernelNames.size(); ii++)
         MessageInterface::ShowMessage("     %s\n", (orbitSpiceKernelNames.at(ii)).c_str());
      MessageInterface::ShowMessage("   posVelSrc = %s\n", Gmat::POS_VEL_SOURCE_STRINGS[posVelSrc].c_str());
      if (kernelReader == NULL)
         MessageInterface::ShowMessage("   kernelReader is NULL\n");
   #endif
   if (posVelSrc != Gmat::SPICE) return false;
   if (kernelReader == NULL)
   {
      std::string errmsg = "ERROR - SpiceKernelReader not set for body \"";
      errmsg += instanceName + "\"\n";
      throw SolarSystemException(errmsg);
   }
   #ifdef DEBUG_CB_SPICE
      if (kernelReader == NULL)
         MessageInterface::ShowMessage("   kernelReader is STILL NULL\n");
   #endif
   std::string mainSPK = theSolarSystem->GetStringParameter("SPKFilename");
   if (orbitSpiceKernelNames.empty())
   {
      if (mainSPK == "")
      {
         std::string errmsg = "ERROR - SPICE selected as source for body \"";
         errmsg += instanceName + "\", but no SPK file(s) specified.\n";
         throw SolarSystemException(errmsg);
      }
      else  // outer planets/moons, comets, and asteroids must have their own SPK file specified
      {
         if (!msgWritten && !NeedsOnlyMainSPK())
//         if (!msgWritten && ((instanceName != SolarSystem::SUN_NAME) && (instanceName != SolarSystem::MERCURY_NAME) &&
//             (instanceName != SolarSystem::VENUS_NAME) && (instanceName != SolarSystem::EARTH_NAME) &&
//             (instanceName != SolarSystem::MOON_NAME)))
         {
            MessageInterface::ShowMessage(
               "An additional body-specific SPK may be required for body %s or its satellites.\n",
               instanceName.c_str());
            msgWritten = true;
         }
      }
   }
//   #ifdef DEBUG_CB_SPICE
//      MessageInterface::ShowMessage("   now loading main SPK kernel ...\n");
//   #endif
   // make sure the "main" Solar System Kernel(s) are loaded first - DONE in SolarSystem
   theSolarSystem->LoadSpiceKernels();
   // now load the spice kernels specified for this body
   for (unsigned int ii = 0; ii < orbitSpiceKernelNames.size(); ii++)
   {
      #ifdef DEBUG_CB_SPICE
         MessageInterface::ShowMessage("   now checking %s ...\n", orbitSpiceKernelNames.at(ii).c_str());
      #endif
      if (!(kernelReader->IsLoaded(orbitSpiceKernelNames.at(ii))))
      {
         try
         {
            kernelReader->LoadKernel(orbitSpiceKernelNames.at(ii));
            #ifdef DEBUG_CB_SPICE
               MessageInterface::ShowMessage("   kernelReader has loaded file %s\n",
                     (orbitSpiceKernelNames.at(ii)).c_str());
            #endif
         }
         catch (UtilityException &ue)
         {
            #ifdef DEBUG_CB_SPICE
               MessageInterface::ShowMessage("   EXCEPTION caught with message: %s ...\n", ue.GetFullMessage().c_str());
            #endif
            // try again with path name if no path found
            std::string spkName = orbitSpiceKernelNames.at(ii);
            if (spkName.find("/") == spkName.npos &&
                spkName.find("\\") == spkName.npos)
            {
               std::string spkPath =
                  FileManager::Instance()->GetFullPathname(FileManager::SPK_PATH);
               spkName = spkPath + spkName;
               try
               {
                  #ifdef DEBUG_CB_SPICE
                     MessageInterface::ShowMessage("   now attempting to load %s ...\n", spkName.c_str());
                  #endif
                  kernelReader->LoadKernel(spkName);
                  #ifdef DEBUG_CB_SPICE
                  MessageInterface::ShowMessage("   kernelReader has loaded file %s\n",
                     spkName.c_str());
                  #endif
               }
               catch (UtilityException &ue2)
               {
                  MessageInterface::ShowMessage("ERROR loading kernel %s\n",
                     (spkName.c_str()));
                  throw; // rethrow the exception, for now
               }
            }
            else
            {
               MessageInterface::ShowMessage("ERROR loading kernel %s\n",
                  (orbitSpiceKernelNames.at(ii).c_str()));
               throw; // rethrow the exception, for now
            }
         }
      }
   }
   // get the NAIF Id from the Spice Kernel(s)   @todo - should this be moved to SpacePoint?
   if (!naifIdSet)
   {
      // SPICE calls Earth's moon "Moon" (like it's the only important one or something - sheesh!)
      // GMAT calls Earth's moon "Luna"    
      Integer spiceNaifId; 
      if (instanceName == SolarSystem::MOON_NAME)
         spiceNaifId = kernelReader->GetNaifID("MOON"); 
      else if (instanceName == GmatSolarSystemDefaults::SOLAR_SYSTEM_BARYCENTER_NAME)
         spiceNaifId = kernelReader->GetNaifID("SSB");
      else
      {
            spiceNaifId = kernelReader->GetNaifID(instanceName, false);
            // if not found with the instanceName, try using the NAIF ID
            if (spiceNaifId == 0)   // SSB is 0, but that's handled above
            {
               std::stringstream ss("");
               ss << naifId;
//               spiceNaifId = kernelReader->GetNaifID(ss.str(), true);
//               if (spiceNaifId != 0)
                  naifName = ss.str();
//               else
//                  naifName = instanceName;  // ??
                  spiceNaifId = naifId;
            }
            else
            {
               naifName = instanceName;
            }
      }
      
      if ((naifId != UNDEFINED_NAIF_ID) && (spiceNaifId != naifId))
      {
         std::stringstream ss("");
         ss << "Overriding input NAIF ID for body \"" << instanceName <<
               "\" with SPICE NAIF ID (" << spiceNaifId << ").\n";
         MessageInterface::PopupMessage(Gmat::WARNING_, ss.str());
      }
      naifId    = spiceNaifId;
      naifIdObserver = kernelReader->GetNaifID(j2000BodyName, false);
      naifIdSet = true;
   }
   #ifdef DEBUG_CB_SPICE
      MessageInterface::ShowMessage("   naifID for body %s is %d\n",
            instanceName.c_str(), naifId);
   #endif

   spiceSetupDone = true;
#endif
   return true;
}

bool CelestialBody::NeedsOnlyMainSPK()
{
   return false;
}

//------------------------------------------------------------------------------
// private methods
//------------------------------------------------------------------------------
// none at this time
