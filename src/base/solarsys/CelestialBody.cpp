//$Id$
//------------------------------------------------------------------------------
//                                  CelestialBody
//------------------------------------------------------------------------------
// GMAT: General Mission Analysis Tool.
//
// Copyright (c) 2002 - 2015 United States Government as represented by the
// Administrator of the National Aeronautics and Space Administration.
// All Other Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License"); 
// You may not use this file except in compliance with the License. 
// You may obtain a copy of the License at:
// http://www.apache.org/licenses/LICENSE-2.0. 
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either 
// express or implied.   See the License for the specific language
// governing permissions and limitations under the License.
//
// Author: Wendy C. Shoan
// Created: 2004/01/28
//
/**
 * Implementation of the CelestialBody class.
 *
 * @note This is an abstract class.
 *
 * @note Class (initial shell only) automatically generated by Dev-C++ New
 *       Class wizard (heavily modified after that)
 */
//------------------------------------------------------------------------------


#include <iostream>
#include <fstream>
#include <sstream>
#include <iomanip>
#include "gmatdefs.hpp"
#include "SpacePoint.hpp"
#include "CelestialBody.hpp"
#include "PlanetaryEphem.hpp"
#include "SolarSystem.hpp"
#include "SolarSystemException.hpp"
#include "PlanetaryEphemException.hpp"
#include "UtilityException.hpp"
#include "FileManager.hpp"
#include "Rvector3.hpp"
#include "Rvector6.hpp"
#include "Rmatrix.hpp"
#include "RealUtilities.hpp"
#include "AtmosphereModel.hpp"
#include "MessageInterface.hpp"
#include "GmatConstants.hpp"
#include "GmatDefaults.hpp"
#include "TimeSystemConverter.hpp"
#include "UtcDate.hpp"
#include "FileUtil.hpp"
#include "TimeTypes.hpp"
#include "AngleUtil.hpp"
#include "TimeTypes.hpp"
#include "StateConversionUtil.hpp"
#include "StringUtil.hpp"               // for ToString()
#include "GravityFileUtil.hpp"          // for GetFileInfo()

//#define DEBUG_CELESTIAL_BODY 1
//#define DEBUG_GET_STATE
//#define DEBUG_CB_SPICE_VS_DE
//#define DEBUG_CB_SET
//#define DEBUG_CB_INIT
//#define DEBUG_TWO_BODY
//#define DEBUG_EPHEM_SOURCE
//#define DEBUG_MODIFIED_FLAG
//#define DEBUG_CB_SET_STRING
//#define DEBUG_CB_SPICE
//#define DEBUG_CB_USER_DEFINED
//#define DEBUG_CB_GET_MJ2000_STATE
//#define DEBUG_REFERENCE_SETTING
//#define DEBUG_CB_READ_ONLY
//#define DEBUG_CB_CLOAKING
//#define DEBUG_CB_CLOAKING_EPOCH
//#define DEBUG_CB_EQ_RAD
//#define DEBUG_CB_CARTOGRAPHIC
//#define DEBUG_CB_DESTRUCT
//#define DEBUG_CB_EPOCH
//#define DEBUG_TEXTURE_FILE
//#define DEBUG_3D_MODEL_FILE
//#define DEBUG_VALIDATION
//#define DEBUG_CB_GET_STRING_ARRAY

//#ifndef DEBUG_MEMORY
//#define DEBUG_MEMORY
//#endif

#ifdef DEBUG_MEMORY
#include "MemoryTracker.hpp"
#endif

using namespace GmatMathUtil;


//------------------------------------------------------------------------------
// static data
//------------------------------------------------------------------------------
const std::string
CelestialBody::PARAMETER_TEXT[CelestialBodyParamCount - SpacePointParamCount] =
{
   "BodyType",
   "Mass",
   "EquatorialRadius",
   "Flattening",
   "PolarRadius",
   "Mu",
   "PosVelSource",
   "State",
   "StateTime",
   "CentralBody",
   "BodyNumber",
   "RefBodyNumber",
   "UsePotentialFileFlag",
   "PotentialFileName",
   "AngularVelocity",
   "HourAngle",
   "AtmosphereModelName",
   "Order",
   "Degree",
   "RotationDataSource",
   "DateFormat",               // for two-body method
   "StateType",                // for two-body method
   "InitialEpoch",             // for two-body method
   "SMA",                      // for two-body method
   "ECC",                      // for two-body method
   "INC",                      // for two-body method
   "RAAN",                     // for two-body method
   "AOP",                      // for two-body method
   "TA",                       // for two-body method
   "OrientationDateFormat",    // orientation parameters, used to compute alpha, delta, W, Wdot
   "OrientationEpoch",
   "SpinAxisRAConstant",
   "SpinAxisRARate",
   "SpinAxisDECConstant",
   "SpinAxisDECRate",
   "RotationConstant",
   "RotationRate",
   "TextureMapFileName",
   "TextureMapFullPath",
   "3DModelFile",
   "3DModelFileFullPath",
   "3DModelOffsetX",
   "3DModelOffsetY",
   "3DModelOffsetZ",
   "3DModelRotationX",
   "3DModelRotationY",
   "3DModelRotationZ",
   "3DModelScale",
};

const Gmat::ParameterType
CelestialBody::PARAMETER_TYPE[CelestialBodyParamCount - SpacePointParamCount] =
{
   Gmat::STRING_TYPE,   //"BodyType",
   Gmat::REAL_TYPE,     //"Mass",
   Gmat::REAL_TYPE,     //"EquatorialRadius",
   Gmat::REAL_TYPE,     //"Flattening",
   Gmat::REAL_TYPE,     //"PolarRadius",
   Gmat::REAL_TYPE,     //"Mu",
   Gmat::STRING_TYPE,   //"PosVelSource",
   Gmat::RVECTOR_TYPE,  //"State",
   Gmat::TIME_TYPE,     //"StateTime",
   Gmat::STRING_TYPE,   //"CentralBody",
   Gmat::INTEGER_TYPE,  //"BodyNumber",
   Gmat::INTEGER_TYPE,  //"RefBodyNumber",
   Gmat::BOOLEAN_TYPE,  //"UsePotentialFileFlag",
   Gmat::FILENAME_TYPE, //"PotentialFileName",
   Gmat::RVECTOR_TYPE,  //"AngularVelocity",
   Gmat::REAL_TYPE,     //"HourAngle",
   Gmat::STRING_TYPE,   //"AtmosphereModelName",
   Gmat::INTEGER_TYPE,  //"Order",
   Gmat::INTEGER_TYPE,  //"Degree",
   Gmat::STRING_TYPE,   //"RotationDataSource",
   Gmat::STRING_TYPE,   //"DateFormat",   
   Gmat::STRING_TYPE,   //"StateType",  
   Gmat::REAL_TYPE,     //"InitialEpoch",
   Gmat::REAL_TYPE,     //"SMA", 
   Gmat::REAL_TYPE,     //"ECC",   
   Gmat::REAL_TYPE,     //"INC",   
   Gmat::REAL_TYPE,     //"RAAN",    
   Gmat::REAL_TYPE,     //"AOP",  
   Gmat::REAL_TYPE,     //"TA", 
   Gmat::STRING_TYPE,   //"OrientationDateFormat",  
   Gmat::REAL_TYPE,     //"OrientationEpoch",
   Gmat::REAL_TYPE,     //"SpinAxisRAConstant", 
   Gmat::REAL_TYPE,     //"SpinAxisRARate", 
   Gmat::REAL_TYPE,     //"SpinAxisDECConstant", 
   Gmat::REAL_TYPE,     //"SpinAxisDECRate", 
   Gmat::REAL_TYPE,     //"RotationConstant", 
   Gmat::REAL_TYPE,     //"RotationRate", 
   Gmat::FILENAME_TYPE, //"TextureMapFileName"
   Gmat::FILENAME_TYPE, //"TextureMapFullPath"
   Gmat::FILENAME_TYPE, //"3DModelFileName"
   Gmat::FILENAME_TYPE, //"3DModelFileFullPath"
   Gmat::REAL_TYPE,     //"3DModelOffsetX"
   Gmat::REAL_TYPE,     //"3DModelOffsetY"
   Gmat::REAL_TYPE,     //"3DModelOffsetZ"
   Gmat::REAL_TYPE,     //"3DModelRotationX"
   Gmat::REAL_TYPE,     //"3DModelRotationY"
   Gmat::REAL_TYPE,     //"3DModelRotationZ"
   Gmat::REAL_TYPE,     //"3DModelScale"
};

const Real    CelestialBody::dDot                       = 1.0;
const Real    CelestialBody::TDot                       = 1.0;
const Real    CelestialBody::KEPLER_TOL                 = 1.0e-08;
const Integer CelestialBody::KEPLER_MAX_ITERATIONS      = 50;
const Real    CelestialBody::DEFAULT_INITIAL_STATE_TIME = GmatTimeConstants::A1MJD_OF_J2000;


//------------------------------------------------------------------------------
// public methods
//------------------------------------------------------------------------------
//------------------------------------------------------------------------------
//  CelestialBody(std::string itsBodyType, std::string name)
//------------------------------------------------------------------------------
/**
 * This method creates an object of the CelestialBody class
 * (additional constructor).
 *
 * @param <itsBodyType> string representation of its body type
 * @param <name> parameter indicating the name of the celestial body.
 */
//------------------------------------------------------------------------------
CelestialBody::CelestialBody(std::string itsBodyType, std::string name) :
   SpacePoint(Gmat::CELESTIAL_BODY, itsBodyType, name),
   equatorialRadius   (GmatSolarSystemDefaults::PLANET_EQUATORIAL_RADIUS[GmatSolarSystemDefaults::EARTH]),
   flattening         (GmatSolarSystemDefaults::PLANET_FLATTENING[GmatSolarSystemDefaults::EARTH]),
   mu                 (GmatSolarSystemDefaults::PLANET_MU[GmatSolarSystemDefaults::EARTH]),
   posVelSrc          (Gmat::DE405),
   stateTime          (GmatTimeConstants::MJD_OF_J2000),
   theCentralBodyName (""),
   theCentralBody     (NULL),
   centralBodySet     (false),
   bodyNumber         (0),
   referenceBodyNumber(0),
   sourceFilename     (""),
   theSourceFile      (NULL),
   usePotentialFile   (false),
   potentialFileName  (""),
   potentialFileNameFullPath (""),
   hourAngle          (0.0),
   atmModel           (NULL),
   atmModelType       ("None"),
   potentialFileRead  (false),
   order              (0),
   degree             (0),
   twoBodyFormat      ("TAIModJulian"),
   twoBodyStateType   ("Keplerian"),
   twoBodyEpoch       (GmatTimeConstants::MJD_OF_J2000),
   newTwoBody         (true),
   overrideTime       (false),
   ephemUpdateInterval (0.0),
   lastEphemTime      (0.0),
   rotationSrc        (Gmat::IAU_SIMPLIFIED),
   userDefined        (false),
   allowSpice         (false),
   orientationDateFormat ("TAIModJulian"),
   orientationEpoch   (GmatTimeConstants::MJD_OF_J2000),
   orientation        (GmatSolarSystemDefaults::PLANET_ORIENTATION_PARAMETERS[GmatSolarSystemDefaults::EARTH]),
   naifIdSet          (false),
   naifName           (name),
   textureMapFileName ("GenericCelestialBody.jpg"),
   textureMapFullPath ("GenericCelestialBody.jpg"),
   view3dModelFileName     (""),
   view3dModelFileFullPath (""),
   view3dModelId        (-1),
   view3dModelOffsetX   (0.0),
   view3dModelOffsetY   (0.0),
   view3dModelOffsetZ   (0.0),
   view3dModelRotationX (0.0),
   view3dModelRotationY (0.0),
   view3dModelRotationZ (0.0),   
   view3dModelScale     (10.0),
   msgWritten           (false)
{
   objectTypes.push_back(Gmat::CELESTIAL_BODY);
   objectTypeNames.push_back("CelestialBody");
   // @todo - what to use for defaults here? - set different values for different celestial bodies
   Rvector6 initKepler(GmatSolarSystemDefaults::PLANET_TWO_BODY_ELEMENTS[GmatSolarSystemDefaults::EARTH]);
   twoBodyKepler = initKepler;
   
   mass        = mu / GmatPhysicalConstants::UNIVERSAL_GRAVITATIONAL_CONSTANT;
   polarRadius = (1.0 - flattening) * equatorialRadius;

   for (Integer i = 0; i < Gmat::ModelTypeCount; i++)
      models[i].push_back("None");

   // try to find the texture map file
   // if (textureMapFileName != "" && !GmatFileUtil::DoesFileExist(textureMapFileName.c_str()))
   // {
   //    std::string textureLoc = (FileManager::Instance())->GetFullPathname("TEXTURE_PATH");
   //    textureMapFileName = textureLoc + textureMapFileName;
   // }
   
   // Call SetTextureMapFileName() to use FileManager::FindPath() (LOJ: 2014.06.18)
   #ifdef DEBUG_TEXTURE_FILE
   MessageInterface::ShowMessage("1 Calling SetTextureMapFileName()\n");
   #endif
   SetTextureMapFileName(textureMapFileName);
   
   for (Integer i=0;i<6;i++)  prevState[i] = 0.0;
   #ifdef __USE_SPICE__
      kernelReader = NULL;
      mainSPK      = "";
      mainPCK      = "";
   #endif
   orbitSpiceKernelNames.clear();
   
   parameterCount = CelestialBodyParamCount;
   InitializeBody(itsBodyType);
   SaveAllAsDefault();

   // we want to cloak the DEFAULT Celestial Body data; i.e. we want to write only those
   // parameters that have been modified by the user to a script; and we don't
   // want to include the Create line either.  This will not be true for user-defined
   // bodies
   cloaking = true;

//   // Set the SPICE_FRAME_ID default - we don't want to do this, as the user
//   // has to set this for user-defined bodies
//   std::string nameUpper = GmatStringUtil::ToUpper(name);
//   spiceFrameID        = "IAU_" + nameUpper;

   #ifdef DEBUG_CB_CONSTRUCTOR
   MessageInterface::ShowMessage
      ("CelestialBody(string) <%p> '%s' constructor entered\n", this, GetName().c_str());
   #endif
}

//------------------------------------------------------------------------------
//  CelestialBody(Gmat::BodyType itsBodyType, std::string name)
//------------------------------------------------------------------------------
/**
 * This method creates an object of the CelestialBody class
 * (additional constructor).
 *
 * @param <itsBodyType> its body type
 * @param <name>        parameter indicating the name of the celestial body.
 */
//------------------------------------------------------------------------------
CelestialBody::CelestialBody(Gmat::BodyType itsBodyType, std::string name) :
   SpacePoint(Gmat::CELESTIAL_BODY,
              Gmat::BODY_TYPE_STRINGS[itsBodyType], name),
   bodyType           (itsBodyType),
   equatorialRadius   (GmatSolarSystemDefaults::PLANET_EQUATORIAL_RADIUS[GmatSolarSystemDefaults::EARTH]),
   flattening         (GmatSolarSystemDefaults::PLANET_FLATTENING[GmatSolarSystemDefaults::EARTH]),
   mu                 (GmatSolarSystemDefaults::PLANET_MU[GmatSolarSystemDefaults::EARTH]),
   posVelSrc          (Gmat::DE405),
   stateTime          (GmatTimeConstants::MJD_OF_J2000),
   theCentralBodyName (""),
   theCentralBody     (NULL),
   centralBodySet     (false),
   bodyNumber         (0),
   referenceBodyNumber(0),
   sourceFilename     (""),
   theSourceFile      (NULL),
   usePotentialFile   (false),
   potentialFileName  (""),
   potentialFileNameFullPath (""),
   hourAngle          (0.0),
   atmModel           (NULL),
   atmModelType       ("None"),
   potentialFileRead  (false),
   order              (0),
   degree             (0),
   twoBodyFormat      ("TAIModjulian"),
   twoBodyStateType   ("Keplerian"),
   twoBodyEpoch       (GmatTimeConstants::MJD_OF_J2000),
   newTwoBody         (true),
   overrideTime       (false),
   ephemUpdateInterval (0.0),
   lastEphemTime      (0.0),
   rotationSrc        (Gmat::IAU_SIMPLIFIED),
   userDefined        (false),
   allowSpice         (false),
   orientationDateFormat ("TAIModJulian"),
   orientationEpoch   (GmatTimeConstants::MJD_OF_J2000),
   orientation        (GmatSolarSystemDefaults::PLANET_ORIENTATION_PARAMETERS[GmatSolarSystemDefaults::EARTH]),
   naifIdSet          (false),
   naifName           (name),
   textureMapFileName ("GenericCelestialBody.jpg"),
   textureMapFullPath ("GenericCelestialBody.jpg"),
   view3dModelFileName     (""),
   view3dModelFileFullPath (""),
   view3dModelId        (-1),
   view3dModelOffsetX   (0.0),
   view3dModelOffsetY   (0.0),
   view3dModelOffsetZ   (0.0),
   view3dModelRotationX (0.0),
   view3dModelRotationY (0.0),
   view3dModelRotationZ (0.0),   
   view3dModelScale     (10.0),
   msgWritten           (false)
{
   objectTypes.push_back(Gmat::CELESTIAL_BODY);
   objectTypeNames.push_back("CelestialBody");
   
   // @todo - what to use for defaults here? - set different values for different celestial bodies
   Rvector6 initKepler(GmatSolarSystemDefaults::PLANET_TWO_BODY_ELEMENTS[GmatSolarSystemDefaults::EARTH]);
   twoBodyKepler = initKepler;

   mass        = mu / GmatPhysicalConstants::UNIVERSAL_GRAVITATIONAL_CONSTANT;
   polarRadius = (1.0 - flattening) * equatorialRadius;
   
   // try to find the texture map file
   // if (textureMapFileName != "" && !GmatFileUtil::DoesFileExist(textureMapFileName.c_str()))
   // {
   //    std::string textureLoc = (FileManager::Instance())->GetFullPathname("TEXTURE_PATH");
   //    textureMapFileName = textureLoc + textureMapFileName;
   // }
   
   // Call SetTextureMapFileName() to use FileManager::FindPath() (LOJ: 2014.06.18)
   #ifdef DEBUG_TEXTURE_FILE
   MessageInterface::ShowMessage("2 Calling SetTextureMapFileName()\n");
   #endif
   SetTextureMapFileName(textureMapFileName);
   
   for (Integer i = 0; i < Gmat::ModelTypeCount; i++)
      models[i].push_back("None");
   for (Integer i=0;i<6;i++)  prevState[i] = 0.0;
   
   #ifdef __USE_SPICE__
      kernelReader = NULL;
      mainSPK      = "";
      mainPCK      = "";
   #endif
   orbitSpiceKernelNames.clear();
   
   parameterCount = CelestialBodyParamCount;
   
   InitializeBody(Gmat::BODY_TYPE_STRINGS[itsBodyType]);
   
   SaveAllAsDefault();
   
   #ifdef DEBUG_CB_CONSTRUCTOR
   MessageInterface::ShowMessage
      ("CelestialBody(bodyType) <%p> '%s' constructor entered\n",
       this, GetName().c_str());
   #endif
}

//------------------------------------------------------------------------------
//  CelestialBody(const CelestialBody &cBody)
//------------------------------------------------------------------------------
/**
 * This method creates an object of the CelestialBody class as a copy of the
 * specified CelestialBody class (copy constructor).
 *
 * @param <cBody> CelestialBody object to copy.
 */
//------------------------------------------------------------------------------
CelestialBody::CelestialBody(const CelestialBody &cBody) :
   SpacePoint          (cBody),
   bodyType            (cBody.bodyType),
   mass                (cBody.mass),
   equatorialRadius    (cBody.equatorialRadius),
   flattening          (cBody.flattening),
   polarRadius         (cBody.polarRadius),
   mu                  (cBody.mu),
   posVelSrc           (cBody.posVelSrc),
   theCentralBodyName  (cBody.theCentralBodyName),
   theCentralBody      (cBody.theCentralBody),    // correct?
   centralBodySet      (cBody.centralBodySet),    // correct?
   bodyNumber          (cBody.bodyNumber),
   referenceBodyNumber (cBody.referenceBodyNumber),
   sourceFilename      (cBody.sourceFilename),
   theSourceFile       (cBody.theSourceFile), // ????????????????
   usePotentialFile    (cBody.usePotentialFile),
   potentialFileName   (cBody.potentialFileName),
   potentialFileNameFullPath (cBody.potentialFileNameFullPath),
   hourAngle           (cBody.hourAngle),
   atmModel            (NULL),
   atmModelType        (cBody.atmModelType),
   potentialFileRead   (false),
   default_equatorialRadius      (cBody.default_equatorialRadius),
   default_flattening            (cBody.default_flattening),
   default_mu                    (cBody.default_mu),
   default_posVelSrc             (cBody.default_posVelSrc),
   default_centralBodyName       (cBody.default_centralBodyName),
   default_orbitSpiceKernelNames (cBody.default_orbitSpiceKernelNames),
   default_rotationSrc           (cBody.default_rotationSrc), 
   default_twoBodyEpoch          (cBody.default_twoBodyEpoch),
   default_twoBodyKepler         (cBody.default_twoBodyKepler),
   default_orientationEpoch      (cBody.default_orientationEpoch),
   default_orientation           (cBody.default_orientation),
   default_textureMapFileName    (cBody.default_textureMapFileName),
   order               (cBody.order),
   degree              (cBody.degree),
//   sij                 (cBody.sij),
//   cij                 (cBody.cij),
   twoBodyFormat       (cBody.twoBodyFormat),
   twoBodyStateType    (cBody.twoBodyStateType),
   twoBodyEpoch        (cBody.twoBodyEpoch),
   twoBodyKepler       (cBody.twoBodyKepler),
   prevTwoBodyEpoch    (cBody.prevTwoBodyEpoch),
   prevTwoBodyState    (cBody.prevTwoBodyState),
   newTwoBody          (cBody.newTwoBody),
   overrideTime        (cBody.overrideTime),
   ephemUpdateInterval (cBody.ephemUpdateInterval),
   lastEphemTime       (cBody.lastEphemTime),
   lastState           (cBody.lastState),
   j2kState            (cBody.j2kState),
   rotationSrc         (cBody.rotationSrc),
   userDefined         (cBody.userDefined),
   allowSpice          (cBody.allowSpice),
   orientationDateFormat (cBody.orientationDateFormat),
   orientationEpoch    (cBody.orientationEpoch),
   orientation         (cBody.orientation),
   naifIdSet           (cBody.naifIdSet),
   naifName            (cBody.naifName),
   textureMapFileName  (cBody.textureMapFileName),
   textureMapFullPath  (cBody.textureMapFullPath),
   view3dModelFileName     (cBody.view3dModelFileName),
   view3dModelFileFullPath (cBody.view3dModelFileFullPath),
   view3dModelId        (cBody.view3dModelId),
   view3dModelOffsetX   (cBody.view3dModelOffsetX),
   view3dModelOffsetY   (cBody.view3dModelOffsetY),
   view3dModelOffsetZ   (cBody.view3dModelOffsetZ),
   view3dModelRotationX (cBody.view3dModelRotationX),
   view3dModelRotationY (cBody.view3dModelRotationY),
   view3dModelRotationZ (cBody.view3dModelRotationZ),   
   view3dModelScale     (cBody.view3dModelScale),
   msgWritten           (cBody.msgWritten)
{
   state                  = cBody.state;
   stateTime              = cBody.stateTime;
   angularVelocity        = cBody.angularVelocity;
   isFirstTimeMu          = true;
   isFirstTimeRadius      = true;
   #ifdef __USE_SPICE__
      kernelReader = NULL;
      mainSPK      = "";
      mainPCK      = "";
   #endif
   
   if (cBody.atmModel)
   {
      AtmosphereModel *clonedAM = (AtmosphereModel*)(cBody.atmModel->Clone());   
      #ifdef DEBUG_MEMORY
      MemoryTracker::Instance()->Add
         (clonedAM, clonedAM->GetName(), "CelestialBody::copy constructor",
          "clonedAM = (AtmosphereModel*)cBody.atmModel->Clone()");
      #endif
      atmModel = clonedAM;
      #ifdef DEBUG_CELESTIAL_BODY
      MessageInterface::ShowMessage
         ("CelestialBody::CelestialBody() Setting ATM:%s on %s\n",
          atmModel->GetName().c_str(), instanceName.c_str());
      #endif
   }
   
   for (Integer i = 0; i < Gmat::ModelTypeCount; i++)
      models[i] = cBody.models[i];
   
   for (Integer i=0;i<6;i++)  prevState[i] = cBody.prevState[i];
   
   #ifdef DEBUG_CB_CONSTRUCTOR
   MessageInterface::ShowMessage
      ("CelestialBody() <%p> '%s' copy constructor entered\n", this, GetName().c_str());
   #endif
}

//------------------------------------------------------------------------------
//  CelestialBody& operator= (const CelestialBody& cBody)
//------------------------------------------------------------------------------
/**
 * Assignment operator for the CelestialBody class.
 *
 * @param <cBody> the CelestialBody object whose data to assign to "this"
 *            solar system.
 *
 * @return "this" CelestialBody with data of input CelestialBody cb.
 */
//------------------------------------------------------------------------------
CelestialBody& CelestialBody::operator=(const CelestialBody &cBody)
{
   if (&cBody == this)
      return *this;

   SpacePoint::operator=(cBody);
   bodyType            = cBody.bodyType;
   mass                = cBody.mass;
   equatorialRadius    = cBody.equatorialRadius;
   flattening          = cBody.flattening;
   polarRadius         = cBody.polarRadius;
   mu                  = cBody.mu;
   posVelSrc           = cBody.posVelSrc;
   state               = cBody.state;
   stateTime           = cBody.stateTime;
   theCentralBodyName  = cBody.theCentralBodyName;
   theCentralBody      = cBody.theCentralBody;
   centralBodySet      = cBody.centralBodySet;
   bodyNumber          = cBody.bodyNumber;
   referenceBodyNumber = cBody.referenceBodyNumber;
   sourceFilename      = cBody.sourceFilename;
   theSourceFile       = cBody.theSourceFile;
   #ifdef __USE_SPICE__
   kernelReader        = cBody.kernelReader;
   mainSPK             = cBody.mainSPK;
   mainPCK             = cBody.mainPCK;
   #endif
   usePotentialFile    = cBody.usePotentialFile;
   potentialFileName   = cBody.potentialFileName;
   potentialFileNameFullPath = cBody.potentialFileNameFullPath;
   angularVelocity     = cBody.angularVelocity;
   hourAngle           = cBody.hourAngle;
   atmModelType        = cBody.atmModelType;
   potentialFileRead   = false;
   
   default_equatorialRadius       = cBody.default_equatorialRadius;
   default_flattening             = cBody.default_flattening;
   default_mu                     = cBody.default_mu;
   default_posVelSrc              = cBody.default_posVelSrc;
   default_centralBodyName        = cBody.default_centralBodyName;
   default_orbitSpiceKernelNames  = cBody.default_orbitSpiceKernelNames;
   default_rotationSrc            = cBody.default_rotationSrc; 
   default_twoBodyEpoch           = cBody.default_twoBodyEpoch;
   default_twoBodyKepler          = cBody.default_twoBodyKepler;
   default_orientationEpoch       = cBody.default_orientationEpoch;
   default_orientation            = cBody.default_orientation;
   default_textureMapFileName     = cBody.default_textureMapFileName;
   
   isFirstTimeMu                  = cBody.isFirstTimeMu;
   isFirstTimeRadius              = cBody.isFirstTimeRadius;
   
   if (atmModel)
   {
      #ifdef DEBUG_MEMORY
      MemoryTracker::Instance()->Remove
         (atmModel, atmModel->GetName(), "CelestialBody::operator=",
          "deleting atmModel");
      #endif
      delete atmModel;
   }
   
   if (cBody.atmModel)
   {
      //atmModel = (AtmosphereModel*)(cBody.atmModel)->Clone();
      AtmosphereModel *clonedAM = (AtmosphereModel*)(cBody.atmModel)->Clone();
      #ifdef DEBUG_MEMORY
      MemoryTracker::Instance()->Add
         (clonedAM, clonedAM->GetName(), "CelestialBody::operator=",
          "clonedAM = (AtmosphereModel*)cBody.atmModel->Clone()");
      #endif
      atmModel = clonedAM;
   }
   else
      atmModel = NULL;
      
   twoBodyFormat       = cBody.twoBodyFormat;
   twoBodyStateType    = cBody.twoBodyStateType;
   twoBodyEpoch        = cBody.twoBodyEpoch;
   twoBodyKepler       = cBody.twoBodyKepler;
   prevTwoBodyEpoch    = cBody.prevTwoBodyEpoch;
   prevTwoBodyState    = cBody.prevTwoBodyState;
   newTwoBody          = cBody.newTwoBody;
   overrideTime        = cBody.overrideTime;
   ephemUpdateInterval = cBody.ephemUpdateInterval;
   lastEphemTime       = cBody.lastEphemTime;
   lastState           = cBody.lastState;
   j2kState            = cBody.j2kState;
   rotationSrc         = cBody.rotationSrc;
   userDefined         = cBody.userDefined;
   allowSpice          = cBody.allowSpice;
   orientationDateFormat = cBody.orientationDateFormat;
   orientationEpoch    = cBody.orientationEpoch;
   orientation         = cBody.orientation;
   
   naifIdSet           = cBody.naifIdSet;
   naifName            = cBody.naifName;
   
   textureMapFileName  = cBody.textureMapFileName;
   textureMapFullPath  = cBody.textureMapFullPath;
   view3dModelFileName     = cBody.view3dModelFileName;
   view3dModelFileFullPath = cBody.view3dModelFileFullPath;
   view3dModelId        = cBody.view3dModelId;
   view3dModelScale     = cBody.view3dModelScale;
   view3dModelOffsetX   = cBody.view3dModelOffsetX;
   view3dModelOffsetY   = cBody.view3dModelOffsetY;
   view3dModelOffsetZ   = cBody.view3dModelOffsetZ;
   view3dModelRotationX = cBody.view3dModelRotationX;
   view3dModelRotationY = cBody.view3dModelRotationY;
   view3dModelRotationZ = cBody.view3dModelRotationZ;   
   view3dModelScale     = cBody.view3dModelScale;
   msgWritten           = cBody.msgWritten;
   
   for (Integer i=0;i<6;i++)  prevState[i] = cBody.prevState[i];

   for (Integer i = 0; i < Gmat::ModelTypeCount; i++)
      models[i] = cBody.models[i];

   return *this;
}

//------------------------------------------------------------------------------
//  ~CelestialBody()
//------------------------------------------------------------------------------
/**
 * Destructor for the CelestialBody class.
 */
//------------------------------------------------------------------------------
CelestialBody::~CelestialBody()
{
   #ifdef DEBUG_CB_DESTRUCT
      MessageInterface::ShowMessage(" Entering CelestialBody destructor for body %s .........\n", instanceName.c_str());
   #endif
   if (atmModel)
   {
      #ifdef DEBUG_MEMORY
      MemoryTracker::Instance()->Remove
         (atmModel, atmModel->GetName(), "CelestialBody::~CelestialBody()",
          "deleting atmModel");
      #endif
      delete atmModel;
   }
   #ifdef __USE_SPICE__
   UnloadKernels(true, true, true, false);
   // unload the kernel(s) from the SpiceKernelReader  // @todo  ADD the other kernels here
//      if (kernelReader != NULL)
//      {
//         for (unsigned int kk = 0; kk < orbitSpiceKernelNames.size(); kk++)
//         {
//            if ((orbitSpiceKernelNames.at(kk) != "") && (orbitSpiceKernelNames.at(kk) != mainSPK))
//            {
//               #ifdef DEBUG_CB_SPICE
//                  MessageInterface::ShowMessage("In CB (%s) destructor, attempting to unload the kernel %s\n",
//                        instanceName.c_str(), (orbitSpiceKernelNames.at(kk)).c_str());
//               #endif
//               if (kernelReader->IsLoaded(orbitSpiceKernelNames.at(kk)))
//               {
//                  #ifdef DEBUG_CB_SPICE
//                     MessageInterface::ShowMessage("... the kernel is still loaded ... so unloading\n");
//                  #endif
//                  kernelReader->UnloadKernel(orbitSpiceKernelNames.at(kk));
//                  #ifdef DEBUG_CB_SPICE
//                     MessageInterface::ShowMessage("... the kernel %s successfully unloaded\n", (orbitSpiceKernelNames.at(kk)).c_str());
//                  #endif
//               }
//            }
//         }
//      }
   #endif
   #ifdef DEBUG_CB_DESTRUCT
      MessageInterface::ShowMessage(" Exiting CelestialBody destructor for body %s .........\n", instanceName.c_str());
   #endif
}


//------------------------------------------------------------------------------
// bool Initialize()
//------------------------------------------------------------------------------
/**
 * Initializes the CelestialBody class.
 *
 * @return  success flag
 */
//------------------------------------------------------------------------------
bool CelestialBody::Initialize()
{
   #ifdef DEBUG_CB_INIT
   MessageInterface::ShowMessage
      ("CelestialBody::Initialize() this=<%p> %10s, posVelSrc=%d, ephemUpdateInterval=%f\n",
       this, GetName().c_str(), posVelSrc, ephemUpdateInterval);
   #endif
   
   // Do we need to reset this?
   // When running GmatFunction, this causes to write message about using default mu
   // in every function call
   // Commented out for now(loj: 2008.10.03)
   //isFirstTimeMu = true;
   //isFirstTimeRadius = true;
   
   lastEphemTime = 0.0;
   stateTime = 0.0;   
   newTwoBody = true;

   if (!centralBodySet)
   {
      std::string errmsg = "Central body \"";
      errmsg += theCentralBodyName + "\" not set for body \"";
      errmsg += instanceName + "\"";
      throw SolarSystemException(errmsg);
   }
   
   // Set to false so that it can be reset to valid spiceNaifId
   // when running function (LOJ: 2010.05.17)
   naifIdSet = false;
   
   // Set up the kernel reader, if required
   SetUpSPICE();
   return true;
}

//------------------------------------------------------------------------------
// void SetUpBody()
//------------------------------------------------------------------------------
/**
 * Sets up the body and checks for missing references.
 */
//------------------------------------------------------------------------------
void CelestialBody::SetUpBody()
{
   // main thing to do for now is to make sure the central body is set
   if (!theSolarSystem)
   {
      std::string errmsg = "Solar System not set for body \"";
      errmsg += instanceName + "\"\n";
      throw SolarSystemException(errmsg);
   }
   if (!theCentralBody)
   {
      CelestialBody *cBody  = theSolarSystem->GetBody(theCentralBodyName);
      if (!cBody)
      {
         std::string errmsg = "Cannot set central body for body \"";
         errmsg += instanceName + "\" because body \"";
         errmsg += theCentralBodyName + "\" cannot be found.\n";
         throw SolarSystemException (errmsg);
      }
      SetRefObject(cBody, Gmat::CELESTIAL_BODY, theCentralBodyName);
   }
   if (RequiresJ2000Body() && j2000Body == NULL)
   {
      j2000Body = theSolarSystem->GetBody(j2000BodyName);
   }
   // add other set-up kinds of things later?
   return;
}

//------------------------------------------------------------------------------
// Real GetEpoch()
//------------------------------------------------------------------------------
/**
 * Accessor for the current epoch of the object, in A.1 Modified Julian format.
 *
 * @return The A.1 epoch.
 *
 * @todo The epoch probably should be TAI throughout GMAT.
 */
//------------------------------------------------------------------------------
Real CelestialBody::GetEpoch()
{
   #ifdef DEBUG_CB_EPOCH
      MessageInterface::ShowMessage("Entering CB::GetEpoch and returning %le\n",
            stateTime.Get());
   #endif
   return lastEphemTime.Get();
}


//------------------------------------------------------------------------------
// Real SetEpoch(const Real ep)
//------------------------------------------------------------------------------
/**
 * Accessor used to set epoch (in A.1 Modified Julian format) of the object.
 *
 * @param <ep> The new A.1 epoch.
 *
 * @return The updated A.1 epoch.
 *
 * @todo The epoch probably should be TAI throughout GMAT.
 */
//------------------------------------------------------------------------------
Real CelestialBody::SetEpoch(const Real ep)
{
   #ifdef DEBUG_CB_EPOCH
      MessageInterface::ShowMessage(
            "Entering CB::SetEpoch and setting stateTime to %le\n",
            ep);
   #endif
   A1Mjd a1(ep);
   GetMJ2000State(a1);  // will set j2kState and lastEphemTime
   return lastEphemTime.Get();
}

Rvector6 CelestialBody::GetLastState()
{
   return j2kState;
}


//------------------------------------------------------------------------------
// const Real GetFirstStateTime()
//------------------------------------------------------------------------------
/**
 * Returns the first SPK state time.
 *
 * @return the first state time from the SPK file(s), or the default
 * initial state time.
 */
//------------------------------------------------------------------------------
Real CelestialBody::GetFirstStateTime(){
   Real retval = -999.0;
   switch (posVelSrc)
   {
      case Gmat::SPICE :
      {
         #ifdef __USE_SPICE__
            if (!spiceSetupDone) SetUpSPICE();
            Real startCov = 0.0;
            Real endCov   = 0.0;
            // Make sure we are looking for coverage in the main SPK kernel as well
            StringArray allKernels = orbitSpiceKernelNames;
            mainSPK                = theSolarSystem->GetStringParameter("SPKFilename");
            mainPCK                = theSolarSystem->GetStringParameter("PCKFilename");
            if (mainSPK != "")  allKernels.push_back(mainSPK);
            if (mainPCK != "")  allKernels.push_back(mainPCK);  // correct?
            #ifdef DEBUG_CB_SPICE
               MessageInterface::ShowMessage("Calling GetCoverage with naifId = %d\n", naifId);
               MessageInterface::ShowMessage("   and allKernels are: \n");
               for (unsigned int ii = 0; ii < allKernels.size(); ii++)
                  MessageInterface::ShowMessage("   %d    %s\n", (Integer) ii,
                        allKernels.at(ii).c_str());
            #endif
            kernelReader->GetCoverageStartAndEnd(allKernels, naifId, startCov, endCov);
            retval = startCov;
         #else
            std::string errmsg = "Use of SPICE file was disabled";
            throw SolarSystemException(errmsg);
         #endif
         break;
      }
      default:
         retval = DEFAULT_INITIAL_STATE_TIME;
         break;
   }

   return retval;
}



//------------------------------------------------------------------------------
//  const Rvector6& GetState(A1Mjd atTime)
//------------------------------------------------------------------------------
/**
 * This method returns the state (position and velocity) of the body at the
 * requested time.
 *
 * @param <atTime>  time for which state of the body is requested.
 *
 * @return state of the body at the requested time.
 *
 * @exception <PlanetaryEphemException> thrown when the requested Pos/Vel
 *            source is set, but the source file has not been set.
 */
//------------------------------------------------------------------------------
const Rvector6&  CelestialBody::GetState(A1Mjd atTime)
{
   if (!theCentralBody) SetUpBody();

   #ifdef DEBUG_GET_STATE
   MessageInterface::ShowMessage
      ("CelestialBody::GetState() <%p> '%s' entered with time %.17f\n", this,
       GetName().c_str(), atTime.Get());
   MessageInterface::ShowMessage
      ("   posVelSrc=%d for <%p> %s\n", posVelSrc, this, GetName().c_str());
   MessageInterface::ShowMessage("   lastEphemTime = %.17f\n",lastEphemTime.Get());
   #endif
   
   Real dt = Abs(atTime.Subtract(lastEphemTime)) * GmatTimeConstants::SECS_PER_DAY;
   if ( dt < ephemUpdateInterval)
   {
      #ifdef DEBUG_GET_STATE
      MessageInterface::ShowMessage("   returning lastState %s\n", state.ToString().c_str());
      #endif
      return lastState;
   }
   
   Real*     posVel = NULL;
   switch (posVelSrc)
   {
//      case Gmat::TWO_BODY_PROPAGATION :   // 2012.01.24 - wcs - disallow for now
//         state = ComputeTwoBody(atTime);
//         break;
      // DE405, DE421,DE424, and DE430 read data from theSourceFile
      case Gmat::DE405 :
      case Gmat::DE421 :
      case Gmat::DE424 :
//      case Gmat::DE430 :
      {
         if (!theSourceFile)
         {
            throw PlanetaryEphemException(
                  "DE file requested, but no file specified");
         }
         #ifdef DEBUG_GET_STATE
         MessageInterface::ShowMessage
            ("   In <%p> '%s', Calling theSourceFile(%s)->GetPosVel(%d, %f, %s)\n",
             this, GetName().c_str(), (theSourceFile->GetName()).c_str(), bodyNumber, atTime.GetReal(),
             overrideTime ? "true" : "false");
         #endif
         posVel     = theSourceFile->GetPosVel(bodyNumber, atTime, overrideTime);
         state.Set(posVel[0], posVel[1], posVel[2],
                   posVel[3], posVel[4], posVel[5]);
         break;
      }
      case Gmat::SPICE :
      {
         #ifdef __USE_SPICE__
            if (!spiceSetupDone) SetUpSPICE();
            Rvector6 spiceState = kernelReader->GetTargetState(naifName, naifId, atTime, j2000BodyName, naifIdObserver);
            state.Set(spiceState[0], spiceState[1], spiceState[2],
                      spiceState[3], spiceState[4], spiceState[5]);
            #ifdef DEBUG_CB_SPICE_VS_DE
               Real *deState;
               deState = (Real *)malloc(6);
               deState = theSourceFile->GetPosVel(bodyNumber,atTime, overrideTime);
               MessageInterface::ShowMessage("for body %s, for time: %12.10f:\n", instanceName.c_str(), atTime.Get());
               MessageInterface::ShowMessage("     SPICE state is: %12.10f  %12.10f  %12.10f  %12.10f  %12.10f  %12.10f\n",
                     spiceState[0], spiceState[1], spiceState[2], spiceState[3], spiceState[4], spiceState[5]);
               MessageInterface::ShowMessage("     DE state is:    %12.10f  %12.10f  %12.10f  %12.10f  %12.10f  %12.10f\n",
                     deState[0], deState[1], deState[2], deState[3], deState[4], deState[5]);
               delete deState;
            #endif
         #else
            // Throw an error if GMAT was not build with __USE_SPICE__ (LOJ: 2010.05.18)
            std::string errmsg = "Use of SPICE file was disabled";
            throw SolarSystemException(errmsg);
         #endif
         break;
      }
      default:
         throw SolarSystemException("Invalid data source defined for body "
                                    + instanceName);
         break;
   }
   stateTime     = atTime;
   lastEphemTime = atTime;
   lastState     = state;
   
   for (Integer i=0;i<6;i++)
      prevState[i] = lastState[i];
   
   #ifdef DEBUG_GET_STATE
   MessageInterface::ShowMessage("   returning state %s\n", state.ToString().c_str());
   #endif
   
   return state;
}

//------------------------------------------------------------------------------
//  const Rvector6& GetState(Real atTime)
//------------------------------------------------------------------------------
/**
 * This method returns the state (position and velocity) of the body at the
 * requested time.
 *
 * @param <atTime>  time for which state of the body is requested.
 *
 * @return state of the body at the requested time.
 *
 * @exception <PlanetaryEphemException> thrown when the requested Pos/Vel
 *            source is set, but the source file has not been set.
 */
//------------------------------------------------------------------------------
const Rvector6&  CelestialBody::GetState(Real atTime)
{
   A1Mjd forTime(atTime);
   return GetState(forTime);
}


//------------------------------------------------------------------------------
// void GetState(const A1Mjd &atTime, Real *outState)
//------------------------------------------------------------------------------
/**
 * This method returns the state (position and velocity) of the body at the
 * requested time.
 *
 * @param <atTime>   time for which state of the body is requested.
 * @param <outState> output resulting state
 *
 * @exception <PlanetaryEphemException> thrown when the requested Pos/Vel
 *            source is set, but the source file has not been set.
 */
//------------------------------------------------------------------------------
void CelestialBody::GetState(const A1Mjd &atTime, Real *outState)
{
   #ifdef DEBUG_GET_STATE
      MessageInterface::ShowMessage("Entering GetState with time %.17f\n",
      atTime.Get());
   #endif
      
   if (!theCentralBody) SetUpBody();

   Real dt = Abs(atTime.Subtract(lastEphemTime)) * GmatTimeConstants::SECS_PER_DAY;
   if ( dt < ephemUpdateInterval)
   {
      for (Integer i=0;i<6;i++) outState[i] = prevState[i];
   }
   
//   Rvector6 state;
   switch (posVelSrc)
   {
//      case Gmat::TWO_BODY_PROPAGATION :  // 2012.01.24 - wcs - disallow for now
//      {
//         state = ComputeTwoBody(atTime);
//         for (Integer i=0;i<6;i++) outState[i] = state[i];
//         break;
//      }
      case Gmat::DE405 :
         if (!theSourceFile)
         {
            throw PlanetaryEphemException(
                  "DE 405 file requested, but no file specified");
         }
         #ifdef DEBUG_GET_STATE
         MessageInterface::ShowMessage
            ("   In <%p> '%s', Calling theSourceFile(%s)->GetPosVel(%d, %f, %s)\n",
             this, GetName().c_str(), (theSourceFile->GetName()).c_str(), bodyNumber, atTime.GetReal(),
             overrideTime ? "true" : "false");
         #endif
         outState     = theSourceFile->GetPosVel(bodyNumber,atTime, overrideTime);
         break;

      case Gmat::DE421 :
          if (!theSourceFile)
          {
             throw PlanetaryEphemException(
                   "DE 421 file requested, but no file specified");
          }
          #ifdef DEBUG_GET_STATE
          MessageInterface::ShowMessage
             ("   In <%p> '%s', Calling theSourceFile(%s)->GetPosVel(%d, %f, %s)\n",
              this, GetName().c_str(), (theSourceFile->GetName()).c_str(), bodyNumber, atTime.GetReal(),
              overrideTime ? "true" : "false");
          #endif
          outState     = theSourceFile->GetPosVel(bodyNumber,atTime, overrideTime);
          break;

      case Gmat::DE424 :
          if (!theSourceFile)
          {
             throw PlanetaryEphemException(
                   "DE 424 file requested, but no file specified");
          }
          #ifdef DEBUG_GET_STATE
          MessageInterface::ShowMessage
             ("   In <%p> '%s', Calling theSourceFile(%s)->GetPosVel(%d, %f, %s)\n",
              this, GetName().c_str(), (theSourceFile->GetName()).c_str(), bodyNumber, atTime.GetReal(),
              overrideTime ? "true" : "false");
          #endif
          outState     = theSourceFile->GetPosVel(bodyNumber,atTime, overrideTime);
          break;

//      case Gmat::DE430 :
//          if (!theSourceFile)
//          {
//             throw PlanetaryEphemException(
//                   "DE 430 file requested, but no file specified");
//          }
//          #ifdef DEBUG_GET_STATE
//          MessageInterface::ShowMessage
//             ("   In <%p> '%s', Calling theSourceFile(%s)->GetPosVel(%d, %f, %s)\n",
//              this, GetName().c_str(), (theSourceFile->GetName()).c_str(), bodyNumber, atTime.GetReal(),
//              overrideTime ? "true" : "false");
//          #endif
//          outState     = theSourceFile->GetPosVel(bodyNumber,atTime, overrideTime);
//          break;
//
      case Gmat::SPICE :
      #ifdef __USE_SPICE__
         if (!spiceSetupDone) SetUpSPICE();
         state = kernelReader->GetTargetState(naifName, naifId, atTime, j2000BodyName, naifIdObserver);
         for (Integer i=0;i<6;i++) outState[i] = state[i];
         #ifdef DEBUG_CB_SPICE_VS_DE
            Real *deState;
            deState = (Real *)malloc(6);
            deState = theSourceFile->GetPosVel(bodyNumber,atTime, overrideTime);
            MessageInterface::ShowMessage("for body %s, for time: %12.10f:\n", instanceName.c_str(), atTime.Get());
            MessageInterface::ShowMessage("     SPICE state is: %12.10f  %12.10f  %12.10f  %12.10f  %12.10f  %12.10f\n",
                  state[0], state[1], state[2], state[3], state[4], state[5]);
            MessageInterface::ShowMessage("     DE state is:    %12.10f  %12.10f  %12.10f  %12.10f  %12.10f  %12.10f\n",
                  deState[0], deState[1], deState[2], deState[3], deState[4], deState[5]);
            delete deState;
         #endif

      #endif
         break;
      default:
         throw SolarSystemException("Invalid data source defined for body "
                                    + instanceName);
         break;
   }
   
   stateTime     = atTime;
   lastEphemTime = atTime;
   state.Set(outState[0],outState[1],outState[2],outState[3],outState[4],outState[5]);
   lastState.Set(outState[0],outState[1],outState[2],outState[3],outState[4],outState[5]);
   
   for (Integer i=0;i<6;i++)
      prevState[i] = outState[i];
   
   #ifdef DEBUG_GET_STATE
      MessageInterface::ShowMessage("Exiting GetState -------------f\n");
   #endif
}

//------------------------------------------------------------------------------
//  Gmat::BodyType GetBodyType() const
//------------------------------------------------------------------------------
/**
 * This method returns the body type of the body.
 *
 * @return body type of the body.
 *
 */
//------------------------------------------------------------------------------
Gmat::BodyType CelestialBody::GetBodyType() const
{
   return bodyType;
}

//------------------------------------------------------------------------------
//  const std::string& GetCentralBody() const
//------------------------------------------------------------------------------
/**
 * This method returns the name of the central body of the body.
 *
 * @return name of the central body of the body.
 *
 */
//------------------------------------------------------------------------------
const std::string& CelestialBody::GetCentralBody() const
{
   return theCentralBodyName;
}


//------------------------------------------------------------------------------
//  Real GetGravitationalConstant() 
//------------------------------------------------------------------------------
/**
 * This method returns the gravitational constant (km^3/s^2) of the body.
 *
 * @return gravitational constant of the body.
 *
 */
//------------------------------------------------------------------------------
Real CelestialBody::GetGravitationalConstant() 
{
   #ifdef DEBUG_GRAV_CONST
   MessageInterface::ShowMessage
      ("CelestialBody::GetGravitationalConstant() this=<%p>, usePotentialFile=%d for %s, "
       "isFirstTimeMu=%d\n", this, usePotentialFile, instanceName.c_str(), isFirstTimeMu);
   #endif
   
   if (usePotentialFile == true)
   {
      if (!potentialFileRead)
      {
         if (!ReadPotentialFile())
         {
            if (isFirstTimeMu)
            {
               MessageInterface::ShowMessage
                  ("For body %s, cannot read file \"%s\", so using default mu"
                   " (%.18f)\n", instanceName.c_str(),
                   potentialFileName.c_str(), default_mu);
               
               isFirstTimeMu = false;
            }
            
            mu = default_mu;
         }
      }
      else
      {
         if (isFirstTimeMu)
         {
            MessageInterface::LogMessage
               ("For body %s, using mu (%.18f) from file \"%s\"\n",
                //instanceName.c_str(), mu, potentialFileName.c_str());
                instanceName.c_str(), mu, potentialFileNameFullPath.c_str());
            
            isFirstTimeMu = false;
         }
      }
   }
   else
   {
      if (isFirstTimeMu)
      {
         MessageInterface::LogMessage
            ("For body %s, not using potential file, so using default mu (%.18f)\n",
             instanceName.c_str(), mu);
         
         isFirstTimeMu = false;
      }
   }
   
   // recompute mass
   mass = mu / GmatPhysicalConstants::UNIVERSAL_GRAVITATIONAL_CONSTANT;
   return mu;
}

//------------------------------------------------------------------------------
//  Real GetEquatorialRadius() 
//------------------------------------------------------------------------------
/**
* This method returns the equatorial radius (km) of the body.
 *
 * @return equatorial radius of the body.
 *
 */
//------------------------------------------------------------------------------
Real CelestialBody::GetEquatorialRadius() 
{   
   #ifdef DEBUG_CB_EQ_RAD
      MessageInterface::ShowMessage("Entering GetEquatorialRadius, %s equatorialRadius = %12.10f\n",
            instanceName.c_str(), equatorialRadius);
      MessageInterface::ShowMessage("    usePotentialFile = %s\n", (usePotentialFile? "true" : "false"));
   #endif
   if (usePotentialFile == true)
   {
      if (!potentialFileRead)
      {
         if (!ReadPotentialFile())
         {
            if (isFirstTimeRadius)
            {
               MessageInterface::ShowMessage
                  ("For body %s, cannot read file \"%s\", so using default eq. radius"
                   " (%.18f)\n", instanceName.c_str(),
                   //potentialFileName.c_str(), default_equatorialRadius);
                   potentialFileNameFullPath.c_str(), default_equatorialRadius);
               
               isFirstTimeRadius = false;
            }
         
            equatorialRadius = default_equatorialRadius;
         }
      }
      else
      {
         if (isFirstTimeRadius)
         {
            MessageInterface::ShowMessage
               ("For body %s, using eq. radius (%.18f) from file \"%s\"\n",
                //instanceName.c_str(), equatorialRadius, potentialFileName.c_str());
                instanceName.c_str(), equatorialRadius, potentialFileNameFullPath.c_str());
         
            isFirstTimeRadius = false;
         }
      }
   }
   else
   {
      if (isFirstTimeRadius)
      {
         MessageInterface::LogMessage
            ("For body %s, not using potential file, so using default eq. radius (%.18f)\n",
             instanceName.c_str(), equatorialRadius);
         
         isFirstTimeRadius = false;
      }
   }
   
   // recompute the polar radius
   polarRadius = (1.0 - flattening) * equatorialRadius;
   #ifdef DEBUG_CB_EQ_RAD
      MessageInterface::ShowMessage("Exiting GetEquatorialRadius, %s equatorialRadius = %12.10f\n",
            instanceName.c_str(), equatorialRadius);
   #endif
   return equatorialRadius;
}

//------------------------------------------------------------------------------
//  Real GetFlattening() const
//------------------------------------------------------------------------------
/**
 * This method returns the flattening coefficient of the body.
 *
 * @return flattening of the body.
 *
 */
//------------------------------------------------------------------------------
Real CelestialBody::GetFlattening() const
{
   return flattening;
}

//------------------------------------------------------------------------------
//  Real GetPolarRadius() 
//------------------------------------------------------------------------------
/**
 * This method returns the polar radius (km) of the body.
 *
 * @return polar radius of the body.
 *
 */
//------------------------------------------------------------------------------
Real CelestialBody::GetPolarRadius() 
{
   // make sure it is computed correctly
   polarRadius = (1.0 - flattening) * equatorialRadius;
   return polarRadius;   
}

//------------------------------------------------------------------------------
//  Real GetMass() 
//------------------------------------------------------------------------------
/**
 * This method returns the mass (kg) of the body.
 *
 * @return mass of the body.
 *
 */
//------------------------------------------------------------------------------
 Real CelestialBody::GetMass() 
{
   // make sure it is computed correctly
   mass = mu / GmatPhysicalConstants::UNIVERSAL_GRAVITATIONAL_CONSTANT;
   return mass;
}

//------------------------------------------------------------------------------
//  Gmat::PosVelSource GetPosVelSource() const
//------------------------------------------------------------------------------
/**
 * This method returns the source of position and velocity for the body.
 *
 * @return position/velocity source for the body.
 *
 */
//------------------------------------------------------------------------------
Gmat::PosVelSource  CelestialBody::GetPosVelSource() const
{
   return posVelSrc;
}

//------------------------------------------------------------------------------
// std::string GetSourceFileName() const
//------------------------------------------------------------------------------
/**
 * This method returns the source file name.
 *
 * @return source file name.
 *
 */
//------------------------------------------------------------------------------
std::string CelestialBody::GetSourceFileName() const
{
   if (theSourceFile)
      return theSourceFile->GetName();
   return "";
}

//------------------------------------------------------------------------------
// PlanetaryEphem* GetSourceFile() const
//------------------------------------------------------------------------------
/**
 * This method returns the source file pointer for the body.
 *
 * @return position/velocity source file pointer
 *
 */
//------------------------------------------------------------------------------
PlanetaryEphem*  CelestialBody::GetSourceFile() const
{
   return theSourceFile;
}

//------------------------------------------------------------------------------
//  bool CelestialBody::GetUsePotentialFile() const
//------------------------------------------------------------------------------
/**
 * This method returns the flag indicating whether or not to use the potential
 * file for the body.
 *
 * @return flag indicating whether or not to use the potential file to determine
 *         mu, radius, and spherical harmonic coefficients.
 *
 */
//------------------------------------------------------------------------------
bool CelestialBody::GetUsePotentialFile() const
{
   return usePotentialFile;
}


//------------------------------------------------------------------------------
// bool GetOverrideTimeSystem() const
//------------------------------------------------------------------------------
/**
 * This method returns the flag indicating whether or not override the time
 * system for the body.
 *
 * @return flag indicating whether or not to override the time system.
 *
 */
//------------------------------------------------------------------------------
bool CelestialBody::GetOverrideTimeSystem() const
{
   return overrideTime;
}


//------------------------------------------------------------------------------
// Real GetEphemUpdateInterval() const
//------------------------------------------------------------------------------
/**
 * This method returns the ephem update interval for the body.
 *
 * @return ephem update interval for the body.
 *
 */
//------------------------------------------------------------------------------
Real CelestialBody::GetEphemUpdateInterval() const
{
   return ephemUpdateInterval;
}


//------------------------------------------------------------------------------
// StringArray GetValidModelList(Gmat::ModelType m) const
//------------------------------------------------------------------------------
/**
 * This method returns the list of valid models of the requested type for
 * the body.
 *
 * @param <m>  type of model requested
 *
 * @return list of valid models of the requested type for the body.
 *
 */
//------------------------------------------------------------------------------
StringArray CelestialBody::GetValidModelList(Gmat::ModelType m) const
{
   return models[(Integer)m]; 
}


//------------------------------------------------------------------------------
//  const Rvector3& CelestialBody::GetAngularVelocity() 
//------------------------------------------------------------------------------
/**
 * This method returns the angular velocity for the body.
 *
 * @return angular velocity for the body.
 *
 */
//------------------------------------------------------------------------------
const Rvector3& CelestialBody::GetAngularVelocity() 
{
   return angularVelocity; 
}

//------------------------------------------------------------------------------
//  Real GetHourAngle(A1Mjd atTime)
//------------------------------------------------------------------------------
/**
 * This method returns the hour angle for the body, referenced from the
 * Prime Meridian, measured westward
 *
 * @param <atTime> time for which to compute the hour angle
 *
 * @return hour angle for the body, in degrees, from the Prime Meridian
 *
 * @note This is a catch-all when information for the body is not defined.
 */
//------------------------------------------------------------------------------
Real  CelestialBody::GetHourAngle(A1Mjd atTime) 
{
   Rvector cart = GetBodyCartographicCoordinates(atTime);
   hourAngle = cart[2];  
   // reduce to a quantity within one day (GmatTimeConstants::SECS_PER_DAY seconds, 360.0 degrees)
   hourAngle = AngleUtil::PutAngleInDegRange(hourAngle,0.0,360.0);
   return hourAngle;
}

////------------------------------------------------------------------------------
////  const Rmatrix& GetHarmonicCoefficientsSij()
////------------------------------------------------------------------------------
///**
// * This method returns the spherical harmonic coefficients sij for the body.  It
// * will read the potential file if that is requested.
// *
// * @return sij spherical harmonic coefficients for the body.
// *
// *
// * @exception <SolarSystemException> thown if there is an error getting the data.
// */
////------------------------------------------------------------------------------
//const Rmatrix& CelestialBody::GetHarmonicCoefficientsSij()
//{
//   return sij;
//}
//
////------------------------------------------------------------------------------
////  const Rmatrix& GetHarmonicCoefficientsCij()
////------------------------------------------------------------------------------
///**
// * This method returns the spherical harmonic coefficients cij for the body.  It
// * will read the potential file if that is requested.
// *
// * @return cij spherical harmonic coefficients for the body.
// *
// * @exception <SolarSystemException> thown if there is an error getting the data.
// */
////------------------------------------------------------------------------------
//const Rmatrix& CelestialBody::GetHarmonicCoefficientsCij()
//{
//   return cij;
//}

//------------------------------------------------------------------------------
//  const Rmatrix& GetCoefDriftS()
//------------------------------------------------------------------------------
/**
 * This method returns the dSbar coefficient drift matrix for the body.  It
 * will read the potential file if that is requested.
 *
 * @return dSbar  coefficient drift matrix for the body.
 *
 * @exception <SolarSystemException> thown if there is an error getting the data.
 */
//------------------------------------------------------------------------------
//const Rmatrix& CelestialBody::GetCoefDriftS()
//{
//   if ((usePotentialFile == true) & (!potentialFileRead))
//   {
//      bool OK = ReadPotentialFile();
//      if (!OK) throw SolarSystemException("Unable to read potential file");
//   }
//   return dSbar;
//}

//------------------------------------------------------------------------------
//  const Rmatrix& GetCoefDriftC()
//------------------------------------------------------------------------------
/**
 * This method returns the dCbar coefficient drift matrix for the body.  It
 * will read the potential file if that is requested.
 *
 * @return dCbar  coefficient drift matrix for the body.
 *
 * @exception <SolarSystemException> thown if there is an error getting the data.
 */
//------------------------------------------------------------------------------
//const Rmatrix& CelestialBody::GetCoefDriftC()
//{
//   if ((usePotentialFile == true) & (!potentialFileRead))
//   {
//      bool OK = ReadPotentialFile();
//      if (!OK) throw SolarSystemException("Unable to read potential file");
//   }
//   return dCbar;
//}

//------------------------------------------------------------------------------
// Integer GetDegree()
//------------------------------------------------------------------------------
/**
 * This method returns the degree of the gravity coefficients for the body.
 *
 * @return degree  degree of the coefficients for the body.
 *
 * @exception <SolarSystemException> thrown if there is an error getting the data.
 */
//------------------------------------------------------------------------------
Integer CelestialBody::GetDegree()
{
   return degree;
}

//------------------------------------------------------------------------------
// Integer GetOrder()
//------------------------------------------------------------------------------
/**
 * This method returns the order of the gravity coefficients for the body.
 *
 * @return degree  order of the coefficients for the body.
 *
 * @exception <SolarSystemException> thrown if there is an error getting the data.
 */
//------------------------------------------------------------------------------
Integer CelestialBody::GetOrder()
{
   return order;
}

//------------------------------------------------------------------------------
//  std::string GetAtmosphereModelType()
//------------------------------------------------------------------------------
/**
 * This method returns the name (type) of the current atmosphere model for
 * the body.
 *
 * @return the name (type) of the current atmosphere model for the body.
 *
 */
//------------------------------------------------------------------------------
std::string  CelestialBody::GetAtmosphereModelType()
{
   if (!atmModel)
      return "Undefined";

   return atmModel->GetTypeName();  // or should I go through the AtmManager?
}

//------------------------------------------------------------------------------
//  AtmosphereModel* GetAtmosphereModel()
//------------------------------------------------------------------------------
/**
 * This method returns a pointer to the current atmosphere model for the body.
 *
 * @return a pointer to the current atmosphere model for the body.
 *
 */
//------------------------------------------------------------------------------
AtmosphereModel* CelestialBody::GetAtmosphereModel()
{
   return atmModel;
}

//------------------------------------------------------------------------------
//  bool GetDensity(Real *position, Real *density, Real epoch, Integer count)
//------------------------------------------------------------------------------
/**
 * Calculates the atmospheric density at a specified location.
 *
 * Density if the core calculation provided by classes derived from this one.
 * The output array, density, must contain the density at the requested
 * locations, expressed in kg / m^3.
 *
 *  @param position  The input vector of spacecraft states
 *  @param density   The array of output densities
 *  @param epoch     The current TAIJulian epoch
 *  @param count     The number of spacecraft contained in position
 */
//------------------------------------------------------------------------------
bool CelestialBody::GetDensity(Real *position, Real *density, Real epoch,
                               Integer count)
{
   if (!atmModel) return false;
   return atmModel->Density(position,density,epoch,count);
}


//------------------------------------------------------------------------------
// A1Mjd GetTwoBodyEpoch() const
//------------------------------------------------------------------------------
/**
 * Returns the two-body epoch.
 *
 * @return two-body A1Mjd epoch
 */
//------------------------------------------------------------------------------
A1Mjd CelestialBody::GetTwoBodyEpoch() const
{
   return twoBodyEpoch;
}


//------------------------------------------------------------------------------
// Rvector6 GetTwoBodyElements() const
//------------------------------------------------------------------------------
/**
 * Returns the two-body elements.
 *
 * @return two-body initial elements
 */
//------------------------------------------------------------------------------
Rvector6 CelestialBody::GetTwoBodyElements() const
{
   return twoBodyKepler;
}

//------------------------------------------------------------------------------
// Gmat::RotationDataSource GetRotationDataSource() const
//------------------------------------------------------------------------------
/**
 * Returns the rotation data source for the body.
 *
 * @return rotation data source
 */
//------------------------------------------------------------------------------
Gmat::RotationDataSource CelestialBody::GetRotationDataSource() const
{
   return rotationSrc;
}

//------------------------------------------------------------------------------
// StringArray GetRotationDataSourceList() const
//------------------------------------------------------------------------------
/**
 * Returns the list of rotation data source options.
 *
 * @return list of rotation data source options
 */
//------------------------------------------------------------------------------
StringArray CelestialBody::GetRotationDataSourceList() const
{
   StringArray srcList;
   for (unsigned int ii = 0; ii < Gmat::RotationDataSrcCount; ii++)
   {
//      // exclude NOT_APPLICABLE for now
//      if (Gmat::ROTATION_DATA_SOURCE_STRINGS[ii] != "NotApplicable")
         srcList.push_back(Gmat::ROTATION_DATA_SOURCE_STRINGS[ii]);
   }
   
   return srcList;
}


//------------------------------------------------------------------------------
// bool IsUserDefined() const
//------------------------------------------------------------------------------
/**
 * Returns a flag indicating whether or not the body is user-defined
 *
 * @return flag indicating whether or not the body is user-defined
 */
//------------------------------------------------------------------------------
bool CelestialBody::IsUserDefined() const
{
   return userDefined;
}


//------------------------------------------------------------------------------
// StringArray GetEphemSourceList() const
//------------------------------------------------------------------------------
/**
 * Returns the list of epehmeris source options.
 *
 * @return list of ephemeris source options
 */
//------------------------------------------------------------------------------
StringArray CelestialBody::GetEphemSourceList() const
{
   StringArray srcList;
   for (int jj = 0; jj < Gmat::PosVelSourceCount; jj++)
   {
      std::string src = Gmat::POS_VEL_SOURCE_STRINGS[jj];
         
      if (userDefined)
      {
      #ifdef __USE_SPICE__
         if (!(GmatStringUtil::StartsWith(src, "DE")))
            srcList.push_back(Gmat::POS_VEL_SOURCE_STRINGS[jj]);  
      #else
            if ((!(GmatStringUtil::StartsWith(src, "DE"))) &&
                  (src.find("SPICE") == std::string::npos))
               srcList.push_back(Gmat::POS_VEL_SOURCE_STRINGS[jj]);  
      #endif
      }
      else if (!allowSpice)
      {
         if (src.find("SPICE") == std::string::npos)
            srcList.push_back(Gmat::POS_VEL_SOURCE_STRINGS[jj]);
      }
      else
      {
      #ifdef __USE_SPICE__
         srcList.push_back(Gmat::POS_VEL_SOURCE_STRINGS[jj]);
      #else
      if (src.find("SPICE") == std::string::npos)
         srcList.push_back(Gmat::POS_VEL_SOURCE_STRINGS[jj]);
      #endif
      }
   }
   return srcList;
}

//------------------------------------------------------------------------------
// Rvector6 GetOrientationParameters() const
//------------------------------------------------------------------------------
/**
 * Returns the array of orientation parameters for the body, in this order:
 * SpinAxisRAConstant
 * SpinAxisRARate
 * SpinAxisDECConstant
 * SpinAxisDECRate
 * RotationConstant
 * RotationRate
 *
 * @return array of orientation parameters
 */
//------------------------------------------------------------------------------
Rvector6 CelestialBody::GetOrientationParameters() const
{
   return orientation;
}


//------------------------------------------------------------------------------
//  bool SetBodyType(Gmat::BodyType bType)
//------------------------------------------------------------------------------
/**
 * This method sets the body type for the body.
 *
 * @param <bType> body type for the body.
 *
 * @return flag indicating success of the method.
 *
 */
//------------------------------------------------------------------------------
bool CelestialBody::SetBodyType(Gmat::BodyType bType)
{
   bodyType            = bType;
   return true; // will need to change default parameters here too, if they
                // are set to values that make no sense for this type of body?
}

//------------------------------------------------------------------------------
//  bool SetCentralBody(const std::string &cBody)
//------------------------------------------------------------------------------
/**
 * This method sets the central body for the body.
 *
 * @param <cBody> central body name for the body.
 *
 * @return flag indicating success of the method.
 *
 */
//------------------------------------------------------------------------------
bool CelestialBody::SetCentralBody(const std::string &cBody)
{
   theCentralBodyName = cBody;
   return true;
}

//------------------------------------------------------------------------------
//  bool SetGravitationalConstant(Real newMu)
//------------------------------------------------------------------------------
/**
 * This method sets the gravitational constant for the body.
 *
 * @param <newMu> gravitational constant (km^3/s^2) for the body.
 *
 * @return flag indicating success of the method.
 *
 * @exception <SolarSystemException> thrown if value is out of range
 *
 */
//------------------------------------------------------------------------------
bool CelestialBody::SetGravitationalConstant(Real newMu)
{
   #ifdef DEBUG_CB_SET
      MessageInterface::ShowMessage("In CB::SetGravitationalConstant, newMu = %.14f\n",
            newMu);
   #endif
   if (newMu <= 0.0)
   {
      SolarSystemException sse;
      sse.SetDetails(errorMessageFormat.c_str(),
                     GmatStringUtil::ToString(newMu, GetDataPrecision()).c_str(),
                     "Mu", "Real Number > 0.0");
      throw sse;
   }
   
   mu                         = newMu;
   mass                       = mu / GmatPhysicalConstants::UNIVERSAL_GRAVITATIONAL_CONSTANT;
   return true;
}

//------------------------------------------------------------------------------
//  bool SetEquatorialRadius(Real newEqRadius)
//------------------------------------------------------------------------------
/**
 * This method sets the equatorial radius for the body.
 *
 * @param <newEqRadius> equatorial radius (km) for the body.
 *
 * @exception <SolarSystemException> thrown if value is out of range
 *
 * @return flag indicating success of the method.
 *
 */
//------------------------------------------------------------------------------
bool CelestialBody::SetEquatorialRadius(Real newEqRadius)
{
   #ifdef DEBUG_CB_SET
      MessageInterface::ShowMessage("In CB::SetEquatorialRadius, newEqRadius = %.14f\n",
            newEqRadius);
   #endif
   if (newEqRadius <= 0.0)
   {
      SolarSystemException sse;
      sse.SetDetails(errorMessageFormat.c_str(),
                     GmatStringUtil::ToString(newEqRadius, GetDataPrecision()).c_str(),
                     "Equatorial Radius", "Real Number > 0.0");
      throw sse;
   }
   
   equatorialRadius                 = newEqRadius;
   polarRadius                      = (1.0 - flattening) * equatorialRadius;
   return true;
}

//------------------------------------------------------------------------------
//  bool SetFlattening(Real flat)
//------------------------------------------------------------------------------
/**
 * This method sets the flattening value for the body.
 *
 * @param <flat> flattening value for the body.
 *
 * @return flag indicating success of the method.
 *
 */
//------------------------------------------------------------------------------
bool CelestialBody::SetFlattening(Real flat) 
{
   #ifdef DEBUG_CB_SET
      MessageInterface::ShowMessage("In CB::SetFlattening, flat = %.14f\n",
         flat);
   #endif
   if (flat < 0.0)
   {
      SolarSystemException sse;
      sse.SetDetails(errorMessageFormat.c_str(),
                     GmatStringUtil::ToString(flat, GetDataPrecision()).c_str(),
                     "Flattening", "Real Number >= 0.0");
      throw sse;
   }
   flattening                          = flat;
   polarRadius                         = (1.0 - flattening) * equatorialRadius;
   return true;
}


//------------------------------------------------------------------------------
//  bool SetSource(Gmat::PosVelSource pvSrc)
//------------------------------------------------------------------------------
/**
 * This method sets the position/velocity source for the body.
 *
 * @param <pcSrc> position/velocity source for the body.
 *
 * @return flag indicating success of the method.
 *
 */
//------------------------------------------------------------------------------
bool CelestialBody::SetSource(Gmat::PosVelSource pvSrc)
{
   #ifdef DEBUG_EPHEM_SOURCE
   MessageInterface::ShowMessage
      ("CelestialBody::SetSource() <%p> %s, Setting source to %d(%s)\n", this,
       GetName().c_str(), pvSrc, Gmat::POS_VEL_SOURCE_STRINGS[pvSrc].c_str());
   #endif
   
   if (pvSrc == posVelSrc) return true;

   if (pvSrc == Gmat::DE405)
   {
      if (userDefined)
      {
         std::string errmsg = "DE405 file option not available for user-defined body ";
         errmsg += instanceName + "\n";
         throw SolarSystemException(errmsg);
      }
   }
   if (pvSrc == Gmat::DE421)
   {
      if (userDefined)
      {
         std::string errmsg = "DE421 file option not available for user-defined body ";
         errmsg += instanceName + "\n";
         throw SolarSystemException(errmsg);
      }
   }
   if (pvSrc == Gmat::DE424)
   {
      if (userDefined)
      {
         std::string errmsg = "DE424 file option not available for user-defined body ";
         errmsg += instanceName + "\n";
         throw SolarSystemException(errmsg);
      }
   }
//   if (pvSrc == Gmat::DE430)
//   {
//      if (userDefined)
//      {
//         std::string errmsg = "DE430 file option not available for user-defined body ";
//         errmsg += instanceName + "\n";
//         throw SolarSystemException(errmsg);
//      }
//   }
   if (pvSrc == Gmat::SPICE)
   {
      if ((!userDefined) && (!allowSpice))
      {
         std::string errmsg = "SPICE file option not available for default body ";
         errmsg += instanceName + "\n";
         throw SolarSystemException(errmsg);
      }
      spiceSetupDone = false;
   }
   posVelSrc           = pvSrc;
   return true;
}

//------------------------------------------------------------------------------
//  bool SetSourceFile(PlanetaryEphem *src)
//------------------------------------------------------------------------------
/**
 * This method sets the position/velocity source file for the body.
 *
 * @param <src> position/velocity source file for the body.
 *
 * @return flag indicating success of the method.
 *
 */
//------------------------------------------------------------------------------
bool CelestialBody::SetSourceFile(PlanetaryEphem *src)
{
   // should I delete the old one here???
   theSourceFile  = src;
   sourceFilename = theSourceFile->GetName();
   bodyNumber     = theSourceFile->GetBodyID(instanceName);
   #ifdef DEBUG_EPHEM_SOURCE
      MessageInterface::ShowMessage
         ("CelestialBody::SetSourceFile() <%p> %s, Setting source file to %p\n",
          this, GetName().c_str(), src);
      MessageInterface::ShowMessage("    and bodyId from source is %d\n", bodyNumber);
   #endif
   return true;
}

//------------------------------------------------------------------------------
//  bool SetAllowSpice(const bool allow)
//------------------------------------------------------------------------------
/**
 * This method sets the flag indicating whether or not to allow the use of
 * SPICE (SPK) as an ephemeris source for this body.
 *
 * @return flag indicating success of the method.
 */
//------------------------------------------------------------------------------
bool CelestialBody::SetAllowSpice(const bool allow)
{
   #ifdef DEBUG_CB_SPICE
      if (userDefined)
         MessageInterface::ShowMessage("Cannot set allowSpice flag for body %s - it is user-defined.\n",
               instanceName.c_str());
      else
         MessageInterface::ShowMessage("Setting allowSpice flag for body %s to %s\n",
               instanceName.c_str(), (allow? "true" : "false"));
   #endif
   if (!userDefined) allowSpice = allow; // set for default bodies only
   if (allowSpice)   spiceSetupDone = false;
   return true;
}

//------------------------------------------------------------------------------
//  bool SetUsePotentialFile(bool useIt)
//------------------------------------------------------------------------------
/**
 * This method sets the flag indicating whether or not to get the mu, radius,
 * and harmonic coefficients from the potential file.
 *
 * @param <useIt> use the potential file?.
 *
 * @return flag indicating success of the method.
 *
 */
//------------------------------------------------------------------------------
bool CelestialBody::SetUsePotentialFile(bool useIt)
{
   #ifdef DEBUG_CB_SET
   MessageInterface::ShowMessage
      ("CelestialBody::SetUsePotentialFile() this=<%p> '%s' entered, useIt=%d\n",
       this, GetName().c_str(), useIt);
   #endif
   
   if ((usePotentialFile == false) && (useIt == true))
   {
      potentialFileRead = false;
      isFirstTimeMu = true;
      isFirstTimeRadius = true;
   }
   else if ((usePotentialFile == true) && (useIt == false))
   {
      mu               = default_mu;
      equatorialRadius = default_equatorialRadius;
      // recompute polar radius
      polarRadius = (1.0 - flattening) * equatorialRadius;
      // recompute mass
      mass = mu / GmatPhysicalConstants::UNIVERSAL_GRAVITATIONAL_CONSTANT;
      isFirstTimeMu = true;
      isFirstTimeRadius = true;
   }
   
   usePotentialFile    = useIt;
   return true;
}

//------------------------------------------------------------------------------
//  bool SetOverrideTimeSystem(bool overrideIt)
//------------------------------------------------------------------------------
/**
 * This method sets the time system override flag for the body 
 * (i.e. if true, TDB times will be overridden with TT times).
 *
 * @param <overrideIt> override TDB time with TT?.
 *
 * @return flag indicating success of the method.
 *
 */
//------------------------------------------------------------------------------
bool CelestialBody::SetOverrideTimeSystem(bool overrideIt)
{
   #ifdef DEBUG_CB_SET
   MessageInterface::ShowMessage
      ("CelestialBody::SetOverrideTimeSystem() <%p> '%s' entered, overrideIt=%d\n",
       this, GetName().c_str(), overrideIt);
   #endif
   overrideTime        = overrideIt;
   return true;
}


//------------------------------------------------------------------------------
// bool SetEphemUpdateInterval(Real intvl)
//------------------------------------------------------------------------------
/**
 * This method sets the ephemeris update interval (seconds)
 *
 * @param <intvl> ephemeris update interval
 *
 * @return flag indicating success of the method.
 *
 */
//------------------------------------------------------------------------------
bool CelestialBody::SetEphemUpdateInterval(Real intvl)
{
   if (intvl < 0.0)
   {
      SolarSystemException sse;
      sse.SetDetails(errorMessageFormat.c_str(),
                     GmatStringUtil::ToString(intvl, GetDataPrecision()).c_str(),
                     "Ephemeris Update Interval", "Real Number >= 0.0");
      throw sse;
   }
   ephemUpdateInterval = intvl;
   return true;
}


//------------------------------------------------------------------------------
// bool AddValidModelName(Gmat::ModelType m, const std::string &newModel)
//------------------------------------------------------------------------------
/**
 * Adds the input model name of the input model type to the list of valid
 * models for the body.
 *
 * @param <m>        model type
 * @param <newModel> model name
 *
 * @return flag indicating success of the method.
 *
 */
//------------------------------------------------------------------------------
bool CelestialBody::AddValidModelName(Gmat::ModelType m, 
                                      const std::string &newModel)
{
   // first, make sure it is not already on the list
   if (find(models[(Integer)m].begin(), models[(Integer)m].end(),
            newModel) == models[(Integer)m].end())
      models[(Integer)m].push_back(newModel);
   // @todo modify it so it adds it before an 'Other' in the list
   
   return true;
   
}


//------------------------------------------------------------------------------
// bool RemoveValidModelName(Gmat::ModelType m, const std::string &modelName)
//------------------------------------------------------------------------------
/**
 * Removes the input model name of the input model type from the list of valid
 * models for the body.
 *
 * @param <m>        model type
 * @param <newModel> model name
 *
 * @return flag indicating success of the method.
 *
 */
//------------------------------------------------------------------------------
bool CelestialBody::RemoveValidModelName(Gmat::ModelType m, 
                                         const std::string &modelName)
{
   // remove it, if it's on the list
   // bool found = false;
   for (StringArray::iterator i = models[(Integer)m].begin();
        i != models[(Integer)m].end(); ++i)
   {
      if (*i == modelName)
      {
         models[(Integer)m].erase(i);
         // found = true;
         break;
      }
   }
   return true;  // found?
}
   
//------------------------------------------------------------------------------
// bool SetValidModelList(Gmat::ModelType m, const StringArray &toList)
//------------------------------------------------------------------------------
/**
 * Sets the valid model list for the input type for the body to the input list.
 *
 * @param <m>        model type
 * @param <toList>   model list
 *
 * @return flag indicating success of the method.
 *
 */
//------------------------------------------------------------------------------
bool CelestialBody::SetValidModelList(Gmat::ModelType m, const StringArray &toList)
{
   models[(Integer)m].clear();
   for (unsigned int ii = 0; ii < toList.size(); ii++)
      models[(Integer)m].push_back(toList.at(ii));
      
   return true;     
}

//------------------------------------------------------------------------------
// bool SetOrder(Integer toOrder)
//------------------------------------------------------------------------------
/**
 * Sets the order.
 *
 * @param toOrder>  order value
 *
 * @return flag indicating success of the method.
 *
 */
//------------------------------------------------------------------------------
bool CelestialBody::SetOrder(Integer toOrder)
{
   order               = toOrder;
   return true;
}

//------------------------------------------------------------------------------
// bool SetDegree(Integer toOrder)
//------------------------------------------------------------------------------
/**
 * Sets the degree.
 *
 * @param toOrder>  degree value
 *
 * @return flag indicating success of the method.
 *
 */
//------------------------------------------------------------------------------
bool CelestialBody::SetDegree(Integer toDegree)
{
   degree              = toDegree;
   return true;
}

//bool CelestialBody::SetHarmonicCoefficientsSij(const Rmatrix &coeffSij)
//{
//   sij                 = coeffSij;
//   return true;
//}
//
//bool CelestialBody::SetHarmonicCoefficientsCij(const Rmatrix &coeffCij)
//{
//   cij                 = coeffCij;
//   return true;
//}



//------------------------------------------------------------------------------
//  bool SetAtmosphereModelType(std::string toAtmModelType)
//------------------------------------------------------------------------------
/**
 * This method sets the atmosphere model type for the body.
 *
 * @param <toAtmModel> name (type) of the atmosphere model to use.
 *
 * @return flag indicating success of the method.
 *
 * @note This method no longer sets the actual atmosphere model pointer.  A call
 *       to SetAtmosphereModel must be executed for that to happen.
 *
 */
//------------------------------------------------------------------------------
bool CelestialBody::SetAtmosphereModelType(std::string toAtmModelType)
{
   atmModelType        = toAtmModelType;
   return true;
}


//------------------------------------------------------------------------------
//  bool SetAtmosphereModel(AtmosphereModel *toAtmModel)
//------------------------------------------------------------------------------
/**
 * This method sets the atmosphere model pointer for the body.
 *
 * @param <toAtmModel> pointer to the atmosphere model to use.
 *
 * @return flag indicating success of the method.
 *
 */
//------------------------------------------------------------------------------
bool CelestialBody::SetAtmosphereModel(AtmosphereModel *toAtmModel)
{
   if (atmModel)
   {
      #ifdef DEBUG_MEMORY
      MemoryTracker::Instance()->Remove
         (atmModel, atmModel->GetName(), "CelestialBody::SetAtmosphereModel()",
          "deleting atmModel");
      #endif
      delete atmModel;
   }
   atmModel            = toAtmModel;
   return true;
}


//------------------------------------------------------------------------------
//  bool SetPotentialFilename(const std::string &fn)
//------------------------------------------------------------------------------
/**
 * This method sets potential file name for this HarmonicField object.
 *
 * @param <fn> full path name of the potential file name to use.
 *
 * @return flag indicating success of the operation.
 */
//------------------------------------------------------------------------------
bool CelestialBody::SetPotentialFilename(const std::string &fn)
{
   if (potentialFileName != fn)
   {
      potentialFileRead = false;
      isFirstTimeMu = true;
      isFirstTimeRadius = true;
   }
   
   potentialFileName   = fn;
   return true;
}


//------------------------------------------------------------------------------
// bool SetTwoBodyEpoch(const A1Mjd &toTime)
//------------------------------------------------------------------------------
/**
 * This method sets two-body epoch .
 *
 * @param <toTime> the two-body epoch
 *
 * @return flag indicating success of the operation.
 */
//------------------------------------------------------------------------------
bool CelestialBody::SetTwoBodyEpoch(const A1Mjd &toTime)
{
   #ifdef DEBUG_TWO_BODY
      MessageInterface::ShowMessage(
         "In CB::SetTwoBodyEpoch, setting epoch to %.12f\n", toTime.Get());
//      "In CB::SetAnalyticEpoch, setting epoch to %.12f\n", toTime.Get());
   #endif
   twoBodyEpoch        = toTime;
   newTwoBody          = true;
   return true;
}


//------------------------------------------------------------------------------
// bool SetSMA(Real value)
//------------------------------------------------------------------------------
/*
 * Sets SemimajorAxis of twoBody model state.
 *
 * @param  value  value of semimajor axis
 *
 * @exception <SolarSystemException> thrown if new value is out of range
 *
 */
//------------------------------------------------------------------------------
bool CelestialBody::SetSMA(Real value)
{
   if (value == 0.0)
   {
      SolarSystemException sse;
      sse.SetDetails(errorMessageFormat.c_str(),
                     GmatStringUtil::ToString(value, GetDataPrecision()).c_str(),
                     PARAMETER_TEXT[TWO_BODY_SMA - SpacePointParamCount].c_str(),
                     "Real Number != 0.0");
      throw sse;
   }
   
   twoBodyKepler[0]    = value;
   return true;
}


//------------------------------------------------------------------------------
// bool SetECC(Real value)
//------------------------------------------------------------------------------
/*
 * Sets Eccentricity of twoBody model state.
 *
 * @param  value  eccentricity value
 *
 * @exception <SolarSystemException> thrown if value is out of range
 *
 */
//------------------------------------------------------------------------------
bool CelestialBody::SetECC(Real value)
{
   if (value < 0.0)
   {
      SolarSystemException sse;
      sse.SetDetails(errorMessageFormat.c_str(),
                     GmatStringUtil::ToString(value, GetDataPrecision()).c_str(),
                     PARAMETER_TEXT[TWO_BODY_ECC - SpacePointParamCount].c_str(),
                     "Real Number >= 0.0");
      throw sse;
   }
   
   twoBodyKepler[1] = value;
   return true;
}


//------------------------------------------------------------------------------
// bool SetTwoBodyElements(const Rvector6 &kepl)
//------------------------------------------------------------------------------
/*
 * Sets the twoBody keplerian state for the body.
 *
 * @param  <kepl>   the keplerian state of the body
 *
 * @exception <SolarSystemException> thrown if value is out of range
 *
 */
//------------------------------------------------------------------------------
bool CelestialBody::SetTwoBodyElements(const Rvector6 &kepl)
{
   #ifdef DEBUG_TWO_BODY
      MessageInterface::ShowMessage(
         "In CB::SetTwoBodyElements, setting elements to\n%.12f %.12f %.12f %.12f"
         " %.12f %.12f\n", kepl[0],kepl[1],kepl[2],kepl[3],kepl[4],kepl[5]);
//      "In CB::SetAnalyticElements, setting elements to\n%.12f %.12f %.12f %.12f"
//      " %.12f %.12f\n", kepl[0],kepl[1],kepl[2],kepl[3],kepl[4],kepl[5]);
   #endif
      
   SetSMA(kepl[0]);
   SetECC(kepl[1]);
   
   /// @todo  Add validation as in StateConversionUtilities
   
   twoBodyKepler       = kepl;
   newTwoBody          = true;
   return true;
}


//------------------------------------------------------------------------------
// bool SetRotationDataSource(Gmat::RotationDataSource src)
//------------------------------------------------------------------------------
/*
 * Sets the rotation data source for the body.
 *
 * @param  <src>   the rotation data source for the body
 *
 * @return  success flag
 *
 */
//------------------------------------------------------------------------------
bool CelestialBody::SetRotationDataSource(Gmat::RotationDataSource src)
{
   rotationSrc         = src;
   return true;
}

//------------------------------------------------------------------------------
// bool SetUserDefined(bool userDefinedBody)
//------------------------------------------------------------------------------
/*
 * Sets the flag indicating whether or not this body id a user-defined body.
 *
 * @param  <userDefinedBody>   is this body a user-defined body?
 *
 * @result success flag
 *
 */
//------------------------------------------------------------------------------
bool CelestialBody::SetUserDefined(bool userDefinedBody)
{
   // make sure source makes sense
   if ((userDefinedBody) && ((posVelSrc == Gmat::DE405) ||(posVelSrc == Gmat::DE421) ||
	    (posVelSrc == Gmat::DE424)))   //  || (posVelSrc == Gmat::DE430)))
	{
      posVelSrc = Gmat::SPICE;
//      posVelSrc = Gmat::TWO_BODY_PROPAGATION; // 2012.01.24 - wcs - disallowed for now
	}
   else if ((!userDefinedBody) && (!allowSpice) && (posVelSrc == Gmat::SPICE))
   {
	   int index;
	   for (index=0; index < Gmat::PosVelSourceCount; ++index)
	   {
		   if (Gmat::POS_VEL_SOURCE_STRINGS[index] == default_posVelSrc)
			   break;
	   }
	   if (index == Gmat::PosVelSourceCount)
		   posVelSrc = Gmat::DE405;
	   else
		   posVelSrc = (Gmat::PosVelSource)index;
   }

   userDefined         = userDefinedBody;
   if (userDefined) allowSpice = true;
   #ifdef DEBUG_CB_USER_DEFINED
      MessageInterface::ShowMessage(
            "In CB::SetUserDefined, body %s has been set to userDefined = %s and allowSpice = %s\n",
            instanceName.c_str(), (userDefined? "true" : "false"),
            (allowSpice? "true" : "false"));
   #endif
   // we DO want to show the all parameters and the Create line when writing the user-defined 
   // Celestial Body data out to a script
   cloaking = false;

   return true;
}


//------------------------------------------------------------------------------
// std::string Get3dViewModelFile()
//------------------------------------------------------------------------------
std::string CelestialBody::Get3dViewModelFile()
{
   return view3dModelFileName;
}


//------------------------------------------------------------------------------
// std::string Get3dViewModelFileFullPath()
//------------------------------------------------------------------------------
std::string CelestialBody::Get3dViewModelFileFullPath()
{
   return view3dModelFileFullPath;
}


//------------------------------------------------------------------------------
// int Get3dViewModelId()
//------------------------------------------------------------------------------
int CelestialBody::Get3dViewModelId()
{
   return view3dModelId;
}


//------------------------------------------------------------------------------
// void Set3dViewModelId(int id)
//------------------------------------------------------------------------------
void CelestialBody::Set3dViewModelId(int id)
{
   view3dModelId = id;
}


//------------------------------------------------------------------------------
// const Rvector6 GetMJ2000State(const A1Mjd &atTime)
//------------------------------------------------------------------------------
/*
 * Returns the MJ2000Eq state for the body.
 *
 * @param  <atTime>   time at which state is requested
 *
 * @result MJ2000eq state for the body at the requested time
 *
 */
//------------------------------------------------------------------------------
const Rvector6 CelestialBody::GetMJ2000State(const A1Mjd &atTime)
{
   #ifdef DEBUG_CB_GET_MJ2000_STATE
   MessageInterface::ShowMessage("In GetMJ2000State, body is %s, time is %12.10f\n",
         instanceName.c_str(), atTime.Get());
   MessageInterface::ShowMessage("In GetMJ2000State, j2000Body is %s\n",
         (j2000Body->GetName()).c_str());
   #endif
   if (j2000Body == NULL)
      throw SolarSystemException
         ("CelestialBody::GetMJ2000State() j2000Body is NULL for " + instanceName);
   
   // If j2000Body is this body, return the zero state vector
   if(j2000Body->GetName() == instanceName) 
   {
      state.Set(0.0,0.0,0.0,0.0,0.0,0.0);
      stateTime     = atTime;
      lastEphemTime = atTime;
      lastState     = state;
      return state;
   }
   
   Rvector6         stateEphem    = GetState(atTime);
   Rvector6         j2kEphemState;
   Gmat::ObjectType ot            = j2000Body->GetType();
   if (ot == Gmat::CELESTIAL_BODY)
   {
      j2kEphemState = ((CelestialBody*)j2000Body)->GetState(atTime);
   }
   else if (ot == Gmat::CALCULATED_POINT)
   {
      // @todo fill in with calculated point stuff when it's done
      //j2kEphemState = ((CalculatedPoint*)j2000Body)->GetState(atTime);
   }
   else
   {
      throw SolarSystemException("j2000Body is of incorrect type.");
   }
   
   #ifdef DEBUG_GET_STATE
   MessageInterface::ShowMessage
      ("CelestialBody::GetMJ2000State() stateEphem =\n   %s\n",
       stateEphem.ToString().c_str());
   MessageInterface::ShowMessage
      ("CelestialBody::GetMJ2000State() j2kEphemState =\n   %s\n",
       j2kEphemState.ToString().c_str());
   #endif
   #ifdef DEBUG_CB_GET_MJ2000_STATE
      Rvector6 theState = stateEphem - j2kEphemState;
      Real ttTime    = TimeConverterUtil::Convert(atTime.Get(), TimeConverterUtil::A1MJD,
                       TimeConverterUtil::TTMJD, GmatTimeConstants::JD_JAN_5_1941);
      Real tdbTime   = TimeConverterUtil::Convert(atTime.Get(), TimeConverterUtil::A1MJD,
                       TimeConverterUtil::TDBMJD, GmatTimeConstants::JD_JAN_5_1941);
      MessageInterface::ShowMessage(
            "Body: %s   TT(TDB) Time: %12.10f (%12.10f)   state:  %12.10f  %12.10f  %12.10f  %12.10f  %12.10f  %12.10f\n",
            instanceName.c_str(), ttTime, tdbTime,
            theState[0], theState[1], theState[2], theState[3], theState[4], theState[5]);
   #endif

   // we need to store the last computed j2k state
   // the lastEphemTime will have been set when we called GetState

   // SPICE does the subtraction itself
   if (posVelSrc == Gmat::SPICE)
   {
      j2kState = stateEphem;
//      return stateEphem;
   }
   else // DE or TwoBodyPropagation
   {
      j2kState = stateEphem - j2kEphemState;
//      return (stateEphem - j2kEphemState);
   }
   return j2kState;
}


//------------------------------------------------------------------------------
// const Rvector3 GetMJ2000Position(const A1Mjd &atTime)
//------------------------------------------------------------------------------
/*
 * Returns the MJ2000Eq position for the body.
 *
 * @param  <atTime>   time at which position is requested
 *
 * @result MJ2000eq position for the body at the requested time
 *
 */
//------------------------------------------------------------------------------
const Rvector3 CelestialBody::GetMJ2000Position(const A1Mjd &atTime)
{
   Rvector6 tmp = GetMJ2000State(atTime);
   return (tmp.GetR());
}


//------------------------------------------------------------------------------
// const Rvector3 GetMJ2000Velocity(const A1Mjd &atTime)
//------------------------------------------------------------------------------
/*
 * Returns the MJ2000Eq velocity for the body.
 *
 * @param  <atTime>   time at which velocity is requested
 *
 * @result MJ2000eq velocity for the body at the requested time
 *
 */
//------------------------------------------------------------------------------
const Rvector3 CelestialBody::GetMJ2000Velocity(const A1Mjd &atTime)
{
   Rvector6 tmp = GetMJ2000State(atTime);
   return (tmp.GetV());
}

//------------------------------------------------------------------------------
// bool SetOrientationParameters(const Rvector6 &orient) const
//------------------------------------------------------------------------------
/**
 * Sets the array of orientation parameters for the body.  The values must be
 * in this order:
 * SpinAxisRAConstant
 * SpinAxisRARate
 * SpinAxisDECConstant
 * SpinAxisDECRate
 * RotationConstant
 * RotationRate
 *
 * @return   success flag
 */
//------------------------------------------------------------------------------
bool CelestialBody::SetOrientationParameters(const Rvector6 &orient)
{
   orientation         = orient;
   return true;
}


//------------------------------------------------------------------------------
//  Rvector GetBodyCartographicCoordinates(const A1Mjd &forTime) const
//------------------------------------------------------------------------------
/**
 * This method returns the cartographic coordinates for the body.
 *
 * @return vector containing alpha, delta, W, Wdot, where:
 *         alpha is the right ascension of the north pole of rotation
 *         delta is the declination of the north pole of rotation
 *         W specifies the ephemeris position of the prime meridian
 *         Wdot specifies the time derivative of W
 *
 * @note currently only implemented for the Star, Planets, and Major Moons of
 *       our Solar System.
 * @note currently, this method only handles the IAU_SIMPLIFIED option; others 
 *       are handled in the child classes, e.g. Luna in Moon class, etc.
 *
 */
//------------------------------------------------------------------------------
Rvector CelestialBody::GetBodyCartographicCoordinates(const A1Mjd &forTime) const
{
   if (rotationSrc == Gmat::IAU_SIMPLIFIED)
   {
      bool orientationDefined = false;
      for (unsigned int ii = 0; ii < 6; ii++)
         if (orientation[ii] != 0.0)  
         {
            orientationDefined = true;
            break;
         }
      if (!orientationDefined)
         throw SolarSystemException(
            "Orientation parameters not yet set for body " + instanceName);
      Real alpha = 0;
      Real delta = 0;
      Real W     = 0;
      Real Wdot  = 0.0; 
      #ifdef DEBUG_CB_CARTOGRAPHIC
         MessageInterface::ShowMessage(
            "About to call GetJulianDaysFromTDBEpoch for body %s at time %le and orientation epoch %le\n",
            instanceName.c_str(), forTime.Get(), orientationEpoch.Get());
      #endif

      Real d = GetJulianDaysFromTDBEpoch(forTime); // interval in Julian days
      if (userDefined)
         d -= GetJulianDaysFromTDBEpoch(orientationEpoch);

      Real T = d / GmatTimeConstants::DAYS_PER_JULIAN_CENTURY; // interval in Julian centuries
      
      alpha = orientation[0]  + orientation[1] * T;
      delta = orientation[2]  + orientation[3] * T;
      W     = orientation[4]  + orientation[5] * d;
      Wdot  = orientation[5]  * CelestialBody::dDot;
      #ifdef DEBUG_CB_CARTOGRAPHIC
//      if ((forTime.Get() > 23158.005) && (forTime.Get() < 23158.006))
//      {
         MessageInterface::ShowMessage("returning cartographic coordinates for body %s at time %12.10f:\n",
                                       instanceName.c_str(), forTime.Get());
         MessageInterface::ShowMessage("   alpha = %12.10f    delta = %12.10f    W = %12.10f    Wdot = %12.10f    d = %12.10f    T = %12.10f  dDot = %12.10f\n",
                                       alpha, delta, W, Wdot, d, T, CelestialBody::dDot);
         MessageInterface::ShowMessage("   orientation array = %s\n", orientation.ToString().c_str());
//      }
      #endif
      return Rvector(4, alpha, delta, W, Wdot);
   }
   else
   {
      std::string errmsg = "Cannot compute cartographic coordinates for body ";
      errmsg += instanceName + "\n";
      throw SolarSystemException(errmsg);
   }
}


//------------------------------------------------------------------------------
//  bool SetPhysicalParameters(Real bodyMass, Real bodyEqRad,
//                             Real bodyPolarRad, Real bodyMu,
//                             Integer coeffSize, Rmatrix& bodySij,
//                             Rmatrix& bodyCij);
//------------------------------------------------------------------------------
/**
 * This method sets the physical parameters for the body.
 *
 * @param <bodyMass>     mass (kg) of the body.
 * @param <bodyMEqRad>   equatorial radius (km) of the body.
 * @param <bodyPolarRad> polar radius (km) of the body.
 * @param <bodyMu>       gravitational constant (km^3/s^2) of the body.
 * @param <coeffSize>    size of Sij and Cij for the body.
 * @param <bodySij>      coefficients Sij for the body (coeffSize x coeffSize).
 * @param <bodyCij>      coefficients Cij for the body (coeffSize x coeffSize).
 *
 * @return flag indicating success of the method.
 *
 * @exception <SolarSystemException> thrown if there is an error in the
 *                                   input data.
 */
//------------------------------------------------------------------------------
//bool CelestialBody::SetPhysicalParameters(Real bodyMass, Real bodyEqRad,
//                                          Real bodyPolarRad, Real bodyMu,
//                                          Integer coeffSize, Rmatrix &bodySij,
//                                          Rmatrix &bodyCij)
//{
//   // add data checks later <-
//   mass             = bodyMass;
//   equatorialRadius = bodyEqRad;
//   polarRadius      = bodyPolarRad;
//   mu               = bodyMu;
//   coefficientSize  = coeffSize;
//   Integer r,c;
//   try
//   {
//      bodySij.GetSize(r,c);
//      sij = bodySij;
//   }
//   catch (TableTemplateExceptions::IllegalSize& tte)
//   {
//      throw SolarSystemException("Sij input to body has no dimensions.");
//   }
//   try
//   {
//      bodyCij.GetSize(r,c);
//      cij = bodyCij;
//   }
//   catch (TableTemplateExceptions::IllegalSize& tte)
//   {
//      throw SolarSystemException("Cij input to body has no dimensions.");
//   }
//   return true;
//}


//------------------------------------------------------------------------------
//  std::string  GetParameterText(const Integer id) const
//------------------------------------------------------------------------------
/**
 * This method returns the parameter text, given the input parameter ID.
 *
 * @param <id> Id for the requested parameter text.
 *
 * @return parameter text for the requested parameter.
 *
 */
//------------------------------------------------------------------------------
std::string CelestialBody::GetParameterText(const Integer id) const
{
   if (id >= SpacePointParamCount && id < CelestialBodyParamCount)
      return PARAMETER_TEXT[id - SpacePointParamCount];

   // Override the PCK kernel names
   if (id == ATTITUDE_SPICE_KERNEL_NAME)  return "PlanetarySpiceKernelName";

   return SpacePoint::GetParameterText(id);
}

//------------------------------------------------------------------------------
//  Integer  GetParameterID(const std::string &str) const
//------------------------------------------------------------------------------
/**
 * This method returns the parameter ID, given the input parameter string.
 *
 * @param <str> string for the requested parameter.
 *
 * @return ID for the requested parameter.
 *
 */
//------------------------------------------------------------------------------
Integer CelestialBody::GetParameterID(const std::string &str) const
{
   #ifdef DEBUG_CB_GET_STRING_ARRAY
      MessageInterface::ShowMessage("In CB::GetParameterID, str = %s\n",
            str.c_str());
   #endif
   for (Integer i = SpacePointParamCount; i < CelestialBodyParamCount; i++)
   {
      if (str == PARAMETER_TEXT[i - SpacePointParamCount])
         return i;
   }
   if (str == "PlanetarySpiceKernelName")
      return ATTITUDE_SPICE_KERNEL_NAME;
   else if (str == "AttitudeSpiceKernelName")
   {
      std::string errmsg = "\"AttitudeSpiceKernelName\" not a valid field for a Celestial Body.  ";
      errmsg += "Please use \"PlanetarySpiceKernelName\".\n";
      throw SolarSystemException(errmsg);
   }
   else
      return SpacePoint::GetParameterID(str);
}

//------------------------------------------------------------------------------
//  Gmat::ParameterType  GetParameterType(const Integer id) const
//------------------------------------------------------------------------------
/**
 * This method returns the parameter type, given the input parameter ID.
 *
 * @param <id> ID for the requested parameter.
 *
 * @return parameter type of the requested parameter.
 *
 */
//------------------------------------------------------------------------------
Gmat::ParameterType CelestialBody::GetParameterType(const Integer id) const
{
   if (id >= SpacePointParamCount && id < CelestialBodyParamCount)
      return PARAMETER_TYPE[id - SpacePointParamCount];
      
   return SpacePoint::GetParameterType(id);
}

//------------------------------------------------------------------------------
//  std::string  GetParameterTypeString(const Integer id) const
//------------------------------------------------------------------------------
/**
 * This method returns the parameter type string, given the input parameter ID.
 *
 * @param <id> ID for the requested parameter.
 *
 * @return parameter type string of the requested parameter.
 *
 */
//------------------------------------------------------------------------------
std::string CelestialBody::GetParameterTypeString(const Integer id) const
{
   return SpacePoint::PARAM_TYPE_STRING[GetParameterType(id)];
}

//------------------------------------------------------------------------------
//  Real  GetRealParameter(const Integer id) const
//------------------------------------------------------------------------------
/**
 * This method returns the Real parameter value, given the input parameter ID.
 *
 * @param <id> ID for the requested parameter value.
 *
 * @return  Real value of the requested parameter.
 *
 */
//------------------------------------------------------------------------------
Real CelestialBody::GetRealParameter(const Integer id) const
{
   /// from SpacePoint - this should only be called from Parameters
   if (id == EPOCH_PARAM)
   {
      #ifdef DEBUG_CB_EPOCH
         MessageInterface::ShowMessage(
               "Entering CB::GetReal and getting stateTime as  %le\n",
               lastEphemTime.Get());
      #endif
      return lastEphemTime.Get();
   }
   if (id == MASS)               return mass;
   if (id == EQUATORIAL_RADIUS)  return equatorialRadius;
   if (id == FLATTENING)         return flattening;
   if (id == POLAR_RADIUS)       return polarRadius;
   if (id == MU)                 return mu;
   if (id == HOUR_ANGLE)         return hourAngle;

   // DJC, 06/15/05: Temporarily put an accessor in place to help debug the
   // force model.  This piece may be replaced by a different call when epoch
   // issues are updated in the Spacecraft/SpaceObject code.
   if (id == STATE_TIME)              return stateTime.Get();
   
//   if (id == TWO_BODY_INITIAL_EPOCH)  return twoBodyEpoch.Get();  // 2012.01.24 - wcs - disallowed for now
//   if (id == TWO_BODY_SMA)            return twoBodyKepler[0];
//   if (id == TWO_BODY_ECC)            return twoBodyKepler[1];
//   if (id == TWO_BODY_INC)            return twoBodyKepler[2];
//   if (id == TWO_BODY_RAAN)           return twoBodyKepler[3];
//   if (id == TWO_BODY_AOP)            return twoBodyKepler[4];
//   if (id == TWO_BODY_TA)             return twoBodyKepler[5];

   if (id == ORIENTATION_EPOCH)       return orientationEpoch.Get();
   if (id == SPIN_AXIS_RA_CONSTANT)   return orientation[0];
   if (id == SPIN_AXIS_RA_RATE)       return orientation[1];
   if (id == SPIN_AXIS_DEC_CONSTANT)  return orientation[2];
   if (id == SPIN_AXIS_DEC_RATE)      return orientation[3];
   if (id == ROTATION_CONSTANT)       return orientation[4];
   if (id == ROTATION_RATE)           return orientation[5];
   
   if (id == VIEW_3D_MODEL_OFFSET_X)   return view3dModelOffsetX;
   if (id == VIEW_3D_MODEL_OFFSET_Y)   return view3dModelOffsetY;
   if (id == VIEW_3D_MODEL_OFFSET_Z)   return view3dModelOffsetZ;
   if (id == VIEW_3D_MODEL_ROTATION_X) return view3dModelRotationX;
   if (id == VIEW_3D_MODEL_ROTATION_Y) return view3dModelRotationY;
   if (id == VIEW_3D_MODEL_ROTATION_Z) return view3dModelRotationZ;
   if (id == VIEW_3D_MODEL_SCALE)      return view3dModelScale;
   
   return SpacePoint::GetRealParameter(id);
}

//------------------------------------------------------------------------------
//  Real  SetRealParameter(const Integer id, const Real value)
//------------------------------------------------------------------------------
/**
 * This method sets the Real parameter value, given the input parameter ID.
 *
 * @param <id> ID for the parameter whose value to change.
 * @param <value> value for the parameter.
 *
 * @return  Real value of the requested parameter.
 *
 */
//------------------------------------------------------------------------------
Real CelestialBody::SetRealParameter(const Integer id, const Real value)
{
   Rvector6 tmpKepl = twoBodyKepler;
   #ifdef DEBUG_CB_SET
      MessageInterface::ShowMessage("In CB::SetReal with id = %d, and value = %.14f\n",
      id, value);
   #endif


   // 2012.01.24 - wcs - two body propagation disallowed for now
   std::string noTwoBody = "The two-body ephemeris model for a celestial body has been deprecated. The following setting is invalid \n";
   // 2012.01.24 - wcs - two body propagation disallowed for now

   /// from SpacePoint - this should only be called from Parameters
   if (id == EPOCH_PARAM)
   {
      #ifdef DEBUG_CB_EPOCH
         MessageInterface::ShowMessage(
               "Entering CB::SetReal and setting stateTime to  %le\n",
               value);
      #endif
      A1Mjd a1(value);
      GetMJ2000State(a1);  // will set lastEphemTime and j2kState
      return lastEphemTime.Get();
   }
      
   if (id == EQUATORIAL_RADIUS)
   {
      return SetEquatorialRadius(value);
   }
   if (id == FLATTENING)
   {
      return SetFlattening(value);
   }
   if (id == MU)
   {
      return SetGravitationalConstant(value);
   }
   if (id == HOUR_ANGLE) // does this even make sense?
   { 
      hourAngle           = value;
      return true;
   }
   if (id == VIEW_3D_MODEL_OFFSET_X)
   {
      if (IsRealParameterValid(id, value))
      {
         view3dModelOffsetX = value;
         return true;
      }
      return false;
   }
   if (id == VIEW_3D_MODEL_OFFSET_Y)
   {
      if (IsRealParameterValid(id, value))
      {
         view3dModelOffsetY = value;
         return true;
      }
      return false;
   }
   if (id == VIEW_3D_MODEL_OFFSET_Z)
   {
      if (IsRealParameterValid(id, value))
      {
         view3dModelOffsetZ = value;
         return true;
      }
      return false;
   }
   if (id == VIEW_3D_MODEL_ROTATION_X)
   {
      if (IsRealParameterValid(id, value))
      {
         view3dModelRotationX = value;
         return true;
      }
      return false;
   }
   if (id == VIEW_3D_MODEL_ROTATION_Y)
   {
      if (IsRealParameterValid(id, value))
      {
         view3dModelRotationY = value;
         return true;
      }
      return false;
   }
   if (id == VIEW_3D_MODEL_ROTATION_Z)
   {
      if (IsRealParameterValid(id, value))
      {
         view3dModelRotationZ = value;
         return true;
      }
      return false;
   }
   if (id == VIEW_3D_MODEL_SCALE)
   {
      if (IsRealParameterValid(id, value))
      {
         view3dModelScale = value;
         return true;
      }
      return false;
   }
   
   // 2012.01/24 - wcs - two body propagation disallowed for now
   if ((id == TWO_BODY_INITIAL_EPOCH) || (id == TWO_BODY_SMA)  || (id == TWO_BODY_ECC) ||
       (id == TWO_BODY_INC)           || (id == TWO_BODY_RAAN) || (id == TWO_BODY_AOP) ||
       (id == TWO_BODY_TA))
   {
      throw SolarSystemException(noTwoBody);
   }
   // 2012.01/24 - wcs - two body propagation disallowed for now

//   if (id == TWO_BODY_INITIAL_EPOCH)
//   {
//      if (SetTwoBodyEpoch(A1Mjd(value)))
//      {
//         newTwoBody          = true;
//         return true;
//      }
//      else return false;
//   }
//   if (id == TWO_BODY_SMA)
//   {
//      tmpKepl[0] = value;
//      if (SetTwoBodyElements(tmpKepl))
//      {
//         newTwoBody          = true;
//         return true;
//      }
//      else return false;
//   }
//   if (id == TWO_BODY_ECC)
//   {
//      tmpKepl[1] = value;
//      if (SetTwoBodyElements(tmpKepl))
//      {
//         newTwoBody          = true;
//         return true;
//      }
//      else return false;
//   }
//   if (id == TWO_BODY_INC)
//   {
//      tmpKepl[2] = value;
//      if (SetTwoBodyElements(tmpKepl))
//      {
//         newTwoBody          = true;
//         return true;
//      }
//      else return false;
//   }
//   if (id == TWO_BODY_RAAN)
//   {
//      tmpKepl[3] = value;
//      if (SetTwoBodyElements(tmpKepl))
//      {
//         newTwoBody          = true;
//         return true;
//      }
//      else return false;
//   }
//   if (id == TWO_BODY_AOP)
//   {
//      tmpKepl[4] = value;
//      if (SetTwoBodyElements(tmpKepl))
//      {
//         newTwoBody          = true;
//         return true;
//      }
//      else return false;
//   }
//   if (id == TWO_BODY_TA)
//   {
//      tmpKepl[5] = value;
//      if (SetTwoBodyElements(tmpKepl))
//      {
//         newTwoBody          = true;
//         return true;
//      }
//      else return false;
//   }

   // for now, don't allow user to modify orientation parameters for default bodies
   if (userDefined)
   {
      if (id == ORIENTATION_EPOCH)
      {
         if ((value >= DateUtil::EARLIEST_VALID_MJD_VALUE) &&
             (value <= DateUtil::LATEST_VALID_MJD_VALUE))
            orientationEpoch    = value;
         else
         {
            std::stringstream errmsg;
            errmsg << "*** Error *** The value of " << value 
                   << " for field " << GetParameterText(id)
                   << " on object \"" << instanceName 
                   <<  "\" is not an allowed value.\n"
                   << "The allowed values are: [Real number between " 
                   << DateUtil::EARLIEST_VALID_MJD_VALUE
                   << " and " << DateUtil::LATEST_VALID_MJD_VALUE << "]";
            throw SolarSystemException(errmsg.str());
         }
         return true;
      }
      if (id == SPIN_AXIS_RA_CONSTANT)
      {
         orientation[0]      = value;
         return true;
      }
      if (id == SPIN_AXIS_RA_RATE)
      {
         orientation[1]      = value;
         return true;
      }
      if (id == SPIN_AXIS_DEC_CONSTANT)
      {
         orientation[2]      = value;
         return true;
      }
      if (id == SPIN_AXIS_DEC_RATE)
      {
         orientation[3]      = value;
         return true;
      }
      if (id == ROTATION_CONSTANT)
      {
         orientation[4]      = value;
         return true;
      }
      if (id == ROTATION_RATE)
      {
         orientation[5]      = value;
         return true;
      }
   }
   else // for default bodies, we are currently not allowing the user to modify these
   {
      if ((id == ORIENTATION_EPOCH)      || 
          (id == SPIN_AXIS_RA_CONSTANT)  || (id == SPIN_AXIS_RA_RATE)  ||
          (id == SPIN_AXIS_DEC_CONSTANT) || (id == SPIN_AXIS_DEC_RATE) ||
          (id == ROTATION_CONSTANT)      || (id == ROTATION_RATE))
      {
         std::string errmsg = "Modification of orientation parameters for default body ";
         errmsg += instanceName + " is not allowed.\n";
         throw SolarSystemException(errmsg);
      }
   }

   #ifdef DEBUG_TWO_BODY
      MessageInterface::ShowMessage(
      "At end of CB::SetReal, Keplerian elements are %.14f %.14f %.14f %.14f %.14f %.14f\n",
      twoBodyKepler[0],twoBodyKepler[1],twoBodyKepler[2],twoBodyKepler[3],
      twoBodyKepler[4],twoBodyKepler[5]);
      MessageInterface::ShowMessage(
      "..... and epoch is: %.14f\n",twoBodyEpoch.Get());
   #endif
   
   return SpacePoint::SetRealParameter(id, value);
}

//------------------------------------------------------------------------------
//  Integer  GetIntegerParameter(const Integer id) const
//------------------------------------------------------------------------------
/**
 * This method returns the Integer parameter value, given the input
 * parameter ID.
 *
 * @param <id> ID for the requested parameter.
 *
 * @return  Integer value of the requested parameter.
 *
 */
//------------------------------------------------------------------------------
Integer CelestialBody::GetIntegerParameter(const Integer id) const
{
   if (id == ORDER)                return order;
   if (id == DEGREE)               return degree;
   if (id == BODY_NUMBER)          return bodyNumber;
   if (id == REF_BODY_NUMBER)      return referenceBodyNumber;
   if (id == ROTATION_DATA_SRC)    return (Integer) rotationSrc;
   
   return SpacePoint::GetIntegerParameter(id); // add others in later?
}

//------------------------------------------------------------------------------
//  Integer  SetIntegerParameter(const Integer id, const Integer value)
//------------------------------------------------------------------------------
/**
 * This method sets the Integer parameter value, given the input
 * parameter ID.
 *
 * @param <id> ID for the requested parameter.
 * @param <value> Integer value for the requested parameter.
 *
 * @return  Integer value of the requested parameter.
 *
 */
//------------------------------------------------------------------------------
Integer CelestialBody::SetIntegerParameter(const Integer id,
                                           const Integer value)
{
   if (id == ORDER)
   {
      order               = value;
      return true;
   }
   if (id == DEGREE)
   {
      degree              = value;
      return true;
   }
   if (id == BODY_NUMBER)
   {
      bodyNumber          = value;
      return true;
   }
   if (id == REF_BODY_NUMBER)
   {
      referenceBodyNumber = value;
      return true;
   }
   
   return SpacePoint::SetIntegerParameter(id,value);  // add others in later
}

//------------------------------------------------------------------------------
//  std::string  GetStringParameter(const Integer id) const
//------------------------------------------------------------------------------
/**
 * This method returns the string parameter value, given the input
 * parameter ID.
 *
 * @param <id> ID for the requested parameter.
 *
 * @return  string value of the requested parameter.
 *
 */
//------------------------------------------------------------------------------
std::string CelestialBody::GetStringParameter(const Integer id) const
{
   #ifdef DEBUG_GET_STRING
   MessageInterface::ShowMessage
      ("CelestialBody::GetStringParameter() '%s' entered, id = %d, textureMapFileName = '%s'\n",
       GetName().c_str(), id, textureMapFileName.c_str());
   #endif
   
   if (id == BODY_TYPE)             return Gmat::BODY_TYPE_STRINGS[bodyType];
   if (id == POS_VEL_SOURCE)        return Gmat::POS_VEL_SOURCE_STRINGS[posVelSrc];

   if (id == POTENTIAL_FILE_NAME)   return potentialFileName;
   if (id == ATMOS_MODEL_NAME)
   {
      if (atmModel == NULL) return "";
      return atmModel->GetTypeName();
   }
   if (id == CENTRAL_BODY)          return theCentralBodyName;
//   if (id == TWO_BODY_DATE_FORMAT)  return twoBodyFormat; // 2012.01.24 - wcs - two body propagation disallowed for now
//   if (id == TWO_BODY_STATE_TYPE)   return twoBodyStateType;
   if (id == ROTATION_DATA_SRC)     return Gmat::ROTATION_DATA_SOURCE_STRINGS[rotationSrc];

   if (id == ORIENTATION_DATE_FORMAT)  return orientationDateFormat;
   
   if (id == TEXTURE_MAP_FILE_NAME)    return textureMapFileName;
   if (id == TEXTURE_MAP_FULL_PATH)    return textureMapFullPath;
   if (id == VIEW_3D_MODEL_FILE_NAME)       return view3dModelFileName;
   if (id == VIEW_3D_MODEL_FILE_FULL_PATH)  return view3dModelFileFullPath;
   
   return SpacePoint::GetStringParameter(id);
}

//------------------------------------------------------------------------------
//  std::string  GetStringParameter(const Integer id, const Integer index) const
//------------------------------------------------------------------------------
/**
 * This method returns the string parameter value, given the input
 * parameter ID and the input index.
 *
 * @param <id>    ID for the requested parameter.
 * @param <index> index into the array of integers
 *
 * @return  string value of the requested parameter.
 *
 */
//------------------------------------------------------------------------------
std::string CelestialBody::GetStringParameter(const Integer id,
                                              const Integer index) const
{   
   return SpacePoint::GetStringParameter(id, index);
}


//------------------------------------------------------------------------------
//  bool  SetStringParameter(const Integer id, const std::string value)
//------------------------------------------------------------------------------
/**
 * This method sets the string parameter value, given the input
 * parameter ID.
 *
 * @param <id> ID for the requested parameter.
 * @param <value> string value for the requested parameter.
 *
 * @exception <SolarSystemException> thrown if value is out of range
 *
 * @return  success flag.
 *
 */
//------------------------------------------------------------------------------
bool CelestialBody::SetStringParameter(const Integer id,
                                       const std::string &value)
{
   #ifdef DEBUG_CB_SET_STRING
   std::string idString = GetParameterText(id);
   MessageInterface::ShowMessage
      ("CelestialBody::SetStringP:: id = %d (%s), value = %s\n",
       id, idString.c_str(), value.c_str());
   #endif

   // 2012.01/24 - wcs - two body propagation disallowed for now
   std::string noTwoBody = "TwoBody propagation not currently allowed in GMAT.\n";
   // 2012.01/24 - wcs - two body propagation disallowed for now

   // this is also handled in SpacePoint - we catch it here to tailor the warning message
   if (id == J2000_BODY_NAME)
   {
      static bool writeIgnoredMessage = true;
      if (writeIgnoredMessage)
      {
         MessageInterface::ShowMessage
            ("*** WARNING *** \"J2000BodyName\" on Celestial Bodies is ignored and will be "
             "removed from a future build\n");
         writeIgnoredMessage = false;
      }

      return true;
   }

   int i;
   if (id == BODY_TYPE)
   {
      for (i=0;i<Gmat::BodyTypeCount;i++)
         if (value == Gmat::BODY_TYPE_STRINGS[i])
         {
            bodyType = (Gmat::BodyType) i;
            return true;
         }
      return false;
   }
   if (id == POS_VEL_SOURCE)
   {
      if (userDefined && (value == "DE405"))
      {
         std::string errmsg = "DE405 not allowed as ephemeris source for user-defined body \"";
         errmsg += instanceName + "\"\n";
         throw SolarSystemException(errmsg);
      }
      else if (userDefined && (value == "DE421"))
      {
         std::string errmsg = "DE421 not allowed as ephemeris source for user-defined body \"";
         errmsg += instanceName + "\"\n";
         throw SolarSystemException(errmsg);
      }
      else if (userDefined && (value == "DE424"))
      {
         std::string errmsg = "DE424 not allowed as ephemeris source for user-defined body \"";
         errmsg += instanceName + "\"\n";
         throw SolarSystemException(errmsg);
      }
//      else if (userDefined && (value == "DE430"))
//      {
//         std::string errmsg = "DE430 not allowed as ephemeris source for user-defined body \"";
//         errmsg += instanceName + "\"\n";
//         throw SolarSystemException(errmsg);
//      }
      else if ((!userDefined) && !allowSpice && (value == "SPICE"))
      {
         std::string errmsg = "SPICE not allowed as ephemeris source for default body \"";
         errmsg += instanceName + "\"\n";
         throw SolarSystemException(errmsg);
      }
      for (i=0;i<Gmat::PosVelSourceCount;i++)
         if (value == Gmat::POS_VEL_SOURCE_STRINGS[i])
         {
            posVelSrc = (Gmat::PosVelSource) i;
            return true;
         }
      return false;
   }
   if (id == POTENTIAL_FILE_NAME)
   {
      // Changed to use GmatBase::GetFullPathFileName()
      std::string potFile = GmatStringUtil::ToUpper(instanceName) + "_POT_FILE";
      potentialFileNameFullPath =
         GmatBase::GetFullPathFileName(potentialFileName, GetName(), value, potFile, true,
                                       "", false, true);
      #ifdef DEBUG_CB_SET_STRING
      MessageInterface::ShowMessage
         ("   potentialFileNameFullPath = '%s'\n", potentialFileNameFullPath.c_str());
      #endif
      // if (!(GmatFileUtil::DoesFileExist(value)))
      if (potentialFileNameFullPath == "")
      {
         SolarSystemException sse;
         sse.SetDetails(errorMessageFormat.c_str(),
                        value.c_str(), "PotentialFileName", "File must exist");
         throw sse;
      }
      
      potentialFileName = value;
      return true;
   }
   if (id == ATMOS_MODEL_NAME)
   {
      atmModelType = value;
      return true;
   }
   if (id == CENTRAL_BODY)
   {
      theCentralBodyName = value;
      return true;
   }

   // 2012.01/24 - wcs - two body propagation disallowed for now
   if ((id == TWO_BODY_DATE_FORMAT) || (id == TWO_BODY_STATE_TYPE))
   {
      throw SolarSystemException(noTwoBody);
   }
   // 2012.01/24 - wcs - two body propagation disallowed for now

   //   if (id == TWO_BODY_DATE_FORMAT)
//   {
//      #ifdef DEBUG_TWO_BODY
//         MessageInterface::ShowMessage(
//         "In CB::SetString (TWO_BODY_DATE_FORMAT) with id = %d, and value = %s\n",
//         id, value.c_str());
//      #endif
//      if (value != "TAIModJulian")
//      {
//         SolarSystemException sse;
//         sse.SetDetails(errorMessageFormat.c_str(), value.c_str(),
//                        PARAMETER_TEXT[TWO_BODY_DATE_FORMAT - SpacePointParamCount].c_str(),
//                        "TAIModJulian");
//         throw sse;
//      }
//      twoBodyFormat = value;
//      return true;
//   }
//   if (id == TWO_BODY_STATE_TYPE)
//   {
//      #ifdef DEBUG_TWO_BODY
//         MessageInterface::ShowMessage(
//         "In CB::SetString (TWO_BODY_STATE_TYPE) with id = %d, and value = %s\n",
//         id, value.c_str());
//      #endif
//      if (value != "Keplerian")
//      {
//         SolarSystemException sse;
//         sse.SetDetails(errorMessageFormat.c_str(), value.c_str(),
//                        PARAMETER_TEXT[TWO_BODY_STATE_TYPE - SpacePointParamCount].c_str(),
//                        "Keplerian");
//
//         throw sse;
//      }
//      twoBodyStateType = value;
//      return true;
//   }
   
   if (id == ROTATION_DATA_SRC)
   {
      if (value == Gmat::ROTATION_DATA_SOURCE_STRINGS[Gmat::DE_405_FILE])
         SetRotationDataSource(Gmat::DE_405_FILE);
      else if (value == Gmat::ROTATION_DATA_SOURCE_STRINGS[Gmat::IAU_2002])
         SetRotationDataSource(Gmat::IAU_2002);
      else if (value == Gmat::ROTATION_DATA_SOURCE_STRINGS[Gmat::FK5_IAU_1980])
         SetRotationDataSource(Gmat::FK5_IAU_1980);
      else if (value == Gmat::ROTATION_DATA_SOURCE_STRINGS[Gmat::IAU_SIMPLIFIED])
         SetRotationDataSource(Gmat::IAU_SIMPLIFIED);
      else
      {
         std::string errmsg = "Unrecognized Rotation Data Source \"";
         errmsg += value + "\" for body ";
         errmsg += instanceName + "\n";
         throw SolarSystemException(errmsg);
      }
      return true;
   }

   if (id == ORIENTATION_DATE_FORMAT)
   {
      if (value != "TAIModJulian")
      {
         SolarSystemException sse;
         sse.SetDetails(errorMessageFormat.c_str(), value.c_str(),
                        PARAMETER_TEXT[ORIENTATION_DATE_FORMAT - SpacePointParamCount].c_str(),
                        "TAIModJulian");
         throw sse;
      }
      orientationDateFormat = value;;
      return true;
   }

   if (id == TEXTURE_MAP_FILE_NAME)
   {
      // Check for texture map file has changed to avoid duplicate waring message
      // from the FileManager (LOJ: 2014.08.27)
      if (textureMapFileName != value)
      {
         // Find find from the FileManager (LOJ: 2014.06.18)
         textureMapFileName = value;
         #ifdef DEBUG_TEXTURE_FILE
         MessageInterface::ShowMessage
            ("3 Calling SetTextureMapFileName() textureMapFileName = '%s'\n", textureMapFileName.c_str());
         #endif
         SetTextureMapFileName(textureMapFileName, true);
      }
      
      // Question: Do we want to throw an exception during the setting?
      #if 0
      if (textureMapFullPath == "")
      {
         std::string errmsg = "Texture map \"";
         errmsg += textureMapFileName + "\" specified for body \"";
         errmsg += instanceName + "\" cannot be found.\n";
         throw SolarSystemException(errmsg);
      }
      #endif
      
      // if (!GmatFileUtil::DoesFileExist(textureMapFileName.c_str()))
      // {
      //    std::string oldTextureFile = textureMapFileName;
      //    std::string textureLoc     = (FileManager::Instance())->GetFullPathname("TEXTURE_PATH");
      //    textureMapFileName         = textureLoc + textureMapFileName;
      //    if (oldTextureFile != "")
      //    {
      //       if (GmatFileUtil::DoesFileExist(textureMapFileName.c_str()))
      //       {
      //          MessageInterface::ShowMessage
      //             ("*** WARNING *** The texture file '%s' does not exist, \n"
      //              "    so using the texture file '%s' using the path specified in the startup file.\n",
      //              oldTextureFile.c_str(), textureMapFileName.c_str(), instanceName.c_str());
      //       }
      //       else
      //       {
      //          std::string errmsg = "Texture map \"";
      //          errmsg += oldTextureFile + "\" specified for body \"";
      //          errmsg += instanceName + "\" cannot be found.\n";
      //          throw SolarSystemException(errmsg);
      //       }
      //    }
      // }
      return true;
   }
   
   if (id == VIEW_3D_MODEL_FILE_NAME)
   {
      if (view3dModelFileName != value)
      {
         view3dModelFileName = value;
         #ifdef DEBUG_TEXTURE_FILE
         MessageInterface::ShowMessage
            ("3 Calling Set3dModelFileName() view3dModelFileName = '%s'\n", view3dModelFileName.c_str());
         #endif
         Set3dModelFileName(view3dModelFileName, true);
      }
      
      return true;
   }
   
   return SpacePoint::SetStringParameter(id, value);
}
   
//------------------------------------------------------------------------------
//  bool  SetStringParameter(const Integer id, const std::string value,
//                           const Integer index)
//------------------------------------------------------------------------------
/**
 * This method sets the string parameter value, given the input
 * parameter ID and the input index.
 *
 * @param <id>    ID for the requested parameter.
 * @param <value> string value for the requested parameter.
 * @param <index> index into the integer array
 *
 * @return  success flag.
 *
 */
//------------------------------------------------------------------------------
bool CelestialBody::SetStringParameter(const Integer id, const std::string &value,
                                       const Integer index)
{
   return SpacePoint::SetStringParameter(id, value, index);
}


//------------------------------------------------------------------------------
//  bool  GetBooleanParameter(const Integer id) const
//------------------------------------------------------------------------------
/**
 * This method returns the bool parameter value, given the input
 * parameter ID.
 *
 * @param <id> ID for the requested parameter.
 *
 * @return  bool value of the requested parameter.
 *
 */
//------------------------------------------------------------------------------
bool CelestialBody::GetBooleanParameter(const Integer id) const
{
   if (id == USE_POTENTIAL_FILE_FLAG)       return usePotentialFile;

   return SpacePoint::GetBooleanParameter(id);
}

//------------------------------------------------------------------------------
//  bool  SetBooleanParameter(const Integer id, const std::string value)
//------------------------------------------------------------------------------
/**
 * This method sets the bool parameter value, given the input
 * parameter ID.
 *
 * @param <id>    ID for the requested parameter.
 * @param <value> bool value for the requested parameter.
 *
 * @return  success flag.
 *
 */
//------------------------------------------------------------------------------
bool CelestialBody::SetBooleanParameter(const Integer id,
                                        const bool value) // const?
{
   if (id == USE_POTENTIAL_FILE_FLAG)
   {
      if ((usePotentialFile == false) && (value == true))
      {
         potentialFileRead = false;
         isFirstTimeMu = true;
         isFirstTimeRadius = true;
      }
      else if ((usePotentialFile == true) && (value == false))
      {
         mu               = default_mu;
         equatorialRadius = default_equatorialRadius;
         // recompute polar radius
         polarRadius = (1.0 - flattening) * equatorialRadius;
         // recompute mass
         mass = mu / GmatPhysicalConstants::UNIVERSAL_GRAVITATIONAL_CONSTANT;
         isFirstTimeMu = true;
         isFirstTimeRadius = true;
      }
   
      usePotentialFile = value;
      return true; 
   }

   return SpacePoint::SetBooleanParameter(id,value);
}

//------------------------------------------------------------------------------
//  const Rvector&  GetRvectorParameter(const Integer id)
//------------------------------------------------------------------------------
/**
 * This method gets the Rvector parameter value, given the input
 * parameter ID.
 *
 * @param <id> ID for the requested parameter.
 *
 * @return  success flag.
 *
 */
//------------------------------------------------------------------------------
const Rvector&  CelestialBody::GetRvectorParameter(const Integer id) const
{
   if (id == STATE)               return state;
   if (id == ANGULAR_VELOCITY)    return angularVelocity;

   return SpacePoint::GetRvectorParameter(id);
}

//------------------------------------------------------------------------------
//  const Rvector&  SetRvectorParameter(const Integer id, const Rvector& value)
//------------------------------------------------------------------------------
/**
 * This method sets the Rvector parameter value, given the input
 * parameter ID.
 *
 * @param <id>    ID for the requested parameter.
 * @param <value> Rvector value for the requested parameter.
 *
 * @return  success flag.
 *
 */
//------------------------------------------------------------------------------
const Rvector&  CelestialBody::SetRvectorParameter(const Integer id,
                                              const Rvector &value)
{
   Integer sz = value.GetSize();
   Integer i;
   
   if (id == STATE)
   {
      if (sz != 6) throw SolarSystemException(
                  "Incorrectly sized Rvector passed in for state.");
      for (i=0;i<6;i++) state(i) = value(i);
      return state;
   }
   if (id == ANGULAR_VELOCITY)
   {
      if (sz != 3) throw SolarSystemException(
                   "Incorrectly sized Rvector passed in for angular velocity.");
      for (i=0;i<3;i++) angularVelocity(i) = value(i);
      return angularVelocity;
   }

   return SpacePoint::SetRvectorParameter(id,value);
}

//------------------------------------------------------------------------------
//  const Rvector&  GetRvectorParameter(const std::string &label)
//------------------------------------------------------------------------------
/**
 * This method gets the Rvector parameter value, given the input
 * parameter ID.
 *
 * @param <label> string ID for the requested parameter.
 *
 * @return  success flag.
 *
 */
//------------------------------------------------------------------------------
const Rvector& CelestialBody::GetRvectorParameter(const std::string &label) const
{
   return GetRvectorParameter(GetParameterID(label));
}

//------------------------------------------------------------------------------
//  const Rvector&  SetRvectorParameter(const std::string &label,
//                                      const Rvector& value)
//------------------------------------------------------------------------------
/**
 * This method sets the Rvector parameter value, given the input
 * parameter ID.
 *
 * @param <label> string ID for the requested parameter.
 * @param <value> Rvector value for the requested parameter.
 *
 * @return  success flag.
 *
 */
//------------------------------------------------------------------------------
const Rvector& CelestialBody::SetRvectorParameter(const std::string &label,
                                              const Rvector &value)
{
   return SetRvectorParameter(GetParameterID(label), value);
}

//------------------------------------------------------------------------------
//  const Rmatrix&  GetRmatrixParameter(const Integer id)
//------------------------------------------------------------------------------
/**
 * This method gets the Rmatrix parameter value, given the input
 * parameter ID.
 *
 * @param <id> ID for the requested parameter.
 *
 * @return  success flag.
 *
 */
//------------------------------------------------------------------------------
//const Rmatrix& CelestialBody::GetRmatrixParameter(const Integer id) const
//{
//   if (id == SIJ)               return sij;
//   if (id == CIJ)               return cij;
//   
//   return SpacePoint::GetRmatrixParameter(id);
//}

//------------------------------------------------------------------------------
//  const Rmatrix&  SetRmatrixParameter(const Integer id, const Rmatrix& value)
//------------------------------------------------------------------------------
/**
 * This method sets the Rmatrix parameter value, given the input
 * parameter ID.
 *
 * @param <id>    ID for the requested parameter.
 * @param <value> Rmatrix value for the requested parameter.
 *
 * @return  success flag.
 *
 */
//------------------------------------------------------------------------------
//const Rmatrix& CelestialBody::SetRmatrixParameter(const Integer id,
//                                                  const Rmatrix &value)
//{
//   if (id == SIJ) 
//   {
//      sij = value;
//      return true;
//   }
//   if (id == CIJ)
//   {
//      cij = value;
//      return true;
//   }
//
//   return SpacePoint::SetRmatrixParameter(id,value);
//}

//------------------------------------------------------------------------------
//  const Rmatrix&  GetRmatrixParameter(const std::string &label)
//------------------------------------------------------------------------------
/**
 * This method gets the Rmatrix parameter value, given the input
 * parameter ID.
 *
 * @param <label> string ID for the requested parameter.
 *
 * @return  success flag.
 *
 */
//------------------------------------------------------------------------------
//const Rmatrix& CelestialBody::GetRmatrixParameter(const std::string &label) const
//{
//   return GetRmatrixParameter(GetParameterID(label));
//}

//------------------------------------------------------------------------------
//  const Rmatrix&  SetRmatrixParameter(const std::string &label,
//                                      const Rmatrix& value)
//------------------------------------------------------------------------------
/**
 * This method sets the Rmatrix parameter value, given the input
 * parameter ID.
 *
 * @param <label> string ID for the requested parameter.
 * @param <value> Rmatrix value for the requested parameter.
 *
 * @return  success flag.
 *
 */
//------------------------------------------------------------------------------
//const Rmatrix& CelestialBody::SetRmatrixParameter(const std::string &label,
//                                                  const Rmatrix &value)
//{
//   return SetRmatrixParameter(GetParameterID(label), value);
//}

//------------------------------------------------------------------------------
//  const StringArray&   GetStringArrayParameter((const Integer id) const
//------------------------------------------------------------------------------
/**
 * This method returns the StringArray parameter value, given the input
 * parameter ID.
 *
 * @param <id> ID for the requested parameter.
 *
 * @return  StringArray value of the requested parameter.
 *
 */
//------------------------------------------------------------------------------
const StringArray& CelestialBody::GetStringArrayParameter(const Integer id) const
{
   return SpacePoint::GetStringArrayParameter(id);
}


//------------------------------------------------------------------------------
//  GmatBase* GetRefObject(const Gmat::ObjectType type,
//                         const std::string &name)
//------------------------------------------------------------------------------
/**
 * This method returns a reference object from the CelestialBody class.
 *
 * @param type  type of the reference object requested
 * @param name  name of the reference object requested
 *
 * @return pointer to the reference object requested.
 *
 */
//------------------------------------------------------------------------------
GmatBase* CelestialBody::GetRefObject(const Gmat::ObjectType type,
                                      const std::string &name)
{
   switch (type)
   {
      case Gmat::SPACE_POINT:
      case Gmat::CELESTIAL_BODY:
         if ((theCentralBody) && (name == theCentralBodyName)) return theCentralBody;
         break;
      default:
         break;
   }
   
   // Not handled here -- invoke the next higher GetRefObject call
   return SpacePoint::GetRefObject(type, name);
}


//------------------------------------------------------------------------------
//  const StringArray& GetRefObjectNameArray(const Gmat::ObjectType type)
//------------------------------------------------------------------------------
/**
 * Returns the names of the reference object. (Derived classes should implement
 * this as needed.)
 *
 * @param <type> reference object type.  Gmat::UnknownObject returns all of the
 *               ref objects.
 *
 * @return The names of the reference object.
 */
//------------------------------------------------------------------------------
const StringArray& CelestialBody::GetRefObjectNameArray(
                                  const Gmat::ObjectType type)
{
   if ((type == Gmat::UNKNOWN_OBJECT) ||
       (type == Gmat::CELESTIAL_BODY) ||
       (type == Gmat::SPACE_POINT) )
   {

      static StringArray refs;
      refs.clear();

      refs.push_back(theCentralBodyName);

      #ifdef DEBUG_REFERENCE_SETTING
         MessageInterface::ShowMessage("+++ReferenceObjects:\n");
         for (StringArray::iterator i = refs.begin(); i != refs.end(); ++i)
            MessageInterface::ShowMessage("   %s\n", i->c_str());
      #endif

      return refs;
   }

   #ifdef DEBUG_REFERENCE_SETTING
      MessageInterface::ShowMessage("Calling SpacePoint::GetRefObjectNameArray for body %s\n",
            instanceName.c_str());
   #endif
   // Not handled here -- invoke the next higher GetRefObject call
   return SpacePoint::GetRefObjectNameArray(type);
}


//------------------------------------------------------------------------------
//  bool SetRefObject(GmatBase *obj, const Gmat::ObjectType type,
//                    const std::string &name)
//------------------------------------------------------------------------------
/**
 * This method sets a reference object for the CelestialBody class.
 *
 * @param obj   pointer to the reference object
 * @param type  type of the reference object
 * @param name  name of the reference object
 *
 * @return true if successful; otherwise, false.
 *
 */
//------------------------------------------------------------------------------
bool CelestialBody::SetRefObject(GmatBase *obj,
                                 const Gmat::ObjectType type,
                                 const std::string &name)
{
   #ifdef DEBUG_REFERENCE_SETTING
   MessageInterface::ShowMessage
      ("CelestialBody::SetRefObject() this=<%p> %s, obj=%p, name=%s\n",
       this, GetName().c_str(), obj, name.c_str());
   #endif
   
   if (this == obj)
      return true;
   
   bool foundHere = false;
   bool trySP     = false;
   if (obj->IsOfType("CelestialBody"))
   {
      if (name == theCentralBodyName)
      {
         CelestialBody *cb = (CelestialBody*) obj;
         if ((theCentralBody == NULL) || (theCentralBody != cb))
         {
            #ifdef DEBUG_REFERENCE_SETTING
               MessageInterface::ShowMessage("   Setting %s as central body for %s\n",
                                             name.c_str(), instanceName.c_str());
            #endif
            theCentralBody  = cb;
            centralBodySet  = true;
            foundHere = true;
         }
     }
   }
   
   // may also be the right object for a higher level parameter ...
   try
   {
      trySP = SpacePoint::SetRefObject(obj, type, name);
   }
   catch (GmatBaseException &)
   {
      //loj: We don't want to throw an exception here. (2007.12.05)
      //if (!foundHere) throw;
      #ifdef DEBUG_REFERENCE_SETTING
      MessageInterface::ShowMessage(e.GetFullMessage() + "\n");
      #endif
   }
   if (foundHere || trySP) 
   {
      return true;
   }
   return false;
}


//------------------------------------------------------------------------------
// bool IsParameterReadOnly(const Integer id) const
//------------------------------------------------------------------------------
/**
 * @see GmatBase
 */
//------------------------------------------------------------------------------
bool CelestialBody::IsParameterReadOnly(const Integer id) const
{
   // if we're not using an twoBody model, those parameters are read-only
//   if (posVelSrc != Gmat::ANALYTIC)
//   if (posVelSrc != Gmat::TWO_BODY_PROPAGATION)
//   {
//      if ((id == TWO_BODY_DATE_FORMAT)   || (id == TWO_BODY_STATE_TYPE) ||
//          (id == TWO_BODY_INITIAL_EPOCH) || (id == TWO_BODY_SMA)        ||
//          (id == TWO_BODY_ECC)           || (id == TWO_BODY_INC)        ||
//          (id == TWO_BODY_RAAN)          || (id == TWO_BODY_AOP)        ||
//          (id == TWO_BODY_TA) )
////         (id == TWO_BODY_TA)            || (id == ANALYTIC_METHOD)      )
//      {
//         #ifdef DEBUG_TWO_BODY
////            MessageInterface::ShowMessage(
////            "In CB::IParameterReadOnly, id = %d, returning TRUE\n",
////            id);
//         #endif
////         return true; // 2009.01.11 WCS - always write out elements, no matter the source
//      }
//   }
   // do not write out computed and some other items
   if ((id == BODY_TYPE)               || (id == MASS)                    || (id == POLAR_RADIUS)        || 
       (id == STATE)                   || (id == STATE_TIME)              || (id == HOUR_ANGLE)          ||
       (id == REF_BODY_NUMBER)         || (id == ORDER)                   ||
       (id == DEGREE)                  || (id == ATMOS_MODEL_NAME)        || (id == BODY_NUMBER)         ||
       (id == ANGULAR_VELOCITY)        || (id == TWO_BODY_DATE_FORMAT)    || (id == TWO_BODY_STATE_TYPE) ||
       (id == ORIENTATION_DATE_FORMAT) || (id == USE_POTENTIAL_FILE_FLAG) || (id == POTENTIAL_FILE_NAME)  )
      return true;
   // the ephem source for default bodies is set on the Solar System 
   if ((!userDefined) && (id == POS_VEL_SOURCE)) return true;
   // for now, don't allow user to modify orientation parameters for default bodies
   if (!userDefined && ((id == ORIENTATION_EPOCH)      || 
       (id == SPIN_AXIS_RA_CONSTANT)  || (id == SPIN_AXIS_RA_RATE) ||
       (id == SPIN_AXIS_DEC_CONSTANT) || (id == SPIN_AXIS_DEC_RATE) ||
       (id == ROTATION_CONSTANT)      || (id == ROTATION_RATE)))
      return true;


   // NAIF ID is not read-only for celestial bodies
   if (id == NAIF_ID)  return false;
   // NAIF ID for the spacecraft reference frame is currently read-only for spacecraft BUT
   // that may change when/if we add the reading of PCK kernels for body orientation data
//   if (id == NAIF_ID_REFERENCE_FRAME)  return false;

//   if (id == ATTITUDE_SPICE_KERNEL_NAME)  return true;
//   if (id == FRAME_SPICE_KERNEL_NAME)     return true;
   if (id == SC_CLOCK_SPICE_KERNEL_NAME)  return true;

   // 2012.01.24 - wcs - disallow TWO_BODY_PROPAGATION for now
   if ((id == TWO_BODY_DATE_FORMAT)   || (id == TWO_BODY_STATE_TYPE) ||
       (id == TWO_BODY_INITIAL_EPOCH) || (id == TWO_BODY_SMA)        ||
       (id == TWO_BODY_ECC)           || (id == TWO_BODY_INC)        ||
       (id == TWO_BODY_RAAN)          || (id == TWO_BODY_AOP)        ||
       (id == TWO_BODY_TA) )
   {
      return true;
   }

   if (id == TEXTURE_MAP_FULL_PATH || id == VIEW_3D_MODEL_FILE_FULL_PATH)
      return true;
   
   return SpacePoint::IsParameterReadOnly(id);
}


//------------------------------------------------------------------------------
// bool CelestialBody::IsParameterCloaked(const Integer id) const
//------------------------------------------------------------------------------
/**
 * @see GmatBase
 */
//------------------------------------------------------------------------------
bool CelestialBody::IsParameterCloaked(const Integer id) const
{
   if (!cloaking) return false;
   // if it's read-only, we'll cloak it
   if (IsParameterReadOnly(id)) return true;

   if (id >= SpacePointParamCount && id < CelestialBodyParamCount)
      return IsParameterEqualToDefault(id);
   
   return SpacePoint::IsParameterCloaked(id);
}

//------------------------------------------------------------------------------
// bool CelestialBody::IsParameterEqualToDefault(const Integer id) const
//------------------------------------------------------------------------------
/**
 * @see GmatBase
 */
//------------------------------------------------------------------------------
bool CelestialBody::IsParameterEqualToDefault(const Integer id) const
{
   if (id == EQUATORIAL_RADIUS)
   {
      return GmatMathUtil::IsEqual(default_equatorialRadius,equatorialRadius);
   }
   if (id == FLATTENING)
   {
      return GmatMathUtil::IsEqual(default_flattening,flattening);
   }
   if (id == MU)
   {
      return GmatMathUtil::IsEqual(default_mu,mu);
   } 
   if (id == POS_VEL_SOURCE)
   {
      #ifdef DEBUG_CB_CLOAKING
            MessageInterface::ShowMessage("In IsPEqual ... posVelSrc = %s & default = %s\n",
                  (Gmat::POS_VEL_SOURCE_STRINGS[posVelSrc]).c_str(), default_posVelSrc.c_str());
      #endif
      if (userDefined)
         return (default_posVelSrc == Gmat::POS_VEL_SOURCE_STRINGS[posVelSrc]);
      else  // for default, mods are made at the SolarSystem level
         return true;
   }
   if (id == CENTRAL_BODY)
   {
      return (default_centralBodyName == theCentralBodyName);
   }
   if (id == ORBIT_SPICE_KERNEL_NAME)
   {
      if (default_orbitSpiceKernelNames.size() != orbitSpiceKernelNames.size()) return false;
      for (unsigned int ii = 0; ii < default_orbitSpiceKernelNames.size(); ii++)
      {
         if (default_orbitSpiceKernelNames.at(ii) != orbitSpiceKernelNames.at(ii)) return false;
      }
      return true;
   }
   if (id == ROTATION_DATA_SRC)
   {
      return (default_rotationSrc == rotationSrc);
   }
//   if (id == TWO_BODY_DATE_FORMAT)
//   {
//      return (default_twoBodyFormat == twoBodyFormat);
//   }
//   if (id == TWO_BODY_STATE_TYPE)
//   {
//      return (default_twoBodyStateType == twoBodyStateType);
//   }
//   if (id == TWO_BODY_INITIAL_EPOCH)
//   {
//      #ifdef DEBUG_CB_CLOAKING_EPOCH
//            MessageInterface::ShowMessage(
//                  "In CB::IsParameterEqualToDefault (%s), twoBody epoch,  time %12.10f == time %12.10f ?  %s\n",
//                  instanceName.c_str(), default_twoBodyEpoch.Get(), twoBodyEpoch.Get(),
//                  (GmatMathUtil::IsEqual(default_twoBodyEpoch.Get(),twoBodyEpoch.Get())? "TRUE" : "FALSE"));
//      #endif
//      return (default_twoBodyEpoch == twoBodyEpoch);
////      return GmatMathUtil::IsEqual(default_twoBodyEpoch.Get(),twoBodyEpoch.Get());
//   }
//   if ((id == TWO_BODY_SMA)  || (id == TWO_BODY_ECC) || (id == TWO_BODY_INC) ||
//       (id == TWO_BODY_RAAN) || (id == TWO_BODY_AOP) || (id == TWO_BODY_TA) )
//   {
//      return (default_twoBodyKepler == twoBodyKepler); // do we need an IsEqual for vectors?
//   }
//   if (id == ORIENTATION_DATE_FORMAT)
//   {
//      return (default_orientationDateFormat == orientationDateFormat);
//   }
   if (id == ORIENTATION_EPOCH)
   {
      #ifdef DEBUG_CB_CLOAKING_EPOCH
            MessageInterface::ShowMessage(
                  "In CB::IsParameterEqualToDefault (%s), orientation epoch,  time %12.10f == time %12.10f ?  %s\n",
                  instanceName.c_str(), default_orientationEpoch.Get(), orientationEpoch.Get(),
                  (GmatMathUtil::IsEqual(default_orientationEpoch.Get(),orientationEpoch.Get())? "TRUE" : "FALSE"));
      #endif
      return (default_orientationEpoch == orientationEpoch);
   }
   if ((id == SPIN_AXIS_RA_CONSTANT)  || (id == SPIN_AXIS_RA_RATE) || (id == SPIN_AXIS_DEC_CONSTANT) ||
       (id == SPIN_AXIS_DEC_RATE)     || (id == ROTATION_CONSTANT) || (id == ROTATION_RATE) )
   {
      return (default_orientation == orientation);
   }
   if (id == TEXTURE_MAP_FILE_NAME)
      return (default_textureMapFileName == textureMapFileName);
   if (id == VIEW_3D_MODEL_FILE_NAME)
      return (view3dModelFileName == "");
   if (id == VIEW_3D_MODEL_OFFSET_X)
      return view3dModelOffsetX == 0.0;
   if (id == VIEW_3D_MODEL_OFFSET_Y)
      return view3dModelOffsetY == 0.0;
   if (id == VIEW_3D_MODEL_OFFSET_Z)
      return view3dModelOffsetZ == 0.0;
   if (id == VIEW_3D_MODEL_ROTATION_X)
      return view3dModelRotationX == 0.0;
   if (id == VIEW_3D_MODEL_ROTATION_Y)
      return view3dModelRotationY == 0.0;
   if (id == VIEW_3D_MODEL_ROTATION_Z)
      return view3dModelRotationZ == 0.0;
   if (id == VIEW_3D_MODEL_SCALE)
      return view3dModelScale == 10.0;
   
   return SpacePoint::IsParameterEqualToDefault(id);
}

//------------------------------------------------------------------------------
// bool IsParameterValid(const Integer id, const std::string &value)
//------------------------------------------------------------------------------
/**
 * @see GmatBase
 */
//------------------------------------------------------------------------------
bool CelestialBody::IsParameterValid(const Integer id,
                                     const std::string &value)
{
   #ifdef DEBUG_VALIDATION
   MessageInterface::ShowMessage
      ("CelestialBody::IsParameterValid() entered, id=%d, value='%s'\n", id, value.c_str());
   #endif
   bool retval = true;
   Real realval;
   lastErrorMessage = "";
   
   if (id == VIEW_3D_MODEL_OFFSET_X || id == VIEW_3D_MODEL_OFFSET_Y || id == VIEW_3D_MODEL_OFFSET_Y ||
       id == VIEW_3D_MODEL_ROTATION_X || id == VIEW_3D_MODEL_ROTATION_Y || id == VIEW_3D_MODEL_ROTATION_Z ||
       id == VIEW_3D_MODEL_SCALE)
   {
      if (GmatStringUtil::ToReal(value, realval))
      {
         retval = IsRealParameterValid(id, realval, false);
      }
      else
      {
         retval = false;
         lastErrorMessage = "*** ERROR *** The value of " + value + " for field \"" +
            GetParameterText(id) + "\" on object \"" + instanceName + "\" is not valid.  "
            "The allowed values are Real number.\n";
      }
   }
   else if (id == TEXTURE_MAP_FILE_NAME)
   {
      #ifdef DEBUG_VALIDATION
      MessageInterface::ShowMessage("   Validating TEXTURE_MAP_FILE_NAME\n");
      #endif
      if (value == "" || value == "GenericCelestialBody.jpg")
         retval = true;
      else if (!SetTextureMapFileName(value, false, true))
         retval = false;
   }
   else if (id == VIEW_3D_MODEL_FILE_NAME)
   {
      #ifdef DEBUG_VALIDATION
      MessageInterface::ShowMessage("   Validating VIEW_3D_MODEL_FILE_NAME\n");
      #endif
      if (value == "")
         retval = true;
      else if (!Set3dModelFileName(value, false, true))
         retval = false;
   }
   
   #ifdef DEBUG_VALIDATION
   MessageInterface::ShowMessage
      ("CelestialBody::IsParameterValid() returning %d\n", retval);
   #endif
   return retval;
}

//------------------------------------------------------------------------------
// bool IsParameterValid(const std::string &label, const std::string &value)
//------------------------------------------------------------------------------
/**
 * @see GmatBase
 */
//------------------------------------------------------------------------------
bool CelestialBody::IsParameterValid(const std::string &label,
                                     const std::string &value)
{
   #ifdef DEBUG_VALIDATION
   MessageInterface::ShowMessage
      ("CelestialBody::IsParameterValid() entered, label='%s', value='%s'\n",
       label.c_str(), value.c_str());
   #endif
   return IsParameterValid(GetParameterID(label), value);
}

//------------------------------------------------------------------------------
// bool WriteEmptyStringParameter(const Integer id) const
//------------------------------------------------------------------------------
bool CelestialBody::WriteEmptyStringParameter(const Integer id) const
{
   if (id == VIEW_3D_MODEL_FILE_NAME)
      return true;
   else
      return SpacePoint::WriteEmptyStringParameter(id);
}

//------------------------------------------------------------------------------
// bool CelestialBody::IsParameterEqualToDefault(const Integer id) const
//------------------------------------------------------------------------------
/**
 * @see GmatBase
 */
//------------------------------------------------------------------------------
bool CelestialBody::SaveAllAsDefault()
{
   SpacePoint::SaveAllAsDefault();
   
   default_equatorialRadius       = equatorialRadius;
   default_flattening             = flattening;
   default_mu                     = mu;
   default_posVelSrc              = Gmat::POS_VEL_SOURCE_STRINGS[posVelSrc];
   default_centralBodyName        = theCentralBodyName;
   default_orbitSpiceKernelNames       = orbitSpiceKernelNames;
   default_rotationSrc            = rotationSrc; 
//   default_twoBodyFormat          = twoBodyFormat;
//   default_twoBodyStateType       = twoBodyStateType;
   default_twoBodyEpoch           = twoBodyEpoch;
   default_twoBodyKepler          = twoBodyKepler;
//   default_orientationDateFormat  = orientationDateFormat;
   default_orientationEpoch       = orientationEpoch;
   default_orientation            = orientation;
   default_textureMapFileName     = textureMapFileName;
   
   return true;
}

//------------------------------------------------------------------------------
// bool CelestialBody::SaveParameterAsDefault(const Integer id)
//------------------------------------------------------------------------------
/**
 * @see GmatBase
 */
//------------------------------------------------------------------------------
bool CelestialBody::SaveParameterAsDefault(const Integer id)
{
   if (id == EQUATORIAL_RADIUS)
   {
      default_equatorialRadius = equatorialRadius;
      return true;
   }
   if (id == FLATTENING)
   {
      default_flattening = flattening;
      return true;
   }
   if (id == MU)
   {
      default_mu = mu;
      return true;
   } 
   if (id == POS_VEL_SOURCE)
   {
      default_posVelSrc = Gmat::POS_VEL_SOURCE_STRINGS[posVelSrc];
      return true;
   }
   if (id == CENTRAL_BODY)
   {
      default_centralBodyName = theCentralBodyName;
      return true;
   }
   if (id == ORBIT_SPICE_KERNEL_NAME)
   {
      default_orbitSpiceKernelNames = orbitSpiceKernelNames;
      return true;
   }
   if (id == ROTATION_DATA_SRC)
   {
      default_rotationSrc = rotationSrc;
      return true;
   }
//   if (id == TWO_BODY_DATE_FORMAT)
//   {
//      default_twoBodyFormat = twoBodyFormat;
//      return true;
//   }
//   if (id == TWO_BODY_STATE_TYPE)
//   {
//      default_twoBodyStateType = twoBodyStateType;
//      return true;
//   }
//   if (id == TWO_BODY_INITIAL_EPOCH)
//   {
//      default_twoBodyEpoch = twoBodyEpoch;
//      return true;
//   }
//   if ((id == TWO_BODY_SMA)  || (id == TWO_BODY_ECC) || (id == TWO_BODY_INC) ||
//       (id == TWO_BODY_RAAN) || (id == TWO_BODY_AOP) || (id == TWO_BODY_TA) )
//   {
//      default_twoBodyKepler = twoBodyKepler;
//      return true;
//   }
//   if (id == ORIENTATION_DATE_FORMAT)
//   {
//      default_orientationDateFormat = orientationDateFormat;
//      return true;
//   }
   if (id == ORIENTATION_EPOCH)
   {
      default_orientationEpoch = orientationEpoch;
      return true;
   }
   if ((id == SPIN_AXIS_RA_CONSTANT)  || (id == SPIN_AXIS_RA_RATE) || (id == SPIN_AXIS_DEC_CONSTANT) ||
       (id == SPIN_AXIS_DEC_RATE)     || (id == ROTATION_CONSTANT) || (id == ROTATION_RATE) )
   {
      default_orientation = orientation;
      return true;
   }
   if (id == TEXTURE_MAP_FILE_NAME)
   {
      default_textureMapFileName = textureMapFileName;
      return true;
   }
   
   return SpacePoint::SaveParameterAsDefault(id);
}



//---------------------------------------------------------------------------
//  void Copy(const GmatBase* orig)
//---------------------------------------------------------------------------
/**
 * Set this instance to match the one passed in.
 * 
 * @param <orig> The object that is being copied.
 */
//---------------------------------------------------------------------------
//void CelestialBody::Copy(const GmatBase* orig)
//{
//   #ifdef DEBUG_CB_COPY
//      MessageInterface::ShowMessage("Entering CB::Copy: copying from %p to %p\n",
//            orig, this);
//   #endif
//   operator=(*((CelestialBody *)(orig)));
//}


//------------------------------------------------------------------------------
// protected methods
//------------------------------------------------------------------------------
//------------------------------------------------------------------------------
//  void  InitializeBody(std::string withBodyType)
//------------------------------------------------------------------------------
/**
 * This method initializes the data values for the body.
 *
 * @param <withBodyType> string representation of the body type.
 *
 */
//------------------------------------------------------------------------------
void CelestialBody::InitializeBody(std::string withBodyType)
{
   #ifdef DEBUG_CB_INIT
   MessageInterface::ShowMessage
      ("CelestialBody::InitializeBody(%s) entered\n", withBodyType.c_str());
   #endif
   
   // assuming derived classes will fill in all the specific things with
   // appropriate default values
   usePotentialFile  = false;
   potentialFileName = "";
   sourceFilename    = "";
   theSourceFile     = NULL;
   stateTime         = 0.0;
   state             = Rvector6(0.0,0.0,0.0,0.0,0.0,0.0);
   angularVelocity   = Rvector3(0.0,0.0,7.29211585530e-5); // correct, for a default?
   potentialFileRead = false;
   atmModel          = NULL;
   for (Integer i = 0; i < (Integer) Gmat::BodyTypeCount; i++)
      if (withBodyType == Gmat::BODY_TYPE_STRINGS[i]) bodyType = (Gmat::BodyType) i;

   isFirstTimeMu = true;
   isFirstTimeRadius = true;
   rotationSrc = Gmat::IAU_SIMPLIFIED;
}

//------------------------------------------------------------------------------
//  bool  DeterminePotentialFileNameFromStartup()
//------------------------------------------------------------------------------
/**
 * This method determines the potential file name from the startup file.
 *
 * @return success flag
 *
 */
//------------------------------------------------------------------------------
bool CelestialBody::DeterminePotentialFileNameFromStartup()
{
   //loj: 3/23/06 set default potential file name from the startup file.
   try
   {
      FileManager *fm = FileManager::Instance();
      std::string potfile = GmatStringUtil::ToUpper(instanceName) + "_POT_FILE";
      
      // Use FileManager::FindPath() for potential file (LOJ: 2014.06.25)
      //std::string filename = fm->GetFullPathname(potfile);
      std::string filename = fm->FindPath("", potfile, true);
      
      #if DEBUG_CELESTIAL_BODY
      MessageInterface::ShowMessage
         ("Planet::DeterminePotentialFileNameFromStartup() body=%s, potfilename=%s\n", instanceName.c_str(),
          filename.c_str());
      #endif
      
      potentialFileName = filename;
   }
   catch (BaseException &e)
   {
      MessageInterface::ShowMessage(e.GetFullMessage());
   }
   return true;
}



//------------------------------------------------------------------------------
//  bool  ReadPotentialFile()
//------------------------------------------------------------------------------
/**
 * This method reads the potential file, if requested, and gets the mu, radius,
 * and spherical harmonic coefficients, sij and cij, from the file.
 *
 * @return flag indicating success of the file-reading.
 *
 */
//------------------------------------------------------------------------------
bool CelestialBody::ReadPotentialFile()
{
   if (potentialFileRead) return true;
   //if (potentialFileName == "") return false;
   if (potentialFileNameFullPath == "") return false;
   
   Integer fileDeg, fileOrd;
   try
   {
      //if (!GravityFileUtil::GetFileInfo(potentialFileName, fileDeg, fileOrd, mu,
      if (!GravityFileUtil::GetFileInfo(potentialFileNameFullPath, fileDeg, fileOrd, mu,
                                        equatorialRadius))
      {
         throw SolarSystemException
            ("Error reading mu and equatorial radius of " + instanceName
             //+ " from "+ potentialFileName);
             + " from "+ potentialFileNameFullPath);
      }
   }
   catch (BaseException &e)
   {
      throw SolarSystemException(e.GetFullMessage());
   }
   
   
   potentialFileRead = true;
   // recompute polar radius
   polarRadius = (1.0 - flattening) * equatorialRadius;
   // recompute mass
   mass = mu / GmatPhysicalConstants::UNIVERSAL_GRAVITATIONAL_CONSTANT;
   return true;
}


//------------------------------------------------------------------------------
//  bool IsBlank(char* aLine)
//------------------------------------------------------------------------------
/**
 * This method returns true if the string is empty or is all white space.
 *
 * @return true if blank; false otherwise
 */
//------------------------------------------------------------------------------
bool CelestialBody::IsBlank(char* aLine)
{
   Integer i;
   for (i=0;i<(int)strlen(aLine);i++)
   {
      if (!isspace(aLine[i])) return false;
   }
   return true;
}


//------------------------------------------------------------------------------
//  Real GetJulianDaysFromTTEpoch(const A1Mjd &forTime)
//------------------------------------------------------------------------------
/**
 * This method computes the Julian days from the TT Epoch.
 *
 * @param forTime   the time for which to return the days from TT epoch
 *
 * @return number of Julian days since the TT J2000 epoch.
 *
 * @note This method computes the Julian Days from the TT epoch.  The original
 * intent of this method was to compute the Julian days from the TCB epoch.
 */
//------------------------------------------------------------------------------
Real CelestialBody::GetJulianDaysFromTTEpoch(const A1Mjd &forTime) const
{
   Real mjdTT  = TimeConverterUtil::Convert(forTime.Get(),
                                            TimeConverterUtil::A1MJD,
                                            TimeConverterUtil::TTMJD, 
                                            GmatTimeConstants::JD_JAN_5_1941);
   return (mjdTT + GmatTimeConstants::JD_JAN_5_1941 - 
           GmatTimeConstants::JD_OF_J2000);
}

//------------------------------------------------------------------------------
//  Real GetJulianDaysFromTDBEpoch(const A1Mjd &forTime)
//------------------------------------------------------------------------------
/**
 * This method computes the Julian days from the TDB Epoch.
 *
 * @param forTime  the time for which to compute the days from epoch
 *
 * @return number of Julian days since the TDB epoch.
 *
 * @note This method computes the Julian Days from the TDB epoch.
 */
//------------------------------------------------------------------------------
Real CelestialBody::GetJulianDaysFromTDBEpoch(const A1Mjd &forTime) const
{
   #ifdef DEBUG_CB_TDB_TIME
      MessageInterface::ShowMessage(
         "CB::GetJulianDaysFromTDBEpoch: body =  %s; forTime = %le\n",
         instanceName.c_str(), forTime.Get());
   #endif
   Real mjdTDB  = TimeConverterUtil::Convert(forTime.Get(),
                                            TimeConverterUtil::A1MJD,
                                            TimeConverterUtil::TDBMJD,
                                            GmatTimeConstants::JD_JAN_5_1941);
   // JD_OF_J2000 (2451545.0) TDB is the reference epoch indicated in
   // Seidelmann et. al. "Report of the IAU/IAGWorking Group on Cartographic
   // Coordinates and Rotational Elements" for use with cartographic data
   return (mjdTDB + GmatTimeConstants::JD_JAN_5_1941 -
          GmatTimeConstants::JD_OF_J2000);

}

//------------------------------------------------------------------------------
//  Rvector6 ComputeTwoBody(const A1Mjd &forTime)
//------------------------------------------------------------------------------
/**
 * This method computes the position and velocity at time forTime
 *
 * @param <forTime>  time at which to compute the two-body state
 *
 * @return body state (position, velocity) at time forTime, with respect to
 *         the Earth.
 *
 */
//------------------------------------------------------------------------------
Rvector6 CelestialBody::ComputeTwoBody(const A1Mjd &forTime)
{
   #ifdef DEBUG_TWO_BODY

   MessageInterface::ShowMessage
      ("CelestialBody::ComputeTwoBody() this=<%p> %s, "
       "theCentralBody=<%p> %s\n", this, GetName().c_str(), theCentralBody,
       theCentralBodyName.c_str());
   #endif
   
   // Since we want the state in MJ2000Eq Earth-centered
   if (instanceName == SolarSystem::EARTH_NAME) 
      return Rvector6(0.0,0.0,0.0,0.0,0.0,0.0);
   #ifdef DEBUG_TWO_BODY
   MessageInterface::ShowMessage
      ("CelestialBody::ComputeTwoBody() before call to centralBody->GetState()\n");
   if (!theCentralBody) 
      MessageInterface::ShowMessage("The central body (%s) for %s is NULL!!!!\n", 
            theCentralBodyName.c_str(), instanceName.c_str());
   #endif
   
   Rvector6 cbState = theCentralBody->GetState(forTime);
   #ifdef DEBUG_TWO_BODY
   MessageInterface::ShowMessage
      ("CelestialBody::ComputeTwoBody() AFTER call to centralBody->GetState()\n");
   #endif
   
   return (KeplersProblem(forTime) + cbState);    
}


//------------------------------------------------------------------------------
//  Rvector6 KeplersProblem(const A1Mjd &forTime)
//------------------------------------------------------------------------------
/**
 * This method computes the position and velocity at time forTime
 *
 * @return body state (position, velocity) at time forTime, with respect to
 *         the central body.
 *
 * @note This is based on Algorithm 8 on pp. 101-2 (and algorithm 1 on
 *       p. 71) of "Fundamentals of Astrodynamics and Applications",
 *       Second Edition, by David A. Vallado.
 */
//------------------------------------------------------------------------------
Rvector6 CelestialBody::KeplersProblem(const A1Mjd &forTime)
{
   #ifdef DEBUG_TWO_BODY
         MessageInterface::ShowMessage
            ("CelestialBody::KeplersProblem() this=<%p> %s, "
             "theCentralBody=<%p> %s\n", this, GetName().c_str(), theCentralBody,
             theCentralBodyName.c_str());
         MessageInterface::ShowMessage("newTwoBody = %s\n", (newTwoBody? "TRUE" : "FALSE"));
         MessageInterface::ShowMessage("keplerian elements = %12.10f   %12.10f   %12.10f   %12.10f   %12.10f   %12.10f\n",
               twoBodyKepler[0],twoBodyKepler[1],twoBodyKepler[2],twoBodyKepler[3],twoBodyKepler[4],twoBodyKepler[5]); 
         MessageInterface::ShowMessage("epoch = %12.10f\n",twoBodyEpoch.Get()); 
         MessageInterface::ShowMessage("forTime = %12.10f\n",forTime.Get());         
   #endif

   Real     cbMu  = theCentralBody->GetGravitationalConstant() + mu;
   Rvector6 cart;  // or MA???
   Real     dTime;
   
   if ((!newTwoBody) && 
       (Abs(forTime.Subtract(prevTwoBodyEpoch) * GmatTimeConstants::SECS_PER_DAY) <= KEPLER_TOL))
      return prevTwoBodyState;
   cart  = StateConversionUtil::KeplerianToCartesian(cbMu, twoBodyKepler, "TA");  // or MA???
   dTime = forTime.Subtract(twoBodyEpoch) * GmatTimeConstants::SECS_PER_DAY;
   #ifdef DEBUG_TWO_BODY
      MessageInterface::ShowMessage("cbMu = %12.14f    dTime = %12.14f\n", cbMu, dTime);
   #endif

   //   // check for number of revs and reduce dTime if necessary (this does not work for the Sun)
   if (instanceName != SolarSystem::SUN_NAME)
   {
      Real sma = twoBodyKepler[0];   // SMA, which should be constant
      Real T = 2 * GmatMathConstants::PI * Sqrt(Abs(sma)*Abs(sma)*Abs(sma)/cbMu);
   
      Real revs = dTime/T;
      dTime = dTime - T * Fix(revs);
      #ifdef DEBUG_TWO_BODY
         MessageInterface::ShowMessage("After Fix, sma = %12.14f    T = %12.14f     revs = %12.14f    dTime = %12.14f\n", 
               sma, T, revs, dTime);
      #endif
   }


   #ifdef DEBUG_TWO_BODY
      MessageInterface::ShowMessage("r0 = %12.16f   %12.16f   %12.16f  & v0 = %12.16f   %12.16f   %12.16f\n",
            cart[0], cart[1], cart[2], cart[3], cart[4], cart[5]);
   #endif
   Rvector3 r0     = cart.GetR();
   Rvector3 v0     = cart.GetV();

   Real     rMag0  = r0.GetMagnitude();
   Real     vMag0  = v0.GetMagnitude();
   Real     alpha = (-(vMag0 * vMag0) / cbMu) + (2.0 / rMag0);
   Real     x0    = -999.999;
   Real     rDotv = r0 * v0;  // dot product
   
   #ifdef DEBUG_TWO_BODY
      MessageInterface::ShowMessage("alpha = %12.14f    rDotv = %12.14f\n", alpha, rDotv);
      MessageInterface::ShowMessage("KEPLER_TOL = %12.14f\n", KEPLER_TOL);
   #endif
   // Determine initial guess .......
   // for a circle or ellipse
   if (alpha > KEPLER_TOL)  
   {
      #ifdef DEBUG_TWO_BODY
         MessageInterface::ShowMessage(" -------- circle or ellipse\n");
      #endif
      x0 = Sqrt(cbMu) * dTime * alpha;

      if (Abs(alpha - 1.0) <= KEPLER_TOL)
      {
         // match Vallado matlab code 
         x0 = x0 * 0.97;
      }
   }
   // for a parabola
   else if (Abs(alpha) < KEPLER_TOL)
   {
      #ifdef DEBUG_TWO_BODY
         MessageInterface::ShowMessage(" -------- parabola\n");
      #endif
      Rvector3 h     = Cross(r0, v0);
      Real     hMag0 = h.GetMagnitude();
      Real     p     = (hMag0 * hMag0) / cbMu;
      Real     s     = (1.0 / 2.0) * (GmatMathConstants::PI_OVER_TWO -
                       ATan(3.0 * Sqrt(cbMu / (p * p * p)) * dTime));
      Real     w     = ATan(Pow(Tan(s), (1.0 / 3.0)));
      x0             = Sqrt(p) * 2.0 / Tan(2.0 * w);
      alpha          = 0.0;   // per kepler function by Vallado
   }
   // for a hyperbola
   else if (alpha < -KEPLER_TOL)
   {
      #ifdef DEBUG_TWO_BODY
         MessageInterface::ShowMessage(" -------- hyperbola\n");
      #endif
      Real     a     = 1.0 / alpha;
      Integer  signT = SignOf(dTime);
      Real     num   = -2.0 * cbMu * alpha * dTime;
      Real     den   = rDotv + signT * Sqrt(-cbMu * a) * 
                       (1.0 - rMag0 * alpha);
      x0             = signT * Sqrt(-a) * Ln(num / den);
   }
   #ifdef DEBUG_TWO_BODY
      MessageInterface::ShowMessage("x0 = %12.14f\n", x0);
   #endif
   // Loop until difference falls within tolerance
   Real    rVal    = 0.0;
   Real    xNew    = 0.0;
   Real    xn      = x0;
   Real    psi     = xn * xn * alpha;
   Real    sqrtPsi = 0.0;
   bool    done    = false;
   Real    c2      = -999.99;
   Real    c3      = -999.99;
   Integer counter = 0;

   while (!done)
   {
      psi = xn * xn * alpha;
      
      // compute c2 and c3, per Algorithm 1, p. 71
      if (psi > KEPLER_TOL)
      {
         sqrtPsi = Sqrt(psi);
         c2      = (1.0 - Cos(sqrtPsi)) / psi;
         c3      = (sqrtPsi - Sin(sqrtPsi)) / Sqrt(psi * psi * psi);
      }
      else if (psi < -KEPLER_TOL)
      {
         sqrtPsi = Sqrt(-psi);
         c2      = (1.0 - Cosh(sqrtPsi)) / psi;
         c3      = (Sinh(sqrtPsi) - sqrtPsi) / Sqrt((-psi) * (-psi) * (-psi));
      }
      else
      {
         c2      = 1.0 / 2.0;
         c3      = 1.0 / 6.0;
      }
      rVal = (xn * xn * c2) + (rDotv / Sqrt(cbMu)) * xn * (1.0 - psi * c3) +
              rMag0 * (1.0 - psi * c2);
      #ifdef DEBUG_TWO_BODY
         MessageInterface::ShowMessage(" at start of loop,xn = %12.14f and psi = %12.14f\n",  xn, psi);
         MessageInterface::ShowMessage("                  c2 = %12.14f and c3 = %12.14f\n",  c2, c3);
         MessageInterface::ShowMessage("                  rVal = %12.14ff\n",  rVal);
      #endif
                
      xNew = xn + ((Sqrt(cbMu) * dTime) - (xn * xn * xn * c3) - 
                   (rDotv / Sqrt(cbMu)) * (xn * xn * c2) -
                   rMag0 * xn * (1.0 - psi *c3)) / rVal;
      
      if (Abs(xn - xNew) < KEPLER_TOL) done = true;
      xn = xNew;
      counter++;
   }
   #ifdef DEBUG_TWO_BODY
      MessageInterface::ShowMessage(" after loop is done, xNew = %12.14f    xn = %12.14f\n", xNew, xn);
   #endif

   if (counter >= KEPLER_MAX_ITERATIONS)
   {
      std::stringstream ss("");
      ss << "Kepler's Problem (TwoBodyPropagation) for Body \"" << instanceName <<
            "\" is not converging after " << KEPLER_MAX_ITERATIONS << "iterations.";
      throw SolarSystemException(ss.str());
   }
   
   Real f     = 1.0 - ((xn * xn) / rMag0) * c2;
   Real g     = dTime - ((xn * xn * xn) / Sqrt(cbMu)) * c3;
   Rvector3 r = f * r0 + g * v0;
   // recompute magnitude, etc. (per Vallado matlab code)
   Real rMagNew = r.GetMagnitude();
   // Mods to this computation per Vallado matlab code
   Real gDot  = 1.0 - ((xn * xn) / rMagNew) * c2;
   Real fDot  = (Sqrt(cbMu) / (rMagNew * rMag0)) * xn * (psi * c3 - 1.0);
   Rvector3 v = fDot * r0 + gDot * v0;

   
   #ifdef DEBUG_TWO_BODY
      MessageInterface::ShowMessage("f    = %12.14f, g    = %12.14f\n", f, g);
      MessageInterface::ShowMessage("fDot = %12.14f, gDot = %12.14f\n", fDot, gDot);
      MessageInterface::ShowMessage("Computed quantity (f*gDot - fDot * g) = %12.14f\n", (Abs(f * gDot - g * fDot)));
   #endif

   if (!IsEqual(Abs(f * gDot - g * fDot), 1.0, 1.0e-5))  // e-5 per S. Hughes 2009.02.19
      throw SolarSystemException(
            "Error performing two body propagation for body "
            + instanceName);
   
   Rvector6 newState(r,v);
   prevTwoBodyEpoch = forTime;
   prevTwoBodyState = newState;
   newTwoBody       = false;
   // debug stuff
   #ifdef DEBUG_TWO_BODY
      MessageInterface::ShowMessage("At end of TwoBody computation, new r  = %12.14f    %12.14f    %12.14f\n",
            newState[0], newState[1], newState[2]);
      MessageInterface::ShowMessage("At end of TwoBody computation, new v  = %12.14f    %12.14f    %12.14f\n",
            newState[3], newState[4], newState[5]);
   #endif
   
   return newState;
}

//------------------------------------------------------------------------------
//  bool SetUpSPICE()
//------------------------------------------------------------------------------
/**
 * This method sets up the interface to the SPICE code.
 *
 * @return success flag
 *
 */
//------------------------------------------------------------------------------
bool CelestialBody::SetUpSPICE()
{
#ifdef __USE_SPICE__
   #ifdef DEBUG_CB_SPICE
      MessageInterface::ShowMessage(
            "Entering SetUpSpice for body %s with source = %s and orbitSpiceKernelNames:\n",
            instanceName.c_str(), Gmat::POS_VEL_SOURCE_STRINGS[posVelSrc].c_str());
      for (unsigned int ii = 0; ii < orbitSpiceKernelNames.size(); ii++)
         MessageInterface::ShowMessage("     %s\n", (orbitSpiceKernelNames.at(ii)).c_str());
      MessageInterface::ShowMessage("   posVelSrc = %s\n", Gmat::POS_VEL_SOURCE_STRINGS[posVelSrc].c_str());
      if (kernelReader == NULL)
         MessageInterface::ShowMessage("   kernelReader is NULL\n");
      if (theSolarSystem == NULL)
         MessageInterface::ShowMessage("   theSolarSystem is NULL\n");
   #endif
   // Need to do this each time, even if the source is not SPICE, because we may
   // be doing Event Location (which currently uses SPICE each time).  2015.08.28 WCS
//   if (posVelSrc != Gmat::SPICE) return false;
   if (kernelReader == NULL) kernelReader = theSolarSystem->GetSpiceOrbitKernelReader();
   if (kernelReader == NULL)
   {
      std::string errmsg = "ERROR - SpiceKernelReader not set for body \"";
      errmsg += instanceName + "\"\n";
      throw SolarSystemException(errmsg);
   }
   #ifdef DEBUG_CB_SPICE
      if (kernelReader == NULL)
         MessageInterface::ShowMessage("   kernelReader is STILL NULL\n");
   #endif
   mainSPK = theSolarSystem->GetStringParameter("SPKFilename");
   mainPCK = theSolarSystem->GetStringParameter("PCKFilename");
   if (orbitSpiceKernelNames.empty())
   {
      if (mainSPK == "")
      {
         std::string errmsg = "ERROR - SPICE selected as source for body \"";
         errmsg += instanceName + "\", but no SPK file(s) specified.\n";
         throw SolarSystemException(errmsg);
      }
      else  // outer planets/moons, comets, and asteroids must have their own SPK file specified
      {
         if (!msgWritten && !NeedsOnlyMainSPK())
         {
            MessageInterface::ShowMessage(
               "An additional body-specific SPK may be required for body %s or its satellites.\n",
               instanceName.c_str());
            msgWritten = true;
         }
      }
   }
   // make sure the "main" Solar System Kernel(s) are loaded first!!!
   theSolarSystem->LoadSpiceKernels();

   // Call SpacePoint method to load the specified kernels - we want orbit,
   // attitude (pck), and frame kernels loaded for celestial bodies
   LoadNeededKernels(true, true, true, false);

//   // now load the spice kernels specified for this body
//   for (unsigned int ii = 0; ii < orbitSpiceKernelNames.size(); ii++)
//   {
//      #ifdef DEBUG_CB_SPICE
//         char *path=NULL;
//         size_t size = 0;
//         path=getcwd(path,size);
//         MessageInterface::ShowMessage("   CURRENT PATH = %s\n", path);
//         MessageInterface::ShowMessage("   now checking %s ...\n", orbitSpiceKernelNames.at(ii).c_str());
//      #endif
//      if (!(kernelReader->IsLoaded(orbitSpiceKernelNames.at(ii))))
//      {
//         try
//         {
//            kernelReader->LoadKernel(orbitSpiceKernelNames.at(ii));
//            #ifdef DEBUG_CB_SPICE
//               MessageInterface::ShowMessage("   kernelReader has loaded file %s\n",
//                     (orbitSpiceKernelNames.at(ii)).c_str());
//            #endif
//         }
//         catch (UtilityException &ue)
//         {
//            #ifdef DEBUG_CB_SPICE
//               MessageInterface::ShowMessage("   EXCEPTION caught with message: %s ...\n", ue.GetFullMessage().c_str());
//            #endif
//            // try again with path name if no path found
//            std::string spkName = orbitSpiceKernelNames.at(ii);
//            if (spkName.find("/") == spkName.npos &&
//                spkName.find("\\") == spkName.npos)
//            {
//               // Changed to use PLANETARY_EPHEM_SPK_PATH (LOJ: 2014.06.18)
//               //std::string spkPath =
//               //   FileManager::Instance()->GetFullPathname(FileManager::SPK_PATH);
//               std::string spkPath =
//                  FileManager::Instance()->GetFullPathname(FileManager::PLANETARY_EPHEM_SPK_PATH);
//               spkName = spkPath + spkName;
//               try
//               {
//                  #ifdef DEBUG_CB_SPICE
//                     MessageInterface::ShowMessage("   now attempting to load %s ...\n", spkName.c_str());
//                  #endif
//                  kernelReader->LoadKernel(spkName);
//                  #ifdef DEBUG_CB_SPICE
//                  MessageInterface::ShowMessage("   kernelReader has loaded file %s\n",
//                     spkName.c_str());
//                  #endif
//               }
//               catch (UtilityException &)
//               {
//                  MessageInterface::ShowMessage("ERROR loading kernel %s\n",
//                     (spkName.c_str()));
//                  throw; // rethrow the exception, for now
//               }
//            }
//            else
//            {
//               MessageInterface::ShowMessage("ERROR loading kernel %s\n",
//                  (orbitSpiceKernelNames.at(ii).c_str()));
//               throw; // rethrow the exception, for now
//            }
//         }
//      }
//   }
   // get the NAIF Id from the Spice Kernel(s)   @todo - should this be moved to SpacePoint?
   if (!naifIdSet)
   {
      // SPICE calls Earth's moon "Moon" ; GMAT calls Earth's moon "Luna"
      Integer spiceNaifId; 
      if (instanceName == SolarSystem::MOON_NAME)
         spiceNaifId = kernelReader->GetNaifID("MOON"); 
      else if (instanceName == GmatSolarSystemDefaults::SOLAR_SYSTEM_BARYCENTER_NAME)
         spiceNaifId = kernelReader->GetNaifID("SSB");
      else
      {
            spiceNaifId = kernelReader->GetNaifID(instanceName, false);
            // if not found with the instanceName, try using the NAIF ID
            if (spiceNaifId == 0)   // SSB is 0, but that's handled above
            {
               std::stringstream ss("");
               ss << naifId;
               naifName = ss.str();
               spiceNaifId = naifId;
            }
            else
            {
               naifName = instanceName;
            }
      }
      
      if ((naifId != UNDEFINED_NAIF_ID) && (spiceNaifId != naifId))
      {
         std::stringstream ss("");
         ss << "Overriding input NAIF ID for body \"" << instanceName <<
               "\" with NAIF ID (" << spiceNaifId << ") from SPICE kernel.\n";
         //         MessageInterface::PopupMessage(Gmat::WARNING_, ss.str());
         MessageInterface::ShowMessage(ss.str().c_str());
      }
      naifId    = spiceNaifId;
      naifIdObserver = kernelReader->GetNaifID(j2000BodyName, false);
      naifIdSet = true;
   }
   #ifdef DEBUG_CB_SPICE
      MessageInterface::ShowMessage("   naifID for body %s is %d\n",
            instanceName.c_str(), naifId);
   #endif

   spiceSetupDone = true;
#endif
   return true;
}

//------------------------------------------------------------------------------
//  bool NeedsOnlyMainSPK()
//------------------------------------------------------------------------------
/**
 * This method returns a flag indicating whether or not this body needs only the
 * main planetary SPK.
 *
 * @return true if body needds only the main planetary SPK; false, otherwise
 *
 */
//------------------------------------------------------------------------------
bool CelestialBody::NeedsOnlyMainSPK()
{
   return false;
}

//------------------------------------------------------------------------------
// bool IsRealParameterValid(Integer id, Real realval, bool throwError = true)
//------------------------------------------------------------------------------
/**
 * Chekcs if input real value is valid.
 *
 * @param id  The Parameter ID
 * @param realval The real value
 * @param throwError  Throws an exception if this flag is true [true]
 */
//------------------------------------------------------------------------------
bool CelestialBody::IsRealParameterValid(Integer id, Real realval, bool throwError)
{
   #ifdef DEBUG_VALIDATION
   MessageInterface::ShowMessage
      ("CelestialBody::IsRealParameterValid() entered, id=%d, realval=%f\n", id, realval);
   #endif
   
   bool retval = true;
   lastErrorMessage = "";
   
   if (id == VIEW_3D_MODEL_OFFSET_X || id == VIEW_3D_MODEL_OFFSET_Y || id == VIEW_3D_MODEL_OFFSET_Y)
   {
      if (realval < -3.5 || realval > 3.5)
         retval = false;
      
      if (retval == false)
      {
         std::string strval = GmatStringUtil::ToString(realval, GetDataPrecision());
         lastErrorMessage = "*** ERROR *** The value of " + strval + " for field \"" + GetParameterText(id) +
            "\" on object \"" + instanceName + "\" is out of bounds.  "
            "The allowed values are: [-3.5 <= Real <= 3.5].\n";
      }
   }
   else if (id == VIEW_3D_MODEL_ROTATION_X || id == VIEW_3D_MODEL_ROTATION_Y || id == VIEW_3D_MODEL_ROTATION_Z)
   {
      if (realval < -180.0 || realval > 180.0)
         retval = false;
      
      if (retval == false)
      {
         std::string strval = GmatStringUtil::ToString(realval, GetDataPrecision());
         lastErrorMessage = "*** ERROR *** The value of " + strval + " for field \"" + GetParameterText(id) +
            "\" on object \"" + instanceName + "\" is out of bounds.  "
            "The allowed values are: [-180 <= Real <= 180].\n";
      }
   }
   else if (id == VIEW_3D_MODEL_SCALE)
   {
      if (realval < 0.001 || realval > 1000)
         retval = false;
      
      if (retval == false)
      {
         std::string strval = GmatStringUtil::ToString(realval, GetDataPrecision());
         lastErrorMessage = "*** ERROR *** The value of " + strval + " for field \"" + GetParameterText(id) +
            "\" on object \"" + instanceName + "\" is out of bounds.  "
            "The allowed values are: [0.001 <= Real <= 1000].\n";
      }
   }
   
   if (retval == false && throwError)
   {
      #ifdef DEBUG_VALIDATION
      MessageInterface::ShowMessage
         ("CelestialBody::IsRealParameterValid() throwing error:\n",
          lastErrorMessage.c_str());
      #endif
      throw SolarSystemException(lastErrorMessage);
   }
   
   #ifdef DEBUG_VALIDATION
   MessageInterface::ShowMessage
      ("CelestialBody::IsRealParameterValid() returning %d\n", retval);
   #endif
   return retval;
}

//------------------------------------------------------------------------------
// bool SetTextureMapFileName(const std::string &filename, bool writeWarning = false,
//                            bool validateOnly = false)
//------------------------------------------------------------------------------
/**
 * Sets full texture file name. If filename is non-blank and does not exist, it
 * will throw an exception. If filename is generic texture file name or blank, it
 * will set to generic texture file name.
 *
 * @return true if input fileName is valid texture file, false otherwise
 */
//------------------------------------------------------------------------------
bool CelestialBody::SetTextureMapFileName(const std::string &fileName, bool writeWarning,
                                          bool validateOnly)
{
   #ifdef DEBUG_TEXTURE_FILE
   MessageInterface::ShowMessage
      ("\nCelestialBody::SetTextureMapFileName() '%s' entered\n   fileName = '%s'\n   "
       "writeWarning = %d, validateOnly = %d\n", GetName().c_str(), fileName.c_str(),
       writeWarning, validateOnly);
   #endif
   
   bool retval = true;
   lastErrorMessage = "";
   FileManager *fm = FileManager::Instance();
   std::string actualFile = fileName;
   std::string actualPath;
   std::string bodyName = GetName();
   bool success = fm->GetTextureMapFile(fileName, bodyName, bodyName, actualFile, actualPath, writeWarning);
   lastErrorMessage = fm->GetLastFilePathMessage() + " texture map file";
   
   #ifdef DEBUG_TEXTURE_FILE
   MessageInterface::ShowMessage
      ("   After call to fm->GetTextureMapFile(), success = %d\n   lastErrorMessage = '%s'\n",
       success, lastErrorMessage.c_str());
   #endif
   
   if (success)
   {
      if (!validateOnly)
      {
         textureMapFileName = actualFile;
         textureMapFullPath = actualPath;
      }
   }
   else
   {
      retval = false;
      textureMapFullPath = "";
      std::string errMsg = lastErrorMessage;
      lastErrorMessage = "**** ERROR *** " + lastErrorMessage;
      if (writeWarning && !validateOnly)
         throw SolarSystemException(errMsg);
   }
   
   #ifdef DEBUG_TEXTURE_FILE
   MessageInterface::ShowMessage
      ("   textureMapFileName = '%s'\n   textureMapFullPath = '%s'\n",
       textureMapFileName.c_str(), textureMapFullPath.c_str());
   MessageInterface::ShowMessage
      ("CelestialBody::SetTextureMapFileName() returning %d\n", retval);
   #endif
   
   return retval;
}


//------------------------------------------------------------------------------
// bool Set3dModelFileName(const std::string &filename, bool writeWarning = false,
//                        bool validateOnly = false)
//------------------------------------------------------------------------------
/**
 * Sets full model file name. If filename is non-blank and does not exist, it
 * will throw an exception. If filename is blank, it will do nothing since
 * model file is optional.
 *
 * @return true if input fileName is valid texture file, false otherwise
 */
//------------------------------------------------------------------------------
bool CelestialBody::Set3dModelFileName(const std::string &fileName, bool writeWarning,
                                       bool validateOnly)
{
   #ifdef DEBUG_3D_MODEL_FILE
   MessageInterface::ShowMessage
      ("\nCelestialBody::Set3dModelFileName() '%s' entered\n   fileName = '%s'\n   "
       "writeWarning = %d, validateOnly = %d\n", GetName().c_str(), fileName.c_str(),
       writeWarning, validateOnly);
   #endif
   
   if (fileName == "")
   {
      if (!validateOnly)
         view3dModelFileFullPath = "";
      
      #ifdef DEBUG_3D_MODEL_FILE
      MessageInterface::ShowMessage
      ("   view3dModelFileName = '%s'\n   view3dModelFileFullPath = '%s'\n",
       view3dModelFileName.c_str(), view3dModelFileFullPath.c_str());
      MessageInterface::ShowMessage
         ("CelestialBody::Set3dModelFileName() returning true, fileName is blank and it's OK\n");
      #endif
      
      return true;
   }
   
   bool retval = true;
   lastErrorMessage = "";
   FileManager *fm = FileManager::Instance();
   std::string actualFile = fileName;
   std::string actualPath;
   std::string bodyName = GetName();
   bool success = fm->GetBody3dModelFile(fileName, bodyName, bodyName, actualFile, actualPath, writeWarning);
   lastErrorMessage = fm->GetLastFilePathMessage() + " 3d model file";
   
   #ifdef DEBUG_3D_MODEL_FILE
   MessageInterface::ShowMessage
      ("   After call to fm->GetModelFile(), success = %d\n   lastErrorMessage = '%s'\n",
       success, lastErrorMessage.c_str());
   #endif
   
   if (success)
   {
      if (!validateOnly)
      {
         view3dModelFileName = actualFile;
         view3dModelFileFullPath = actualPath;
      }
   }
   else
   {
      retval = false;
      view3dModelFileFullPath = "";
      std::string errMsg = lastErrorMessage;
      lastErrorMessage = "**** ERROR *** " + lastErrorMessage;
      if (writeWarning && !validateOnly)
         throw SolarSystemException(errMsg);
   }
   
   #ifdef DEBUG_3D_MODEL_FILE
   MessageInterface::ShowMessage
      ("   view3dModelFileName = '%s'\n   view3dModelFileFullPath = '%s'\n",
       view3dModelFileName.c_str(), view3dModelFileFullPath.c_str());
   MessageInterface::ShowMessage
      ("CelestialBody::Set3dModelFileName() returning %d\n", retval);
   #endif
   
   return retval;
}


//------------------------------------------------------------------------------
// private methods
//------------------------------------------------------------------------------


bool CelestialBody::LoadNeededKernels(bool orbit,  bool attitude,
                                      bool frame,  bool scClock)
{
#ifdef DEBUG_CB_SPICE
   MessageInterface::ShowMessage("   INLoadNeededKernels, size of attitudeSpiceKernelNames = %d\n",
         (Integer) attitudeSpiceKernelNames.size());
#endif

#ifdef __USE_SPICE__
   if (orbit)
   {
      for (unsigned int ii = 0; ii < orbitSpiceKernelNames.size(); ii++)
      {
         bool isItLoaded = kernelReader->IsLoaded(orbitSpiceKernelNames.at(ii));
         #ifdef DEBUG_CB_SPICE
            char *path=NULL;
            size_t size = 0;
            path=getcwd(path,size);
            MessageInterface::ShowMessage("   CURRENT PATH = %s\n", path);
            MessageInterface::ShowMessage("   now checking Orbit file %s ...\n", orbitSpiceKernelNames.at(ii).c_str());
            MessageInterface::ShowMessage("   is it already loaded? %s\n", (isItLoaded? "YES!!!" : "no"));
         #endif
         if (!isItLoaded)
         {
#ifdef DEBUG_CB_SPICE
   MessageInterface::ShowMessage("   %s IS NOT already loaded!!!\n", orbitSpiceKernelNames.at(ii).c_str());
#endif
            try
            {
               kernelReader->LoadKernel(orbitSpiceKernelNames.at(ii));
               #ifdef DEBUG_CB_SPICE
                  MessageInterface::ShowMessage("   CB::LNK -- spice has loaded file %s\n",
                        (orbitSpiceKernelNames.at(ii)).c_str());
               #endif
            }
            catch (UtilityException &ue)
            {
               #ifdef DEBUG_CB_SPICE
                  MessageInterface::ShowMessage("   EXCEPTION caught with message: %s ...\n", ue.GetFullMessage().c_str());
               #endif
               // try again with path name if no path found
               std::string spkName = orbitSpiceKernelNames.at(ii);
               if (spkName.find("/") == spkName.npos &&
                   spkName.find("\\") == spkName.npos)
               {
                  // Changed to use PLANETARY_EPHEM_SPK_PATH (LOJ: 2014.06.18)
                  //std::string spkPath =
                  //   FileManager::Instance()->GetFullPathname(FileManager::SPK_PATH);
                  std::string spkPath =
                     FileManager::Instance()->GetFullPathname(FileManager::PLANETARY_EPHEM_SPK_PATH);
#ifdef DEBUG_CB_SPICE
   MessageInterface::ShowMessage("   In CB, spkPath returned was %s ...\n", spkPath.c_str());
#endif
                  spkName = spkPath + spkName;
                  try
                  {
                     #ifdef DEBUG_CB_SPICE
                        MessageInterface::ShowMessage("   now attempting to load %s ...\n", spkName.c_str());
                     #endif
                     kernelReader->LoadKernel(spkName);
                     #ifdef DEBUG_CB_SPICE
                     MessageInterface::ShowMessage("   spice has loaded file %s\n",
                        spkName.c_str());
                     #endif
                  }
                  catch (UtilityException &)
                  {
                     MessageInterface::ShowMessage("ERROR loading kernel %s\n",
                        (spkName.c_str()));
                     throw; // rethrow the exception, for now
                  }
               }
               else
               {
                  MessageInterface::ShowMessage("ERROR loading kernel %s\n",
                     (orbitSpiceKernelNames.at(ii).c_str()));
                  throw; // rethrow the exception, for now
               }
            }
         }
         #ifdef DEBUG_CB_SPICE
         else
         {
            MessageInterface::ShowMessage("   %s was already loaded, so not loaded!!!\n", orbitSpiceKernelNames.at(ii).c_str());
         }
         #endif

      }
   }
   if (attitude)
   {
      for (unsigned int ii = 0; ii < attitudeSpiceKernelNames.size(); ii++)
      {
         #ifdef DEBUG_CB_SPICE
            char *path=NULL;
            size_t size = 0;
            path=getcwd(path,size);
            MessageInterface::ShowMessage("   CURRENT PATH = %s\n", path);
            MessageInterface::ShowMessage("   now checking Planetary file %s ...\n", attitudeSpiceKernelNames.at(ii).c_str());
         #endif
         if (!(kernelReader->IsLoaded(attitudeSpiceKernelNames.at(ii))))
         {
            try
            {
               kernelReader->LoadKernel(attitudeSpiceKernelNames.at(ii));
               #ifdef DEBUG_CB_SPICE
                  MessageInterface::ShowMessage("   spice has loaded file %s\n",
                        (attitudeSpiceKernelNames.at(ii)).c_str());
               #endif
            }
            catch (UtilityException &ue)
            {
               #ifdef DEBUG_CB_SPICE
                  MessageInterface::ShowMessage("   EXCEPTION caught with message: %s ...\n", ue.GetFullMessage().c_str());
               #endif
               // try again with path name if no path found
               std::string pckName = attitudeSpiceKernelNames.at(ii);
               if (pckName.find("/") == pckName.npos &&
                   pckName.find("\\") == pckName.npos)
               {
                  std::string pckPath =
                     FileManager::Instance()->GetFullPathname(FileManager::PLANETARY_COEFF_PATH);
                  pckName = pckPath + pckName;
                  try
                  {
                     #ifdef DEBUG_CB_SPICE
                        MessageInterface::ShowMessage("   now attempting to load %s ...\n", pckName.c_str());
                     #endif
                     kernelReader->LoadKernel(pckName);
                     #ifdef DEBUG_CB_SPICE
                     MessageInterface::ShowMessage("   spice has loaded file %s\n",
                        pckName.c_str());
                     #endif
                  }
                  catch (UtilityException &)
                  {
                     MessageInterface::ShowMessage("ERROR loading kernel %s\n",
                        (pckName.c_str()));
                     throw; // rethrow the exception, for now
                  }
               }
               else
               {
                  MessageInterface::ShowMessage("ERROR loading kernel %s\n",
                     (attitudeSpiceKernelNames.at(ii).c_str()));
                  throw; // rethrow the exception, for now
               }
            }
         }
      }
   }
   if (frame)
   {
      for (unsigned int ii = 0; ii < frameSpiceKernelNames.size(); ii++)
      {
         #ifdef DEBUG_CB_SPICE
            char *path=NULL;
            size_t size = 0;
            path=getcwd(path,size);
            MessageInterface::ShowMessage("   CURRENT PATH = %s\n", path);
            MessageInterface::ShowMessage("   now checking Frame file %s ...\n", frameSpiceKernelNames.at(ii).c_str());
         #endif
         if (!(kernelReader->IsLoaded(frameSpiceKernelNames.at(ii))))
         {
            try
            {
               kernelReader->LoadKernel(frameSpiceKernelNames.at(ii));
               #ifdef DEBUG_CB_SPICE
                  MessageInterface::ShowMessage("   spice has loaded file %s\n",
                        (frameSpiceKernelNames.at(ii)).c_str());
               #endif
            }
            catch (BaseException &ue)
            {
               #ifdef DEBUG_CB_SPICE
                  MessageInterface::ShowMessage("   EXCEPTION caught with message: %s ...\n", ue.GetFullMessage().c_str());
               #endif
               // try again with path name if no path found
               std::string fkName = frameSpiceKernelNames.at(ii);
               if (fkName.find("/") == fkName.npos &&
                   fkName.find("\\") == fkName.npos)
               {
                  std::string fkPath =
                     FileManager::Instance()->GetFullPathname(FileManager::PLANETARY_COEFF_PATH);
                  fkName = fkPath + fkName;
                  try
                  {
                     #ifdef DEBUG_CB_SPICE
                        MessageInterface::ShowMessage("   now attempting to load %s ...\n", fkName.c_str());
                     #endif
                     kernelReader->LoadKernel(fkName);
                     #ifdef DEBUG_CB_SPICE
                     MessageInterface::ShowMessage("   spice has loaded file %s\n",
                        fkName.c_str());
                     #endif
                  }
                  catch (UtilityException &)
                  {
                     MessageInterface::ShowMessage("ERROR loading kernel %s\n",
                        (fkName.c_str()));
                     throw; // rethrow the exception, for now
                  }
               }
               else
               {
                  MessageInterface::ShowMessage("ERROR loading kernel %s\n",
                     (frameSpiceKernelNames.at(ii).c_str()));
                  throw; // rethrow the exception, for now
               }
            }
         }
      }
   }
   if (scClock)
   {
      for (unsigned int ii = 0; ii < scClockSpiceKernelNames.size(); ii++)
      {
         #ifdef DEBUG_CB_SPICE
            char *path=NULL;
            size_t size = 0;
            path=getcwd(path,size);
            MessageInterface::ShowMessage("   CURRENT PATH = %s\n", path);
            MessageInterface::ShowMessage("   now checking ScClock file %s ...\n", scClockSpiceKernelNames.at(ii).c_str());
         #endif
         if (!(kernelReader->IsLoaded(scClockSpiceKernelNames.at(ii))))
         {
            try
            {
               kernelReader->LoadKernel(scClockSpiceKernelNames.at(ii));
               #ifdef DEBUG_CB_SPICE
                  MessageInterface::ShowMessage("   spice has loaded file %s\n",
                        (scClockSpiceKernelNames.at(ii)).c_str());
               #endif
            }
            catch (UtilityException &ue)
            {
               #ifdef DEBUG_CB_SPICE
                  MessageInterface::ShowMessage("   EXCEPTION caught with message: %s ...\n", ue.GetFullMessage().c_str());
               #endif
               // try again with path name if no path found
               std::string scClockName = scClockSpiceKernelNames.at(ii);
               if (scClockName.find("/") == scClockName.npos &&
                   scClockName.find("\\") == scClockName.npos)
               {
                  std::string scClockPath =
                     FileManager::Instance()->GetFullPathname(FileManager::PLANETARY_COEFF_PATH);
                  scClockName = scClockPath + scClockName;
                  try
                  {
                     #ifdef DEBUG_CB_SPICE
                        MessageInterface::ShowMessage("   now attempting to load %s ...\n", scClockName.c_str());
                     #endif
                     kernelReader->LoadKernel(scClockName);
                     #ifdef DEBUG_CB_SPICE
                     MessageInterface::ShowMessage("   spice has loaded file %s\n",
                        scClockName.c_str());
                     #endif
                  }
                  catch (UtilityException &)
                  {
                     MessageInterface::ShowMessage("ERROR loading kernel %s\n",
                        (scClockName.c_str()));
                     throw; // rethrow the exception, for now
                  }
               }
               else
               {
                  MessageInterface::ShowMessage("ERROR loading kernel %s\n",
                     (scClockSpiceKernelNames.at(ii).c_str()));
                  throw; // rethrow the exception, for now
               }
            }
         }
      }
   }
#endif
   return true;
}

bool CelestialBody::UnloadKernels(bool orbit,  bool attitude,
                                  bool frame,  bool scClock)
{
#ifdef __USE_SPICE__
   if (kernelReader)
   {
      if (orbit)
      {
         // unload the kernel(s) from the SpiceKernelReader
         for (unsigned int kk = 0; kk < orbitSpiceKernelNames.size(); kk++)
         {
            if ((orbitSpiceKernelNames.at(kk) != "") && (orbitSpiceKernelNames.at(kk) != mainSPK))
            {
               #ifdef DEBUG_CB_SPICE
                  MessageInterface::ShowMessage("In CB (%s) destructor, attempting to unload the kernel %s\n",
                        instanceName.c_str(), (orbitSpiceKernelNames.at(kk)).c_str());
               #endif
               if (kernelReader->IsLoaded(orbitSpiceKernelNames.at(kk)))
               {
                  #ifdef DEBUG_CB_SPICE
                     MessageInterface::ShowMessage("... the kernel is still loaded ... so unloading\n");
                  #endif
                  kernelReader->UnloadKernel(orbitSpiceKernelNames.at(kk));
                  #ifdef DEBUG_CB_SPICE
                     MessageInterface::ShowMessage("... the kernel %s successfully unloaded\n", (orbitSpiceKernelNames.at(kk)).c_str());
                  #endif
               }
            }
         }
      }
      if (attitude)
      {
         // unload the kernel(s) from the SpiceKernelReader
         for (unsigned int kk = 0; kk < attitudeSpiceKernelNames.size(); kk++)
         {
            if ((attitudeSpiceKernelNames.at(kk) != "") && (attitudeSpiceKernelNames.at(kk) != mainPCK))
            {
               #ifdef DEBUG_CB_SPICE
                  MessageInterface::ShowMessage("In CB (%s) destructor, attempting to unload the kernel %s\n",
                        instanceName.c_str(), (attitudeSpiceKernelNames.at(kk)).c_str());
               #endif
               if (kernelReader->IsLoaded(attitudeSpiceKernelNames.at(kk)))
               {
                  #ifdef DEBUG_CB_SPICE
                     MessageInterface::ShowMessage("... the kernel is still loaded ... so unloading\n");
                  #endif
                  kernelReader->UnloadKernel(attitudeSpiceKernelNames.at(kk));
                  #ifdef DEBUG_CB_SPICE
                     MessageInterface::ShowMessage("... the kernel %s successfully unloaded\n", (attitudeSpiceKernelNames.at(kk)).c_str());
                  #endif
               }
            }
         }
      }
      if (frame)
      {
         // unload the kernel(s) from the SpiceKernelReader
         for (unsigned int kk = 0; kk < frameSpiceKernelNames.size(); kk++)
         {
            if (frameSpiceKernelNames.at(kk) != "")
            {
               #ifdef DEBUG_CB_SPICE
                  MessageInterface::ShowMessage("In CB (%s) destructor, attempting to unload the kernel %s\n",
                        instanceName.c_str(), (frameSpiceKernelNames.at(kk)).c_str());
               #endif
               if (kernelReader->IsLoaded(frameSpiceKernelNames.at(kk)))
               {
                  #ifdef DEBUG_CB_SPICE
                     MessageInterface::ShowMessage("... the kernel is still loaded ... so unloading\n");
                  #endif
                  kernelReader->UnloadKernel(frameSpiceKernelNames.at(kk));
                  #ifdef DEBUG_CB_SPICE
                     MessageInterface::ShowMessage("... the kernel %s successfully unloaded\n", (frameSpiceKernelNames.at(kk)).c_str());
                  #endif
               }
            }
         }
      }
      if (scClock)
      {
         // unload the kernel(s) from the SpiceKernelReader
         for (unsigned int kk = 0; kk < scClockSpiceKernelNames.size(); kk++)
         {
            if (scClockSpiceKernelNames.at(kk) != "")
            {
               #ifdef DEBUG_CB_SPICE
                  MessageInterface::ShowMessage("In CB (%s) destructor, attempting to unload the kernel %s\n",
                        instanceName.c_str(), (scClockSpiceKernelNames.at(kk)).c_str());
               #endif
               if (kernelReader->IsLoaded(scClockSpiceKernelNames.at(kk)))
               {
                  #ifdef DEBUG_CB_SPICE
                     MessageInterface::ShowMessage("... the kernel is still loaded ... so unloading\n");
                  #endif
                  kernelReader->UnloadKernel(scClockSpiceKernelNames.at(kk));
                  #ifdef DEBUG_CB_SPICE
                     MessageInterface::ShowMessage("... the kernel %s successfully unloaded\n", (scClockSpiceKernelNames.at(kk)).c_str());
                  #endif
               }
            }
         }
      }
   }
#endif
   return true;
}

