//$Id$
//------------------------------------------------------------------------------
//                                  CelestialBody
//------------------------------------------------------------------------------
// GMAT: Goddard Mission Analysis Tool.
//
// Author: Wendy C. Shoan
// Created: 2004/01/28
//
/**
 * Implementation of the CelestialBody class.
 *
 * @note This is an abstract class.
 *
 * @note Class (initial shell only) automatically generated by Dev-C++ New
 *       Class wizard (heavily modified after that)
 */
//------------------------------------------------------------------------------


#include <iostream>
#include <fstream>
#include <sstream>
#include <iomanip>
#include "gmatdefs.hpp"
#include "SpacePoint.hpp"
#include "CoordUtil.hpp"                // for conversion to/from Cartesian
#include "CelestialBody.hpp"
#include "PlanetaryEphem.hpp"
#include "SolarSystem.hpp"
#include "SolarSystemException.hpp"
#include "PlanetaryEphemException.hpp"
#include "Rvector3.hpp"
#include "Rvector6.hpp"
#include "Rmatrix.hpp"
#include "AtmosphereModel.hpp"
#include "MessageInterface.hpp"
#include "PhysicalConstants.hpp"
#include "TimeSystemConverter.hpp"
#include "UtcDate.hpp"
#include "TimeTypes.hpp"
#include "AngleUtil.hpp"
#include "TimeTypes.hpp"
#include "TimeSystemConverter.hpp"
#include "StringUtil.hpp"           // for ToString()
#include "GravityFile.hpp"          // for GetFileInfo()

//#define DEBUG_CELESTIAL_BODY 1
//#define DEBUG_GET_STATE
//#define DEBUG_CB_ANALYTIC


using namespace GmatMathUtil;
using namespace std; 

//---------------------------------
// static data
//---------------------------------
const std::string
CelestialBody::PARAMETER_TEXT[CelestialBodyParamCount - SpacePointParamCount] =
{
   "BodyType",
   "Mass",
   "EquatorialRadius",
   "Flattening",
   "PolarRadius",
   "Mu",
   "PosVelSource",
   "AnalyticMethod",
   "State",
   "StateTime",
   "CentralBody",
   "BodyNumber",
   "RefBodyNumber",
   "SourceFilename",
   "SourceFile",
   "UsePotentialFileFlag",
   "PotentialFileName",
   "AngularVelocity",
   "HourAngle",
   "AtmosphereModelName",
   "Order",
   "Degree",
   "RotationDataSource",
   "DateFormat",               // for analytic method
   "StateType",                // for analytic method
   "InitialEpoch",             // for analytic method
   "SMA",                      // for analytic method
   "ECC",                      // for analytic method
   "INC",                      // for analytic method
   "RAAN",                     // for analytic method
   "AOP",                      // for analytic method
   "TA",                       // for analytic method
};

const Gmat::ParameterType
CelestialBody::PARAMETER_TYPE[CelestialBodyParamCount - SpacePointParamCount] =
{
   Gmat::STRING_TYPE,   //"BodyType",
   Gmat::REAL_TYPE,     //"Mass",
   Gmat::REAL_TYPE,     //"EquatorialRadius",
   Gmat::REAL_TYPE,     //"Flattening",
   Gmat::REAL_TYPE,     //"PolarRadius",
   Gmat::REAL_TYPE,     //"Mu",
   Gmat::STRING_TYPE,   //"PosVelSource",
   Gmat::STRING_TYPE,   //"AnalyticMethod",
   Gmat::RVECTOR_TYPE,  //"State",
   Gmat::TIME_TYPE,     //"StateTime",
   Gmat::STRING_TYPE,   //"CentralBody",
   Gmat::INTEGER_TYPE,  //"BodyNumber",
   Gmat::INTEGER_TYPE,  //"RefBodyNumber",
   Gmat::STRING_TYPE,   //"SourceFilename",
   Gmat::OBJECT_TYPE,   //"SourceFile",
   Gmat::BOOLEAN_TYPE,  //"UsePotentialFileFlag",
   Gmat::STRING_TYPE,   //"PotentialFileName",
   Gmat::RVECTOR_TYPE,  //"AngularVelocity",
   Gmat::REAL_TYPE,     //"HourAngle",
   Gmat::STRING_TYPE,   //"AtmosphereModelName",
   Gmat::INTEGER_TYPE,  //"Order",
   Gmat::INTEGER_TYPE,  //"Degree",
   Gmat::STRING_TYPE,   //"RotationDataSource",
   Gmat::STRING_TYPE,   //"DateFormat",   
   Gmat::STRING_TYPE,   //"StateType",  
   Gmat::REAL_TYPE,     //"InitialEpoch",
   Gmat::REAL_TYPE,     //"SMA", 
   Gmat::REAL_TYPE,     //"ECC",   
   Gmat::REAL_TYPE,     //"INC",   
   Gmat::REAL_TYPE,     //"RAAN",    
   Gmat::REAL_TYPE,     //"AOP",  
   Gmat::REAL_TYPE,     //"TA", 
};

const Real CelestialBody::JD_EPOCH_2000_TCB = 2451545.0;
const Real CelestialBody::JD_EPOCH_2000_TT  = 2451545.0; // FIGURE THIS OUT!!!
const Real CelestialBody::dDot              = 1.0;
const Real CelestialBody::TDot              = 1.0;
const Real CelestialBody::KEPLER_TOL        = 1.0e-06;

//------------------------------------------------------------------------------
// public methods
//------------------------------------------------------------------------------
//------------------------------------------------------------------------------
//  CelestialBody(std::string itsBodyType, std::string name)
//------------------------------------------------------------------------------
/**
 * This method creates an object of the CelestialBody class
 * (additional constructor).
 *
 * @param <itsBodyType> string representation of its body type
 * @param <name> parameter indicating the name of the celestial body.
 */
//------------------------------------------------------------------------------
CelestialBody::CelestialBody(std::string itsBodyType, std::string name) :
   SpacePoint(Gmat::CELESTIAL_BODY, itsBodyType, name),
   mass               (5.9733319571407163e24),
   equatorialRadius   (6378.137),
   flattening         (0.0033528106647474807198455),
   polarRadius        (6356.76),
   mu                 (398600.4415),
   posVelSrc          (Gmat::DE_405),
   analyticMethod     (Gmat::LOW_FIDELITY),
   stateTime          (21545.0),
   centralBody        (""),
   cb                 (NULL),
   bodyNumber         (0),
   referenceBodyNumber(0),
   sourceFilename     (""),
   theSourceFile      (NULL),
   usePotentialFile   (false),
   potentialFileName  (""),
   hourAngle          (0.0),
   atmModel           (NULL),
   atmModelType       (""),
   potentialFileRead  (false),
   defaultMu          (398600.4415),
   defaultEqRadius    (6378.14),
   order              (4),
   degree             (4),
   analyticFormat     ("TAIModJulian"),
   analyticStateType  ("Keplerian"),
   newAnalytic        (true),
   overrideTime       (false),
   ephemUpdateInterval (0.0),
   lastEphemTime      (0.0),
   rotationSrc        (Gmat::NOT_APPLICABLE)
{
   objectTypes.push_back(Gmat::CELESTIAL_BODY);
   objectTypeNames.push_back("CelestialBody");
   
   for (Integer i = 0; i < Gmat::ModelTypeCount; i++)
      models[i].push_back("None");
   
   for (Integer i=0;i<6;i++)  prevState[i] = 0.0;
   
   parameterCount = CelestialBodyParamCount;
   InitializeBody(itsBodyType);
}

//------------------------------------------------------------------------------
//  CelestialBody(Gmat::BodyType itsBodyType, std::string name)
//------------------------------------------------------------------------------
/**
 * This method creates an object of the CelestialBody class
 * (additional constructor).
 *
 * @param <itsBodyType> its body type
 * @param <name> parameter indicating the name of the celestial body.
 */
//------------------------------------------------------------------------------
CelestialBody::CelestialBody(Gmat::BodyType itsBodyType, std::string name) :
   SpacePoint(Gmat::CELESTIAL_BODY,
              Gmat::BODY_TYPE_STRINGS[itsBodyType], name),
   bodyType           (itsBodyType),
   mass               (5.9733319571407163e24),
   equatorialRadius   (6378.137),
   flattening         (0.0033528106647474807198455),
   polarRadius        (6356.76),
   mu                 (398600.4415),
   posVelSrc          (Gmat::DE_405),
   analyticMethod     (Gmat::LOW_FIDELITY),
   stateTime          (21545.0),
   centralBody        (""),
   cb                 (NULL),
   bodyNumber         (0),
   referenceBodyNumber(0),
   sourceFilename     (""),
   theSourceFile      (NULL),
   usePotentialFile   (false),
   potentialFileName  (""),
   hourAngle          (0.0),
   atmModel           (NULL),
   atmModelType       (""),
   potentialFileRead  (false),
   defaultMu          (398600.4415),
   defaultEqRadius    (6378.14),
   order              (0),
   degree             (0),
   analyticFormat     ("TAIModjulian"),
   analyticStateType  ("Keplerian"),
   newAnalytic        (true),
   overrideTime       (false),
   ephemUpdateInterval (0.0),
   lastEphemTime      (0.0),
   rotationSrc        (Gmat::NOT_APPLICABLE)
{
   objectTypes.push_back(Gmat::CELESTIAL_BODY);
   objectTypeNames.push_back("CelestialBody");
   
   for (Integer i = 0; i < Gmat::ModelTypeCount; i++)
      models[i].push_back("None");
   for (Integer i=0;i<6;i++)  prevState[i] = 0.0;
   
   parameterCount = CelestialBodyParamCount;
   
   InitializeBody(Gmat::BODY_TYPE_STRINGS[itsBodyType]);
}

//------------------------------------------------------------------------------
//  CelestialBody(const CelestialBody &cBody)
//------------------------------------------------------------------------------
/**
 * This method creates an object of the CelestialBody class as a copy of the
 * specified CelestialBody class (copy constructor).
 *
 * @param <cBody> CelestialBody object to copy.
 */
//------------------------------------------------------------------------------
CelestialBody::CelestialBody(const CelestialBody &cBody) :
   SpacePoint          (cBody),
   bodyType            (cBody.bodyType),
   mass                (cBody.mass),
   equatorialRadius    (cBody.equatorialRadius),
   flattening          (cBody.flattening),
   polarRadius         (cBody.polarRadius),
   mu                  (cBody.mu),
   posVelSrc           (cBody.posVelSrc),
   analyticMethod      (cBody.analyticMethod),
   centralBody         (cBody.centralBody),
   cb                  (cBody.cb),
   bodyNumber          (cBody.bodyNumber),
   referenceBodyNumber (cBody.referenceBodyNumber),
   sourceFilename      (cBody.sourceFilename),
   theSourceFile       (cBody.theSourceFile), // ????????????????
   usePotentialFile    (cBody.usePotentialFile),
   potentialFileName   (cBody.potentialFileName),
   hourAngle           (cBody.hourAngle),
   atmModel            (NULL),
   order               (cBody.order),
   degree              (cBody.degree),
   sij                 (cBody.sij),
   cij                 (cBody.cij),
   analyticFormat      (cBody.analyticFormat),
   analyticStateType   (cBody.analyticStateType),
   analyticEpoch       (cBody.analyticEpoch),
   analyticKepler      (cBody.analyticKepler),
   prevAnalyticEpoch   (cBody.prevAnalyticEpoch),
   prevAnalyticState   (cBody.prevAnalyticState),
   newAnalytic         (cBody.newAnalytic),
   overrideTime        (cBody.overrideTime),
   ephemUpdateInterval (cBody.ephemUpdateInterval),
   lastEphemTime       (cBody.lastEphemTime),
   lastState           (cBody.lastState),
   rotationSrc         (cBody.rotationSrc)
{
   state                  = cBody.state;
   stateTime              = cBody.stateTime;
   angularVelocity        = cBody.angularVelocity;
   defaultMu              = cBody.defaultMu;
   defaultEqRadius        = cBody.defaultEqRadius;
   potentialFileRead      = false;
   
   if (cBody.atmModel)
   {
      atmModel = (AtmosphereModel*)(cBody.atmModel->Clone());
      
      #ifdef DEBUG_CELESTIAL_BODY
      MessageInterface::ShowMessage
         ("CelestialBody::CelestialBody() Setting ATM:%s on %s\n",
          atmModel->GetName().c_str(), instanceName.c_str());
      #endif
   }
   
   for (Integer i = 0; i < Gmat::ModelTypeCount; i++)
      models[i] = cBody.models[i];
   
   for (Integer i=0;i<6;i++)  prevState[i] = cBody.prevState[i];
}

//------------------------------------------------------------------------------
//  CelestialBody& operator= (const CelestialBody& cBody)
//------------------------------------------------------------------------------
/**
 * Assignment operator for the CelestialBody class.
 *
 * @param <cBody> the CelestialBody object whose data to assign to "this"
 *            solar system.
 *
 * @return "this" CelestialBody with data of input CelestialBody cb.
 */
//------------------------------------------------------------------------------
CelestialBody& CelestialBody::operator=(const CelestialBody &cBody)
{
   if (&cBody == this)
      return *this;

   SpacePoint::operator=(cBody);
   bodyType            = cBody.bodyType;
   mass                = cBody.mass;
   equatorialRadius    = cBody.equatorialRadius;
   flattening          = cBody.flattening;
   polarRadius         = cBody.polarRadius;
   mu                  = cBody.mu;
   posVelSrc           = cBody.posVelSrc;
   analyticMethod      = cBody.analyticMethod;
   state               = cBody.state;
   stateTime           = cBody.stateTime;
   centralBody         = cBody.centralBody;
   cb                  = cBody.cb;
   bodyNumber          = cBody.bodyNumber;
   referenceBodyNumber = cBody.referenceBodyNumber;
   sourceFilename      = cBody.sourceFilename;
   theSourceFile       = cBody.theSourceFile;   // ??????????????
   usePotentialFile    = cBody.usePotentialFile;
   potentialFileName   = cBody.potentialFileName;
   angularVelocity     = cBody.angularVelocity;
   hourAngle           = cBody.hourAngle;
   
   if (atmModel)
      delete atmModel;

   if (cBody.atmModel)
   {
      atmModel = (AtmosphereModel*)(cBody.atmModel)->Clone();
   }
   else
      atmModel = NULL;
   
   potentialFileRead   = false;
   defaultMu           = cBody.defaultMu;
   defaultEqRadius     = cBody.defaultEqRadius;
      
   for (Integer i = 0; i < Gmat::ModelTypeCount; i++)
      models[i] = cBody.models[i];
   
   analyticEpoch       = cBody.analyticEpoch;
   analyticKepler      = cBody.analyticKepler;
   prevAnalyticEpoch   = cBody.prevAnalyticEpoch;
   prevAnalyticState   = cBody.prevAnalyticState;
   analyticFormat      = cBody.analyticFormat;
   analyticStateType   = cBody.analyticStateType;
   newAnalytic         = cBody.newAnalytic;
   overrideTime        = cBody.overrideTime;
   ephemUpdateInterval = cBody.ephemUpdateInterval;
   lastEphemTime       = cBody.lastEphemTime;
   lastState           = cBody.lastState;
   rotationSrc         = cBody.rotationSrc;
   
   for (Integer i=0;i<6;i++)  prevState[i] = cBody.prevState[i];
   
   return *this;
}

//------------------------------------------------------------------------------
//  ~CelestialBody()
//------------------------------------------------------------------------------
/**
 * Destructor for the CelestialBody class.
 */
//------------------------------------------------------------------------------
CelestialBody::~CelestialBody()
{
   delete atmModel;  
}


//------------------------------------------------------------------------------
// bool Initialize()
//------------------------------------------------------------------------------
bool CelestialBody::Initialize()
{
   #ifdef DEBUG_CB_INIT
   MessageInterface::ShowMessage
      ("CelestialBody::Initialize() posVelSrc=%d, this=%s, ephemUpdateInterval=%f\n",
       posVelSrc, GetName().c_str(), ephemUpdateInterval);
   #endif
   
   isFirstTimeMu = true;
   isFirstTimeRadius = true;
   
   lastEphemTime = 0.0;
   stateTime = 0.0;   
   newAnalytic = true;
   
   return true;
}


//------------------------------------------------------------------------------
//  const Rvector6& GetState(A1Mjd atTime)
//------------------------------------------------------------------------------
/**
 * This method returns the state (position and velocity) of the body at the
 * requested time.
 *
 * @param <atTime>  time for which state of the body is requested.
 *
 * @return state of the body at the requested time.
 *
 * @exception <PlanetaryEphemException> thrown when the requested Pos/Vel
 *            source is set to SLP or DE***, but the source file has not
 *            been set.
 *
 */
//------------------------------------------------------------------------------
const Rvector6&  CelestialBody::GetState(A1Mjd atTime)
{
   #ifdef DEBUG_GET_STATE
      MessageInterface::ShowMessage("Entering Rvector6& GetState with time %.17f\n",
      atTime.Get());
      MessageInterface::ShowMessage("   lastEphemTime = %.17f\n",lastEphemTime.Get());
   #endif
      
   Real dt = Abs(atTime.Subtract(lastEphemTime)) * GmatTimeUtil::SECS_PER_DAY;
   if ( dt < ephemUpdateInterval)
   {
      #ifdef DEBUG_GET_STATE
      MessageInterface::ShowMessage("   returning lastState %s\n", state.ToString().c_str());
      #endif
      return lastState;
   }
   
   Real*     posVel = NULL;
   switch (posVelSrc)
   {
      case Gmat::ANALYTIC :
         switch (analyticMethod)
         {
            case Gmat::NO_ANALYTIC_METHOD :
               throw SolarSystemException(
                      "No analytic method specified for body " +instanceName);
            case Gmat::LOW_FIDELITY :
               state = ComputeLowFidelity(atTime);
               break;
            default:
               break;
         }
         break;
      case Gmat::SLP :
//      case Gmat::DE_102 :
      case Gmat::DE_200 :
//      case Gmat::DE_202 :
//      case Gmat::DE_403 :
      case Gmat::DE_405 :
//      case Gmat::DE_406 :
         if (!theSourceFile)
         {
            throw PlanetaryEphemException(
                  "SLP or DE file requested, but no file specified");
         }
         posVel     = theSourceFile->GetPosVel(bodyNumber,atTime, overrideTime);
         state.Set(posVel[0], posVel[1], posVel[2],
                   posVel[3], posVel[4], posVel[5]);
         break;
//      case Gmat::EPHEMERIS :  
//         break; // other cases later <<<<<<<<<<<<<<<<
      default:
         throw SolarSystemException("Invalid data source defined for body "
                                    + instanceName);
         break;
   }
   stateTime     = atTime;
   lastEphemTime = atTime;
   lastState     = state;
   
   for (Integer i=0;i<6;i++)
      prevState[i] = lastState[i];
   
   #ifdef DEBUG_GET_STATE
   MessageInterface::ShowMessage("   returning state %s\n", state.ToString().c_str());
   #endif
   
   return state;
}

//------------------------------------------------------------------------------
//  const Rvector6& GetState(Real atTime)
//------------------------------------------------------------------------------
 /**
 * This method returns the state (position and velocity) of the body at the
 * requested time.
 *
 * @param <atTime>  time for which state of the body is requested.
 *
 * @return state of the body at the requested time.
 *
 * @exception <PlanetaryEphemException> thrown when the requested Pos/Vel
 *            source is set to SLP or DE***, but the source file has not
 *            been set.
 *
 */
//------------------------------------------------------------------------------
const Rvector6&  CelestialBody::GetState(Real atTime)
{
   A1Mjd forTime(atTime);
   return GetState(forTime);
}


//------------------------------------------------------------------------------
// void GetState(const A1Mjd &atTime, Real *outState)
//------------------------------------------------------------------------------
void CelestialBody::GetState(const A1Mjd &atTime, Real *outState)
{
   #ifdef DEBUG_GET_STATE
      MessageInterface::ShowMessage("Entering GetState with time %.17f\n",
      atTime.Get());
   #endif
      
   Real dt = Abs(atTime.Subtract(lastEphemTime)) * GmatTimeUtil::SECS_PER_DAY;
   if ( dt < ephemUpdateInterval)
   {
      for (Integer i=0;i<6;i++) outState[i] = prevState[i];
   }
   
   switch (posVelSrc)
   {
      case Gmat::ANALYTIC :
         switch (analyticMethod)
         {
            case Gmat::NO_ANALYTIC_METHOD :
               throw SolarSystemException(
                      "No analytic method specified for body " +instanceName);
            case Gmat::LOW_FIDELITY :
            {
               Rvector6 state;
               state = ComputeLowFidelity(atTime);
               for (Integer i=0;i<6;i++) outState[i] = state[i];
               break;
            }
            default:
               break;
         }
         break;
      case Gmat::SLP :
//      case Gmat::DE_102 :
      case Gmat::DE_200 :
//      case Gmat::DE_202 :
//      case Gmat::DE_403 :
      case Gmat::DE_405 :
//      case Gmat::DE_406 :
         if (!theSourceFile)
         {
            throw PlanetaryEphemException(
                  "SLP or DE file requested, but no file specified");
         }
         outState     = theSourceFile->GetPosVel(bodyNumber,atTime, overrideTime);
         break;
//      case Gmat::EPHEMERIS :  
//         break; // other cases later <<<<<<<<<<<<<<<<
      default:
         throw SolarSystemException("Invalid data source defined for body "
                                    + instanceName);
         break;
   }
   
   stateTime     = atTime;
   lastEphemTime = atTime;
   lastState.Set(outState[0],outState[1],outState[2],outState[3],outState[4],outState[5]);
   
   for (Integer i=0;i<6;i++)
      prevState[i] = outState[i];
   
   #ifdef DEBUG_GET_STATE
      MessageInterface::ShowMessage("Exiting GetState -------------f\n");
   #endif
}

//------------------------------------------------------------------------------
//  Gmat::BodyType GetBodyType() const
//------------------------------------------------------------------------------
/**
 * This method returns the body type of the body.
 *
 * @return body type of the body.
 *
 */
//------------------------------------------------------------------------------
Gmat::BodyType CelestialBody::GetBodyType() const
{
   return bodyType;
}

//------------------------------------------------------------------------------
//  const std::string& GetCentralBody() const
//------------------------------------------------------------------------------
/**
 * This method returns the name of the central body of the body.
 *
 * @return name of the central body of the body.
 *
 */
//------------------------------------------------------------------------------
const std::string& CelestialBody::GetCentralBody() const
{
   return centralBody;
}


//------------------------------------------------------------------------------
//  Real GetGravitationalConstant() 
//------------------------------------------------------------------------------
/**
 * This method returns the gravitational constant (km^3/s^2) of the body.
 *
 * @return gravitational constant of the body.
 *
 */
//------------------------------------------------------------------------------
Real CelestialBody::GetGravitationalConstant() 
{
   //MessageInterface::ShowMessage
   //   ("==> CelestialBody::GetGravitationalConstant() usePotentialFile=%d for %s\n",
   //    usePotentialFile, instanceName.c_str());
   
   if (usePotentialFile == true)
   {
      if (!potentialFileRead)
      {
         if (!ReadPotentialFile())
         {
            if (isFirstTimeMu)
            {
               MessageInterface::ShowMessage
                  ("For body %s, cannot read file \"%s\", so using default mu"
                   " (%.18f)\n", instanceName.c_str(),
                   potentialFileName.c_str(), defaultMu);
               
               isFirstTimeMu = false;
            }
            
            mu = defaultMu;
         }
      }
      else
      {
         if (isFirstTimeMu)
         {
            MessageInterface::ShowMessage
               ("For body %s, using mu (%.18f) from file \"%s\"\n",
                instanceName.c_str(), mu, potentialFileName.c_str());
            
            isFirstTimeMu = false;
         }
      }
   }
   else
   {
      if (isFirstTimeMu)
      {
         MessageInterface::ShowMessage
            ("For body %s, not using potential file, so using default mu (%.18f)\n",
             instanceName.c_str(), mu, potentialFileName.c_str());
            
         isFirstTimeMu = false;
      }
   }
   
   // recompute mass
   mass = mu / GmatPhysicalConst::UNIVERSAL_GRAVITATIONAL_CONSTANT;
   return mu;
}

//------------------------------------------------------------------------------
//  Real GetEquatorialRadius() 
//------------------------------------------------------------------------------
/**
* This method returns the equatorial radius (km) of the body.
 *
 * @return equatorial radius of the body.
 *
 */
//------------------------------------------------------------------------------
Real CelestialBody::GetEquatorialRadius() 
{   
   if (usePotentialFile == true)
   {
      if (!potentialFileRead)
      {
         if (!ReadPotentialFile())
         {
            if (isFirstTimeRadius)
            {
               MessageInterface::ShowMessage
                  ("For body %s, cannot read file \"%s\", so using default eq. radius"
                   " (%.18f)\n", instanceName.c_str(),
                   potentialFileName.c_str(), defaultEqRadius);
               
               isFirstTimeRadius = false;
            }
         
            equatorialRadius = defaultEqRadius;
         }
      }
      else
      {
         if (isFirstTimeRadius)
         {
            MessageInterface::ShowMessage
               ("For body %s, using eq. radius (%.18f) from file \"%s\"\n",
                instanceName.c_str(), equatorialRadius, potentialFileName.c_str());
         
            isFirstTimeRadius = false;
         }
      }
   }
   else
   {
      if (isFirstTimeRadius)
      {
         MessageInterface::ShowMessage
            ("For body %s, not using potential file, so using default eq. radius (%.18f)\n",
             instanceName.c_str(), equatorialRadius, potentialFileName.c_str());
         
         isFirstTimeRadius = false;
      }
   }
   
   // recompute the polar radius
   polarRadius = (1.0 - flattening) * equatorialRadius;
   return equatorialRadius;
}

//------------------------------------------------------------------------------
//  Real GetFlattening() const
//------------------------------------------------------------------------------
/**
 * This method returns the flattening value of the body.
 *
 * @return flattening of the body.
 *
 */
//------------------------------------------------------------------------------
Real CelestialBody::GetFlattening() const
{
   return flattening;
}

//------------------------------------------------------------------------------
//  Real GetPolarRadius() 
//------------------------------------------------------------------------------
/**
 * This method returns the polar radius (km) of the body.
 *
 * @return polar radius of the body.
 *
 */
//------------------------------------------------------------------------------
Real CelestialBody::GetPolarRadius() 
{
   // make sure it is computed correctly
   polarRadius = (1.0 - flattening) * equatorialRadius;
   return polarRadius;   
}

//------------------------------------------------------------------------------
//  Real GetMass() 
//------------------------------------------------------------------------------
/**
 * This method returns the mass (kg) of the body.
 *
 * @return mass of the body.
 *
 */
//------------------------------------------------------------------------------
 Real CelestialBody::GetMass() 
{
   // make sure it is computed correctly
   mass = mu / GmatPhysicalConst::UNIVERSAL_GRAVITATIONAL_CONSTANT;
   return mass;
}

//------------------------------------------------------------------------------
//  Gmat::PosVelSource GetPosVelSource() const
//------------------------------------------------------------------------------
/**
 * This method returns the source of position and velocity for the body.
 *
 * @return position/velocity source for the body.
 *
 */
//------------------------------------------------------------------------------
Gmat::PosVelSource  CelestialBody::GetPosVelSource() const
{
   return posVelSrc;
}

//------------------------------------------------------------------------------
// std::string GetSourceFileName() const
//------------------------------------------------------------------------------
std::string CelestialBody::GetSourceFileName() const
{
   if (theSourceFile)
      return theSourceFile->GetName();
   return "";
}


//------------------------------------------------------------------------------
// PlanetaryEphem* GetSourceFile() const
//------------------------------------------------------------------------------
PlanetaryEphem*  CelestialBody::GetSourceFile() const
{
   return theSourceFile;
}

//------------------------------------------------------------------------------
//  Gmat::AnalyticMethod GetAnalyticMethod() const
//------------------------------------------------------------------------------
/**
 * This method returns the analytic method used for the body.
 *
 * @return analytic method for the body.
 *
 */
//------------------------------------------------------------------------------
Gmat::AnalyticMethod CelestialBody::GetAnalyticMethod() const
{
   return analyticMethod;
}

//------------------------------------------------------------------------------
//  bool CelestialBody::GetUsePotentialFile() const
//------------------------------------------------------------------------------
/**
 * This method returns the flag indicating whether to use the potential file
 * or not used for the body.
 *
 * @return flag indicating whether or not to use the potential file to determine
 *         mu, radius, and spherical harmonic coefficients.
 *
 */
//------------------------------------------------------------------------------
bool CelestialBody::GetUsePotentialFile() const
{
   return usePotentialFile;
}


//------------------------------------------------------------------------------
// bool GetOverrideTimeSystem() const
//------------------------------------------------------------------------------
bool CelestialBody::GetOverrideTimeSystem() const
{
   return overrideTime;
}


//------------------------------------------------------------------------------
// Real GetEphemUpdateInterval() const
//------------------------------------------------------------------------------
Real CelestialBody::GetEphemUpdateInterval() const
{
   return ephemUpdateInterval;
}


//------------------------------------------------------------------------------
// StringArray GetValidModelList(Gmat::ModelType m) const
//------------------------------------------------------------------------------
StringArray CelestialBody::GetValidModelList(Gmat::ModelType m) const
{
   return models[(Integer)m]; 
}


//------------------------------------------------------------------------------
//  const Rvector3& CelestialBody::GetAngularVelocity() 
//------------------------------------------------------------------------------
/**
 * This method returns the angular velocity for the body.
 *
 * @return angular velocity (Real[3]) for the body.
 *
 */
//------------------------------------------------------------------------------
const Rvector3& CelestialBody::GetAngularVelocity() 
{
   return angularVelocity; 
}

//------------------------------------------------------------------------------
//  Real GetHourAngle(A1Mjd atTime)
//------------------------------------------------------------------------------
/**
 * This method returns the hour angle for the body, referenced from the
 * Prime Meridian, measured westward
 *
 * @param <atTime> time for which to compute the hour angle
 *
 * @return hour angle for the body, in degrees, from the Prime Meridian
 *
 * @note This is a catch-all when information for the body is not defined.
 */
//------------------------------------------------------------------------------
Real  CelestialBody::GetHourAngle(A1Mjd atTime) 
{
   // should be implemented in derived classes
   throw SolarSystemException(
         "Hour Angles not yet available for body " + instanceName);
}

//------------------------------------------------------------------------------
//  const Rmatrix& GetHarmonicCoefficientsSij() 
//------------------------------------------------------------------------------
/**
 * This method returns the spherical harmonic coefficients sij for the body.  It
 * will read the potential file if that is requested.
 *
 * @return sij spherical harmonic coefficients for the body.
 *
 *
 * @exception <SolarSystemException> thown if there is an error getting the data.
 */
//------------------------------------------------------------------------------
const Rmatrix& CelestialBody::GetHarmonicCoefficientsSij() 
{
   return sij;
}

//------------------------------------------------------------------------------
//  const Rmatrix& GetHarmonicCoefficientsCij() 
//------------------------------------------------------------------------------
/**
 * This method returns the spherical harmonic coefficients cij for the body.  It
 * will read the potential file if that is requested.
 *
 * @return cij spherical harmonic coefficients for the body.
 *
 * @exception <SolarSystemException> thown if there is an error getting the data.
 */
//------------------------------------------------------------------------------
const Rmatrix& CelestialBody::GetHarmonicCoefficientsCij() 
{
   return cij;
}

//------------------------------------------------------------------------------
//  const Rmatrix& GetCoefDriftS()
//------------------------------------------------------------------------------
/**
 * This method returns the dSbar coefficient drift matrix for the body.  It
 * will read the potential file if that is requested.
 *
 * @return dSbar  coefficient drift matrix for the body.
 *
 * @exception <SolarSystemException> thown if there is an error getting the data.
 */
//------------------------------------------------------------------------------
//const Rmatrix& CelestialBody::GetCoefDriftS()
//{
//   if ((usePotentialFile == true) & (!potentialFileRead))
//   {
//      bool OK = ReadPotentialFile();
//      if (!OK) throw SolarSystemException("Unable to read potential file");
//   }
//   return dSbar;
//}

//------------------------------------------------------------------------------
//  const Rmatrix& GetCoefDriftC()
//------------------------------------------------------------------------------
/**
 * This method returns the dCbar coefficient drift matrix for the body.  It
 * will read the potential file if that is requested.
 *
 * @return dCbar  coefficient drift matrix for the body.
 *
 * @exception <SolarSystemException> thown if there is an error getting the data.
 */
//------------------------------------------------------------------------------
//const Rmatrix& CelestialBody::GetCoefDriftC()
//{
//   if ((usePotentialFile == true) & (!potentialFileRead))
//   {
//      bool OK = ReadPotentialFile();
//      if (!OK) throw SolarSystemException("Unable to read potential file");
//   }
//   return dCbar;
//}

//------------------------------------------------------------------------------
// Integer GetDegree()
//------------------------------------------------------------------------------
/**
 * This method returns the degree of the gravity coefficients for the body.  It
 * will read the potential file if that is requested.
 *
 * @return degree  degree of the coefficients for the body.
 *
 * @exception <SolarSystemException> thown if there is an error getting the data.
 */
//------------------------------------------------------------------------------
Integer CelestialBody::GetDegree()
{
   return degree;
}

//------------------------------------------------------------------------------
// Integer GetOrder()
//------------------------------------------------------------------------------
/**
 * This method returns the order of the gravity coefficients for the body.  It
 * will read the potential file if that is requested.
 *
 * @return degree  order of the coefficients for the body.
 *
 * @exception <SolarSystemException> thown if there is an error getting the data.
 */
//------------------------------------------------------------------------------
Integer CelestialBody::GetOrder()
{
   return order;
}

//------------------------------------------------------------------------------
//  std::string GetAtmosphereModelType()
//------------------------------------------------------------------------------
/**
 * This method returns the name (type) of the current atmosphere model for
 * the body.
 *
 * @return the name (type) of the current atmosphere model for the body.
 *
 */
//------------------------------------------------------------------------------
std::string  CelestialBody::GetAtmosphereModelType()
{
   if (!atmModel)
      return "Undefined";

   return atmModel->GetTypeName();  // or should I go through the AtmManager?
}

//------------------------------------------------------------------------------
//  AtmosphereModel* GetAtmosphereModel()
//------------------------------------------------------------------------------
/**
 * This method returns a pointer to the current atmosphere model for the body.
 *
 * @return a pointer to the current atmosphere model for the body.
 *
 */
//------------------------------------------------------------------------------
AtmosphereModel* CelestialBody::GetAtmosphereModel()
{
   return atmModel;
}

//------------------------------------------------------------------------------
//  bool GetDensity(Real *position, Real *density, Real epoch, Integer count)
//------------------------------------------------------------------------------
/**
 * Calculates the atmospheric density at a specified location.
 *
 * Density if the core calculation provided by classes derived from this one.
 * The outpur array, density, must contain the density at the requested
 * locations, expressed in kg / m^3.
 *
 *  @param position  The input vector of spacecraft states
 *  @param density   The array of output densities
 *  @param epoch     The current TAIJulian epoch
 *  @param count     The number of spacecraft contained in position
 */
//------------------------------------------------------------------------------
bool CelestialBody::GetDensity(Real *position, Real *density, Real epoch,
                               Integer count)
{
   if (!atmModel) return false;
   return atmModel->Density(position,density,epoch,count);
}


//------------------------------------------------------------------------------
// A1Mjd GetAnalyticEpoch() const
//------------------------------------------------------------------------------
A1Mjd CelestialBody::GetAnalyticEpoch() const
{
   return analyticEpoch;
}


//------------------------------------------------------------------------------
// Rvector6 GetAnalyticElements() const
//------------------------------------------------------------------------------
Rvector6 CelestialBody::GetAnalyticElements() const
{
   return analyticKepler;
}

//------------------------------------------------------------------------------
// Gmat::RotationDataSource GetRotationDataSource() const
//------------------------------------------------------------------------------
Gmat::RotationDataSource CelestialBody::GetRotationDataSource() const
{
   return rotationSrc;
}

//------------------------------------------------------------------------------
//  bool SetBodyType(Gmat::BodyType bType)
//------------------------------------------------------------------------------
/**
 * This method sets the body type for the body.
 *
 * @param <bType> body type for the body.
 *
 * @return flag indicating success of the method.
 *
 */
//------------------------------------------------------------------------------
bool CelestialBody::SetBodyType(Gmat::BodyType bType)
{
   bodyType = bType;
   return true; // will need to change default parameters here too, if they
                // are set to values that make no sense for this type of body?
}

//------------------------------------------------------------------------------
//  bool SetCentralBody(const std::string &cBody)
//------------------------------------------------------------------------------
/**
 * This method sets the central body for the body.
 *
 * @param <cBody> central body name for the body.
 *
 * @return flag indicating success of the method.
 *
 */
//------------------------------------------------------------------------------
bool CelestialBody::SetCentralBody(const std::string &cBody)
{
   centralBody = cBody;
   return true;
}

//------------------------------------------------------------------------------
//  bool SetGravitationalConstant(Real newMu)
//------------------------------------------------------------------------------
/**
 * This method sets the gravitational constant for the body.
 *
 * @param <newMw> gravitational constant (km^3/s^2) for the body.
 *
 * @exception <SolarSystemException> thrown if value is out of range
 * 
 * @return flag indicating success of the method.
 *
 */
//------------------------------------------------------------------------------
bool CelestialBody::SetGravitationalConstant(Real newMu)
{
   if (newMu <= 0.0)
   {
      SolarSystemException sse;
      sse.SetDetails(errorMessageFormat.c_str(),
                     GmatStringUtil::ToString(newMu, GetDataPrecision()).c_str(),
                     "Mu", "Real Number > 0.0");
      throw sse;
   }
   
   mu   = newMu;
   mass = mu / GmatPhysicalConst::UNIVERSAL_GRAVITATIONAL_CONSTANT;
   return true;
}

//------------------------------------------------------------------------------
//  bool SetEquatorialRadius(Real newEqRadius)
//------------------------------------------------------------------------------
/**
 * This method sets the equatorial radius for the body.
 *
 * @param <newEqRadius> equatorial radius (km) for the body.
 *
 * @exception <SolarSystemException> thrown if value is out of range
 *
 * @return flag indicating success of the method.
 *
 */
//------------------------------------------------------------------------------
bool CelestialBody::SetEquatorialRadius(Real newEqRadius)
{
   if (newEqRadius <= 0.0)
   {
      SolarSystemException sse;
      sse.SetDetails(errorMessageFormat.c_str(),
                     GmatStringUtil::ToString(newEqRadius, GetDataPrecision()).c_str(),
                     "Equatorial Radius", "Real Number > 0.0");
      throw sse;
   }
   
   equatorialRadius = newEqRadius;
   polarRadius      = (1.0 - flattening) * equatorialRadius;
   return true;
}

//------------------------------------------------------------------------------
//  bool SetFlattening(Real flat)
//------------------------------------------------------------------------------
/**
 * This method sets the flattening value for the body.
 *
 * @param <flat> flattening value for the body.
 *
 * @return flag indicating success of the method.
 *
 */
//------------------------------------------------------------------------------
bool CelestialBody::SetFlattening(Real flat) 
{
   flattening  = flat;
   polarRadius = (1.0 - flattening) * equatorialRadius;
   return true;
}

//------------------------------------------------------------------------------
//  bool SetMass(Real newMass)
//------------------------------------------------------------------------------
/**
 * This method sets the mass for the body.
 *
 * @param <newMass> mass (kg) for the body.
 *
 * @return flag indicating success of the method.
 *
 */
//------------------------------------------------------------------------------
//bool CelestialBody::SetMass(Real newMass) 
//{
//   mass = newMass;
//   return true;
//}

//------------------------------------------------------------------------------
//  bool SetSource(Gmat::PosVelSource pvSrc)
//------------------------------------------------------------------------------
/**
 * This method sets the position/velocity source for the body.
 *
 * @param <pcSrc> position/velocity source for the body.
 *
 * @return flag indicating success of the method.
 *
 */
//------------------------------------------------------------------------------
bool CelestialBody::SetSource(Gmat::PosVelSource pvSrc)
{
   posVelSrc = pvSrc;
   return true;
}

//------------------------------------------------------------------------------
//  bool SetSourceFile(PlanetaryEphem *src)
//------------------------------------------------------------------------------
/**
 * This method sets the position/velocity source file for the body.
 *
 * @param <src> position/velocity source file for the body.
 *
 * @return flag indicating success of the method.
 *
 */
//------------------------------------------------------------------------------
bool CelestialBody::SetSourceFile(PlanetaryEphem *src)
{
   // should I delete the old one here???
   theSourceFile = src;
   sourceFilename = theSourceFile->GetName();
   bodyNumber = theSourceFile->GetBodyID(instanceName);
   return true;
}

//------------------------------------------------------------------------------
//  bool SetAnalyticMethod(Gmat::AnalyticMethod aM)
//------------------------------------------------------------------------------
/**
* This method sets the analytic method for the body.
 *
 * @param <aM> analytic method for the body.
 *
 * @return flag indicating success of the method.
 *
 */
//------------------------------------------------------------------------------
bool CelestialBody::SetAnalyticMethod(Gmat::AnalyticMethod aM)
{
   analyticMethod = aM;
   return true; 
}

//------------------------------------------------------------------------------
//  bool SetUsePotentialFile(bool useIt)
//------------------------------------------------------------------------------
/**
 * This method sets the flag indicating whether or not to get the mu, radius,
 * and harmonic coefficients from the potential file.
 *
 * @param <useIt> use the potential file?.
 *
 * @return flag indicating success of the method.
 *
 */
//------------------------------------------------------------------------------
bool CelestialBody::SetUsePotentialFile(bool useIt)
{
   if ((usePotentialFile == false) && (useIt == true))
   {
      potentialFileRead = false;
      isFirstTimeMu = true;
      isFirstTimeRadius = true;
   }
   else if ((usePotentialFile == true) && (useIt == false))
   {
      mu               = defaultMu;
      equatorialRadius = defaultEqRadius;
      // recompute polar radius
      polarRadius = (1.0 - flattening) * equatorialRadius;
      // recompute mass
      mass = mu / GmatPhysicalConst::UNIVERSAL_GRAVITATIONAL_CONSTANT;
      isFirstTimeMu = true;
      isFirstTimeRadius = true;
   }
   
   usePotentialFile = useIt;
   return true;
}

//------------------------------------------------------------------------------
//  bool SetOverrideTimeSystem(bool overrideIt)
//------------------------------------------------------------------------------
/**
 * This method sets the time system override flag for the body 
 * (i.e. if true, TDB and TCB times will be overridden with TT times).
 *
 * @param <overrideIt> overrride TDB or TCB time with TT?.
 *
 * @return flag indicating success of the method.
 *
 */
//------------------------------------------------------------------------------
bool CelestialBody::SetOverrideTimeSystem(bool overrideIt)
{
   overrideTime = overrideIt;
   return true;
}


//------------------------------------------------------------------------------
// bool SetEphemUpdateInterval(Real intvl)
//------------------------------------------------------------------------------
bool CelestialBody::SetEphemUpdateInterval(Real intvl)
{
   if (intvl < 0.0)
   {
      SolarSystemException sse;
      sse.SetDetails(errorMessageFormat.c_str(),
                     GmatStringUtil::ToString(intvl, GetDataPrecision()).c_str(),
                     "Ephemeris Update Interval", "Real Number >= 0.0");
      throw sse;
   }
   ephemUpdateInterval = intvl;
   return true;
}


//------------------------------------------------------------------------------
// bool AddValidModelName(Gmat::ModelType m, const std::string &newModel)
//------------------------------------------------------------------------------
bool CelestialBody::AddValidModelName(Gmat::ModelType m, 
                                      const std::string &newModel)
{
   // first, make sure it is not already on the list
   if (find(models[(Integer)m].begin(), models[(Integer)m].end(),
            newModel) == models[(Integer)m].end())
      models[(Integer)m].push_back(newModel);
   // @todo modify it so it adds it before an 'Other' in the list
   
   return true;
   
}


//------------------------------------------------------------------------------
// bool RemoveValidModelName(Gmat::ModelType m, const std::string &modelName)
//------------------------------------------------------------------------------
bool CelestialBody::RemoveValidModelName(Gmat::ModelType m, 
                                         const std::string &modelName)
{
   // remove it, if it's on the list
   bool found = false;
   for (StringArray::iterator i = models[(Integer)m].begin();
        i != models[(Integer)m].end(); ++i)
   {
      if (*i == modelName)
      {
         models[(Integer)m].erase(i);
         found = true;
         break;
      }
   }
   return true;  // found?
}


//------------------------------------------------------------------------------
//  bool SetAtmosphereModelType(std::string toAtmModelType)
//------------------------------------------------------------------------------
/**
* This method sets the atmosphere model type for the body.
 *
 * @param <toAtmModel> name (type) of the atmosphere model to use.
 *
 * @return flag indicating success of the method.
 *
 * @note This method no longer sets the actual atmosphere model pointer.  A call
 *       to SetAtmosphereModel must be executed for that to happen.
 *
 */
//------------------------------------------------------------------------------
bool CelestialBody::SetAtmosphereModelType(std::string toAtmModelType)
{
   atmModelType = toAtmModelType;
   return true;
}


//------------------------------------------------------------------------------
//  bool SetAtmosphereModel(AtmosphereModel *toAtmModel)
//------------------------------------------------------------------------------
/**
 * This method sets the atmosphere model pointer for the body.
 *
 * @param <toAtmModel> pointer to the atmosphere model to use.
 *
 * @return flag indicating success of the method.
 *
 */
//------------------------------------------------------------------------------
bool CelestialBody::SetAtmosphereModel(AtmosphereModel *toAtmModel)
{
   if (atmModel) delete atmModel;
   atmModel = toAtmModel;
   return true;
}


//------------------------------------------------------------------------------
//  bool SetPotentialFilename(const std::string &fn)
//------------------------------------------------------------------------------
/**
 * This method sets potential file name for this HarmonicField object.
 *
 * @param <fn> full path name of the potential file name to use.
 *
 * @return flag indicating success of the operation.
 */
//------------------------------------------------------------------------------
bool CelestialBody::SetPotentialFilename(const std::string &fn)
{
   if (potentialFileName != fn)
   {
      potentialFileRead = false;
      isFirstTimeMu = true;
      isFirstTimeRadius = true;
   }
   
   potentialFileName = fn;
   return true;
}


//------------------------------------------------------------------------------
// bool SetAnalyticEpoch(const A1Mjd &toTime)
//------------------------------------------------------------------------------
bool CelestialBody::SetAnalyticEpoch(const A1Mjd &toTime)
{
   #ifdef DEBUG_CB_ANALYTIC
      MessageInterface::ShowMessage(
      "In CB::SetAnalyticEpoch, setting epoch to %.12f\n", toTime.Get());
   #endif
   analyticEpoch = toTime;
   newAnalytic   = true;
   return true;
}


//------------------------------------------------------------------------------
// bool SetSMA(Real value)
//------------------------------------------------------------------------------
/*
 * Sets SemimajorAxis of analytic model state.
 *
 * @param  value  value of semimajor axis
 *
 * @exception <SolarSystemException> thrown if new value is out of range
 *
 */
//------------------------------------------------------------------------------
bool CelestialBody::SetSMA(Real value)
{
   if (value == 0.0)
   {
      SolarSystemException sse;
      sse.SetDetails(errorMessageFormat.c_str(),
                     GmatStringUtil::ToString(value, GetDataPrecision()).c_str(),
                     PARAMETER_TEXT[ANALYTIC_SMA - SpacePointParamCount].c_str(),
                     "Real Number != 0.0");
      throw sse;
   }
   
   analyticKepler[0] = value;
   return true;
}


//------------------------------------------------------------------------------
// bool SetECC(Real value)
//------------------------------------------------------------------------------
/*
 * Sets Eccentricity of analytic model state.
 *
 * @param  value  eccentricity value
 *
 * @exception <SolarSystemException> thrown if value is out of range
 *
 */
//------------------------------------------------------------------------------
bool CelestialBody::SetECC(Real value)
{
   if (value < 0.0)
   {
      SolarSystemException sse;
      sse.SetDetails(errorMessageFormat.c_str(),
                     GmatStringUtil::ToString(value, GetDataPrecision()).c_str(),
                     PARAMETER_TEXT[ANALYTIC_ECC - SpacePointParamCount].c_str(),
                     "Real Number >= 0.0");
      throw sse;
   }
   
   analyticKepler[1] = value;
   return true;
}


//------------------------------------------------------------------------------
// bool SetAnalyticElements(const Rvector6 &kepl)
//------------------------------------------------------------------------------
bool CelestialBody::SetAnalyticElements(const Rvector6 &kepl)
{
   #ifdef DEBUG_CB_ANALYTIC
      MessageInterface::ShowMessage(
      "In CB::SetAnalyticElements, setting elements to\n%.12f %.12f %.12f %.12f"
      " %.12f %.12f\n", kepl[0],kepl[1],kepl[2],kepl[3],kepl[4],kepl[5]);
   #endif
      
   SetSMA(kepl[0]);
   SetECC(kepl[1]);
   
//    if (kepl[0] == 0.0)
//    {
//       //std::string errMsg = "For body " + instanceName + 
//       //   ", SMA value must be non-zero"; 
//       std::stringstream buffer;
//       buffer << kepl[0];
//       std::string errMsg = "The value of \"" + buffer.str() + "\" for field \"" + 
//          PARAMETER_TEXT[ANALYTIC_SMA - SpacePointParamCount] + "\" on object \"" + instanceName +
//          "\" is not an allowed value.  \nThe allowed values are: " +
//          " [Real number non-zero]."; 
//       throw SolarSystemException(errMsg);
//    }
   
//    if (kepl[1] < 0.0)
//    {
//       //std::string errMsg = "For body " + instanceName + 
//       //   ", ECC value must be greater than or equal to zero"; 
//       std::stringstream buffer;
//       buffer << kepl[1];
//       std::string errMsg = "The value of \"" + buffer.str() + "\" for field " + 
//          PARAMETER_TEXT[ANALYTIC_ECC - SpacePointParamCount] + "\" on object \"" + instanceName +
//          "\" is not an allowed value.  \nThe allowed values are: " +
//          " [Real number >= zero]."; 
//       throw SolarSystemException(errMsg);
//    }
   
   analyticKepler = kepl;
   newAnalytic    = true;
   return true;
}

bool CelestialBody::SetRotationDataSource(Gmat::RotationDataSource src)
{
   rotationSrc = src;
   return true;
}


//------------------------------------------------------------------------------
// const Rvector6 GetMJ2000State(const A1Mjd &atTime)
//------------------------------------------------------------------------------
const Rvector6 CelestialBody::GetMJ2000State(const A1Mjd &atTime)
{
   if (j2000Body == NULL)
      throw SolarSystemException("j2000Body is NULL for " + instanceName);
      
   // If j2000Body is this body, return the zero state vector
   if(j2000Body->GetName() == instanceName) 
      return Rvector6(0.0, 0.0, 0.0, 0.0, 0.0, 0.0);

   Rvector6         stateEphem    = GetState(atTime);
   Rvector6         j2kEphemState;
   Gmat::ObjectType ot            = j2000Body->GetType();
   if (ot == Gmat::CELESTIAL_BODY)
   {
      j2kEphemState = ((CelestialBody*)j2000Body)->GetState(atTime);
   }
   else if (ot == Gmat::CALCULATED_POINT)
   {
      // fill in with calculated point stuff when it's done
      //j2kEphemState = ((CalculatedPoint*)j2000Body)->GetState(atTime);
   }
   else
   {
      throw SolarSystemException("j2000Body is of incorrect type.");
   }
   return (stateEphem - j2kEphemState);
   
}


//------------------------------------------------------------------------------
// const Rvector3 GetMJ2000Position(const A1Mjd &atTime)
//------------------------------------------------------------------------------
const Rvector3 CelestialBody::GetMJ2000Position(const A1Mjd &atTime)
{
   Rvector6 tmp = GetMJ2000State(atTime);
   return (tmp.GetR());
}


//------------------------------------------------------------------------------
// const Rvector3 GetMJ2000Velocity(const A1Mjd &atTime)
//------------------------------------------------------------------------------
const Rvector3 CelestialBody::GetMJ2000Velocity(const A1Mjd &atTime)
{
   Rvector6 tmp = GetMJ2000State(atTime);
   return (tmp.GetV());
}


//------------------------------------------------------------------------------
//  Rvector GetBodyCartographicCoordinates(const A1Mjd &forTime) const
//------------------------------------------------------------------------------
/**
 * This method returns the cartographic coordinates for the body.
 *
 * @return vector containing alpha, delta, W, Wdot, where:
 *         alpha is the right ascension of the north pole of rotation
 *         delta is the declination of the north pole of rotation
 *         W specifies the ephemeris position of the prime meridian
 *         Wdot specifies the time derivative of W
 *
 * @note currently only implemented for the Star, Planets, and Major Moons of
 *       our Solar System.
 *
 */
//------------------------------------------------------------------------------
Rvector CelestialBody::GetBodyCartographicCoordinates(const A1Mjd &forTime) const
{
   // should be implemented in derived classes
   throw SolarSystemException(
         "Cartographic Coordinates not yet computed for body " + instanceName);
}


//------------------------------------------------------------------------------
//  bool SetPhysicalParameters(Real bodyMass, Real bodyEqRad,
//                             Real bodyPolarRad, Real bodyMu,
//                             Integer coeffSize, Rmatrix& bodySij,
//                             Rmatrix& bodyCij);
//------------------------------------------------------------------------------
/**
 * This method sets the physical parameters for the body.
 *
 * @param <bodyMass>     mass (kg) of the body.
 * @param <bodyMEqRad>   equatorial radius (km) of the body.
 * @param <bodyPolarRad> polar radius (km) of the body.
 * @param <bodyMu>       gravitational constant (km^3/s^2) of the body.
 * @param <coeffSize>    size of Sij and Cij for the body.
 * @param <bodySij>      coefficients Sij for the body (coeffSize x coeffSize).
 * @param <bodyCij>      coefficients Cij for the body (coeffSize x coeffSize).
 *
 * @return flag indicating success of the method.
 *
 * @exception <SolarSystemException> thrown if there is an error in the
 *                                   input data.
 */
//------------------------------------------------------------------------------
//bool CelestialBody::SetPhysicalParameters(Real bodyMass, Real bodyEqRad,
//                                          Real bodyPolarRad, Real bodyMu,
//                                          Integer coeffSize, Rmatrix &bodySij,
//                                          Rmatrix &bodyCij)
//{
//   // add data checks later <-
//   mass             = bodyMass;
//   equatorialRadius = bodyEqRad;
//   polarRadius      = bodyPolarRad;
//   mu               = bodyMu;
//   coefficientSize  = coeffSize;
//   Integer r,c;
//   try
//   {
//      bodySij.GetSize(r,c);
//      sij = bodySij;
//   }
//   catch (TableTemplateExceptions::IllegalSize& tte)
//   {
//      throw SolarSystemException("Sij input to body has no dimensions.");
//   }
//   try
//   {
//      bodyCij.GetSize(r,c);
//      cij = bodyCij;
//   }
//   catch (TableTemplateExceptions::IllegalSize& tte)
//   {
//      throw SolarSystemException("Cij input to body has no dimensions.");
//   }
//   return true;
//}
//------------------------------------------------------------------------------
//  std::string  GetParameterText(const Integer id) const
//------------------------------------------------------------------------------
/**
 * This method returns the parameter text, given the input parameter ID.
 *
 * @param <id> Id for the requested parameter text.
 *
 * @return parameter text for the requested parameter.
 *
 */
//------------------------------------------------------------------------------
std::string CelestialBody::GetParameterText(const Integer id) const
{
   if (id >= SpacePointParamCount && id < CelestialBodyParamCount)
      return PARAMETER_TEXT[id - SpacePointParamCount];
   return SpacePoint::GetParameterText(id);
}

//------------------------------------------------------------------------------
//  Integer  GetParameterID(const std::string &str) const
//------------------------------------------------------------------------------
/**
 * This method returns the parameter ID, given the input parameter string.
 *
 * @param <str> string for the requested parameter.
 *
 * @return ID for the requested parameter.
 *
 */
//------------------------------------------------------------------------------
Integer     CelestialBody::GetParameterID(const std::string &str) const
{
   for (Integer i = SpacePointParamCount; i < CelestialBodyParamCount; i++)
   {
      if (str == PARAMETER_TEXT[i - SpacePointParamCount])
         return i;
   }
   
   return SpacePoint::GetParameterID(str);
}

//------------------------------------------------------------------------------
//  Gmat::ParameterType  GetParameterType(const Integer id) const
//------------------------------------------------------------------------------
/**
 * This method returns the parameter type, given the input parameter ID.
 *
 * @param <id> ID for the requested parameter.
 *
 * @return parameter type of the requested parameter.
 *
 */
//------------------------------------------------------------------------------
Gmat::ParameterType CelestialBody::GetParameterType(const Integer id) const
{
   if (id >= SpacePointParamCount && id < CelestialBodyParamCount)
      return PARAMETER_TYPE[id - SpacePointParamCount];
      
   return SpacePoint::GetParameterType(id);
}

//------------------------------------------------------------------------------
//  std::string  GetParameterTypeString(const Integer id) const
//------------------------------------------------------------------------------
/**
 * This method returns the parameter type string, given the input parameter ID.
 *
 * @param <id> ID for the requested parameter.
 *
 * @return parameter type string of the requested parameter.
 *
 */
//------------------------------------------------------------------------------
std::string CelestialBody::GetParameterTypeString(const Integer id) const
{
   return SpacePoint::PARAM_TYPE_STRING[GetParameterType(id)];
}

//------------------------------------------------------------------------------
//  Real  GetRealParameter(const Integer id) const
//------------------------------------------------------------------------------
/**
 * This method returns the Real parameter value, given the input parameter ID.
 *
 * @param <id> ID for the requested parameter value.
 *
 * @return  Real value of the requested parameter.
 *
 */
//------------------------------------------------------------------------------
Real        CelestialBody::GetRealParameter(const Integer id) const
{
   if (id == MASS)               return mass;
   if (id == EQUATORIAL_RADIUS)  return equatorialRadius;
   if (id == FLATTENING)         return flattening;
   if (id == POLAR_RADIUS)       return polarRadius;
   if (id == MU)                 return mu;
   if (id == HOUR_ANGLE)         return hourAngle;

   // DJC, 06/15/05: Temporarily put an accessor in place to help debug the
   // force model.  This piece may be replaced by a different call when epoch
   // issues are updated in the Spacecraft/SpaceObject code.
   if (id == STATE_TIME)              return stateTime.Get();
   
   if (id == ANALYTIC_INITIAL_EPOCH)  return analyticEpoch.Get();
   if (id == ANALYTIC_SMA)            return analyticKepler[0];
   if (id == ANALYTIC_ECC)            return analyticKepler[1];
   if (id == ANALYTIC_INC)            return analyticKepler[2];
   if (id == ANALYTIC_RAAN)           return analyticKepler[3];
   if (id == ANALYTIC_AOP)            return analyticKepler[4];
   if (id == ANALYTIC_TA)             return analyticKepler[5];
   
   return SpacePoint::GetRealParameter(id);
}

//------------------------------------------------------------------------------
//  Real  SetRealParameter(const Integer id, const Real value)
//------------------------------------------------------------------------------
/**
 * This method sets the Real parameter value, given the input parameter ID.
 *
 * @param <id> ID for the parameter whose value to change.
 * @param <value> value for the parameter.
 *
 * @return  Real value of the requested parameter.
 *
 */
//------------------------------------------------------------------------------
Real CelestialBody::SetRealParameter(const Integer id, const Real value)
{
   Rvector6 tmpKepl = analyticKepler;
   #ifdef DEBUG_CB_ANALYTIC
      MessageInterface::ShowMessage("In CB::SetReal with id = %d, and value = %.14f\n",
      id, value);
   #endif
      
   //if (id == MASS)              return (mass               = value); // make sense?
   if (id == EQUATORIAL_RADIUS)
   {
      return SetEquatorialRadius(value);
   }
   if (id == FLATTENING)
   {
      flattening = value;
      polarRadius = (1.0 - flattening) * equatorialRadius;
      return true;
   }
   //if (id == POLAR_RADIUS)      return (polarRadius        = value); // make sense?
   if (id == MU)
   {
      return SetGravitationalConstant(value);
   }
   if (id == HOUR_ANGLE)
   {
      hourAngle = value;
      return true;
   }
   if (id == ANALYTIC_INITIAL_EPOCH)
   {
      if (SetAnalyticEpoch(A1Mjd(value)))
      {
         newAnalytic = true;
         return true;
      }
      else return false;
   }
   if (id == ANALYTIC_SMA)
   {
      tmpKepl[0] = value;
      if (SetAnalyticElements(tmpKepl)) 
      {
         newAnalytic = true;
         return true;
      }
      else return false;
   }
   if (id == ANALYTIC_ECC)
   {
      tmpKepl[1] = value;
      if (SetAnalyticElements(tmpKepl)) 
      {
         newAnalytic = true;
         return true;
      }
      else return false;
   }
   if (id == ANALYTIC_INC)
   {
      tmpKepl[2] = value;
      if (SetAnalyticElements(tmpKepl)) 
      {
         newAnalytic = true;
         return true;
      }
      else return false;
   }
   if (id == ANALYTIC_RAAN)
   {
      tmpKepl[3] = value;
      if (SetAnalyticElements(tmpKepl)) 
      {
         newAnalytic = true;
         return true;
      }
      else return false;
   }
   if (id == ANALYTIC_AOP)
   {
      tmpKepl[4] = value;
      if (SetAnalyticElements(tmpKepl)) 
      {
         newAnalytic = true;
         return true;
      }
      else return false;
   }
   if (id == ANALYTIC_TA)
   {
      tmpKepl[5] = value;
      if (SetAnalyticElements(tmpKepl)) 
      {
         newAnalytic = true;
         return true;
      }
      else return false;
   }

   #ifdef DEBUG_CB_ANALYTIC
      MessageInterface::ShowMessage(
      "At end of CB::SetReal, Keplerian elements are %.14f %.14f %.14f %.14f %.14f %.14f\n",
      analyticKepler[0],analyticKepler[1],analyticKepler[2],analyticKepler[3],
      analyticKepler[4],analyticKepler[5]);
      MessageInterface::ShowMessage(
      "..... and epoch is: %.14f\n",analyticEpoch.Get());
   #endif
   
   return SpacePoint::SetRealParameter(id, value);
}

//------------------------------------------------------------------------------
//  Integer  GetIntegerParameter(const Integer id) const
//------------------------------------------------------------------------------
/**
 * This method returns the Integer parameter value, given the input
 * parameter ID.
 *
 * @param <id> ID for the requested parameter.
 *
 * @return  Integer value of the requested parameter.
 *
 */
//------------------------------------------------------------------------------
Integer CelestialBody::GetIntegerParameter(const Integer id) const
{
   if (id == ORDER)                return order;
   if (id == DEGREE)               return degree;
   if (id == BODY_NUMBER)          return bodyNumber;
   if (id == REF_BODY_NUMBER)      return referenceBodyNumber;
   if (id == ROTATION_DATA_SRC)    return (Integer) rotationSrc;
   
   return SpacePoint::GetIntegerParameter(id); // add others in later?
}

//------------------------------------------------------------------------------
//  Integer  SetIntegerParameter(const Integer id, const Integer value)
//------------------------------------------------------------------------------
/**
 * This method sets the Integer parameter value, given the input
 * parameter ID.
 *
 * @param <id> ID for the requested parameter.
 * @param <value> Integer value for the requested parameter.
 *
 * @return  Integer value of the requested parameter.
 *
 */
//------------------------------------------------------------------------------
Integer CelestialBody::SetIntegerParameter(const Integer id,
                                           const Integer value)
{
   if (id == ORDER)
   {
      order = value;
      return true;
   }
   if (id == DEGREE)
   {
      degree = value;
      return true;
   }
   if (id == BODY_NUMBER)
   {
      bodyNumber = value;
      return true;
   }
   if (id == REF_BODY_NUMBER)
   {
      referenceBodyNumber = value;
      return true;
   }
   
   return SpacePoint::SetIntegerParameter(id,value);  // add others in later
}

//------------------------------------------------------------------------------
//  std::string  GetStringParameter(const Integer id) const
//------------------------------------------------------------------------------
/**
 * This method returns the string parameter value, given the input
 * parameter ID.
 *
 * @param <id> ID for the requested parameter.
 *
 * @return  string value of the requested parameter.
 *
 */
//------------------------------------------------------------------------------
std::string CelestialBody::GetStringParameter(const Integer id) const
{
   if (id == BODY_TYPE)             return Gmat::BODY_TYPE_STRINGS[bodyType];
   if (id == POS_VEL_SOURCE)        return Gmat::POS_VEL_SOURCE_STRINGS[posVelSrc];
   if (id == ANALYTIC_METHOD)       return Gmat::ANALYTIC_METHOD_STRINGS[analyticMethod];
   if (id == SOURCE_FILENAME)       return sourceFilename;
   if (id == SOURCE_FILE)           return sourceFilename;
   if (id == POTENTIAL_FILE_NAME)   return potentialFileName;
   if (id == ATMOS_MODEL_NAME)
   {
      if (atmModel == NULL) return "";
      return atmModel->GetTypeName();
   }
   if (id == CENTRAL_BODY)          return centralBody;
   if (id == ANALYTIC_DATE_FORMAT)  return analyticFormat;
   if (id == ANALYTIC_STATE_TYPE)   return analyticStateType;
   if (id == ROTATION_DATA_SRC)     return Gmat::ROTATION_DATA_SOURCE_STRINGS[rotationSrc];
   
   return SpacePoint::GetStringParameter(id);
}

//------------------------------------------------------------------------------
//  std::string  SetStringParameter(const Integer id, const std::string value)
//------------------------------------------------------------------------------
/**
 * This method sets the string parameter value, given the input
 * parameter ID.
 *
 * @param <id> ID for the requested parameter.
 * @param <value> string value for the requested parameter.
 *
 * @exception <SolarSystemException> thrown if value is out of range
 *
 * @return  success flag.
 *
 */
//------------------------------------------------------------------------------
bool CelestialBody::SetStringParameter(const Integer id,
                                       const std::string &value) // const?
{
   int i;
   if (id == BODY_TYPE)
   {
      for (i=0;i<Gmat::BodyTypeCount;i++)
         if (value == Gmat::BODY_TYPE_STRINGS[i])
         {
            bodyType = (Gmat::BodyType) i;
            return true;
         }
      return false;
   }
   if (id == POS_VEL_SOURCE)
   {
      for (i=0;i<Gmat::PosVelSourceCount;i++)
         if (value == Gmat::POS_VEL_SOURCE_STRINGS[i])
         {
            posVelSrc = (Gmat::PosVelSource) i;
            return true;
         }
      return false;
   }
   if (id == ANALYTIC_METHOD)
   {
      for (i=0;i<Gmat::AnalyticMethodCount;i++)
         if (value == Gmat::ANALYTIC_METHOD_STRINGS[i])
         {
            analyticMethod = (Gmat::AnalyticMethod) i;
            return true;
         }
      return false;
   }
   if (id == SOURCE_FILENAME)
   {
      sourceFilename = value;
      return true;
   }
   if (id == POTENTIAL_FILE_NAME)
   {
      potentialFileName = value;
      return true;
   }
   if (id == ATMOS_MODEL_NAME)
   {
      atmModelType = value;
      return true;
   }
   if (id == CENTRAL_BODY)
   {
      centralBody = value;
      return true;
   }
   if (id == ANALYTIC_DATE_FORMAT)
   {
      #ifdef DEBUG_CB_ANALYTIC
         MessageInterface::ShowMessage(
         "In CB::SetString (ANALYTIC_DATE_FORMAT) with id = %d, and value = %s\n",
         id, value.c_str());
      #endif
      if (value != "TAIModJulian")
      {
         SolarSystemException sse;
         sse.SetDetails(errorMessageFormat.c_str(), value.c_str(),
                        PARAMETER_TEXT[ANALYTIC_DATE_FORMAT - SpacePointParamCount].c_str(),
                        "TAIModJulian");
         throw sse;
      }
      analyticFormat = value;
      return true;
   }
   if (id == ANALYTIC_STATE_TYPE)
   {
      #ifdef DEBUG_CB_ANALYTIC
         MessageInterface::ShowMessage(
         "In CB::SetString (ANALYTIC_STATE_TYPE) with id = %d, and value = %s\n",
         id, value.c_str());
      #endif
      if (value != "Keplerian")
      {
         SolarSystemException sse;
         sse.SetDetails(errorMessageFormat.c_str(), value.c_str(),
                        PARAMETER_TEXT[ANALYTIC_STATE_TYPE - SpacePointParamCount].c_str(),
                        "Keplerian");
         
         throw sse;
      }
      analyticStateType = value;
      return true;
   }
   
   if (id == ROTATION_DATA_SRC)
   {
      MessageInterface::ShowMessage
         ("CelestialBody::SetStringParameter -> value = %s\n", value.c_str());
      //if (value == "DE405")
      if (value == Gmat::ROTATION_DATA_SOURCE_STRINGS[Gmat::DE_FILE])
         SetRotationDataSource(Gmat::DE_FILE);
      //else if (value == "IAU2002")
      else if (value == Gmat::ROTATION_DATA_SOURCE_STRINGS[Gmat::IAU_DATA])
         SetRotationDataSource(Gmat::IAU_DATA);
      else
      {
         SolarSystemException sse;
         std::string validStr;
         for (int i = 0; i < Gmat::NOT_APPLICABLE; i++)
            validStr = validStr + Gmat::ROTATION_DATA_SOURCE_STRINGS[i] + ", ";
         
         sse.SetDetails(errorMessageFormat.c_str(), value.c_str(),
                        PARAMETER_TEXT[ROTATION_DATA_SRC - SpacePointParamCount].c_str(),
                        //"DE405, IAU2002");
                        validStr.c_str());
         throw sse;
      }
      return true;
   }
   
   return SpacePoint::SetStringParameter(id, value);
}

//------------------------------------------------------------------------------
//  bool  GetBooleanParameter(const Integer id) const
//------------------------------------------------------------------------------
/**
 * This method returns the bool parameter value, given the input
 * parameter ID.
 *
 * @param <id> ID for the requested parameter.
 *
 * @return  bool value of the requested parameter.
 *
 */
//------------------------------------------------------------------------------
bool CelestialBody::GetBooleanParameter(const Integer id) const
{
   if (id == USE_POTENTIAL_FILE_FLAG)       return usePotentialFile;

   return SpacePoint::GetBooleanParameter(id);
}

//------------------------------------------------------------------------------
//  bool  SetBooleanParameter(const Integer id, const std::string value)
//------------------------------------------------------------------------------
/**
 * This method sets the bool parameter value, given the input
 * parameter ID.
 *
 * @param <id> ID for the requested parameter.
 * @param <value> bool value for the requested parameter.
 *
 * @return  success flag.
 *
 */
//------------------------------------------------------------------------------
bool CelestialBody::SetBooleanParameter(const Integer id,
                                        const bool value) // const?
{
   if (id == USE_POTENTIAL_FILE_FLAG)
   {
      if ((usePotentialFile == false) && (value == true))
      {
         potentialFileRead = false;
         isFirstTimeMu = true;
         isFirstTimeRadius = true;
      }
      else if ((usePotentialFile == true) && (value == false))
      {
         mu               = defaultMu;
         equatorialRadius = defaultEqRadius;
         // recompute polar radius
         polarRadius = (1.0 - flattening) * equatorialRadius;
         // recompute mass
         mass = mu / GmatPhysicalConst::UNIVERSAL_GRAVITATIONAL_CONSTANT;
         isFirstTimeMu = true;
         isFirstTimeRadius = true;
      }
   
      usePotentialFile = value;
      return true; 
   }

   return SpacePoint::SetBooleanParameter(id,value);
}

//------------------------------------------------------------------------------
//  const Rvector&  GetRvectorParameter(const Integer id)
//------------------------------------------------------------------------------
/**
 * This method gets the Rvector parameter value, given the input
 * parameter ID.
 *
 * @param <id> ID for the requested parameter.
 *
 * @return  success flag.
 *
 */
//------------------------------------------------------------------------------
const Rvector&  CelestialBody::GetRvectorParameter(const Integer id) const
{
   if (id == STATE)               return state;
   if (id == ANGULAR_VELOCITY)    return angularVelocity;

   return SpacePoint::GetRvectorParameter(id);
}

//------------------------------------------------------------------------------
//  const Rvector&  SetRvectorParameter(const Integer id, const Rvector& value)
//------------------------------------------------------------------------------
/**
 * This method sets the Rvector parameter value, given the input
 * parameter ID.
 *
 * @param <id> ID for the requested parameter.
 * @param <value> Rvector value for the requested parameter.
 *
 * @return  success flag.
 *
 */
//------------------------------------------------------------------------------
const Rvector&  CelestialBody::SetRvectorParameter(const Integer id,
                                              const Rvector &value)
{
   Integer sz = value.GetSize();
   Integer i;
   
   if (id == STATE)
   {
      if (sz != 6) throw SolarSystemException(
                  "Incorrectly sized Rvector passed in for state.");
      for (i=0;i<6;i++) state(i) = value(i);
      return state;
   }
   if (id == ANGULAR_VELOCITY)
   {
      if (sz != 3) throw SolarSystemException(
                   "Incorrectly sized Rvector passed in for angular velocity.");
      for (i=0;i<3;i++) angularVelocity(i) = value(i);
      return angularVelocity;
   }

   return SpacePoint::SetRvectorParameter(id,value);
}

//------------------------------------------------------------------------------
//  const Rvector&  GetRvectorParameter(const std::string &label)
//------------------------------------------------------------------------------
/**
 * This method gets the Rvector parameter value, given the input
 * parameter ID.
 *
 * @param <label> string ID for the requested parameter.
 *
 * @return  success flag.
 *
 */
//------------------------------------------------------------------------------
const Rvector& CelestialBody::GetRvectorParameter(const std::string &label) const
{
   return GetRvectorParameter(GetParameterID(label));
}

//------------------------------------------------------------------------------
//  const Rvector&  SetRvectorParameter(const std::string &label,
//                                      const Rvector& value)
//------------------------------------------------------------------------------
/**
 * This method sets the Rvector parameter value, given the input
 * parameter ID.
 *
 * @param <label> string ID for the requested parameter.
 * @param <value> Rvector value for the requested parameter.
 *
 * @return  success flag.
 *
 */
//------------------------------------------------------------------------------
const Rvector& CelestialBody::SetRvectorParameter(const std::string &label,
                                              const Rvector &value)
{
   return SetRvectorParameter(GetParameterID(label), value);
}

//------------------------------------------------------------------------------
//  const Rmatrix&  GetRmatrixParameter(const Integer id)
//------------------------------------------------------------------------------
/**
 * This method gets the Rmatrix parameter value, given the input
 * parameter ID.
 *
 * @param <id> ID for the requested parameter.
 *
 * @return  success flag.
 *
 */
//------------------------------------------------------------------------------
//const Rmatrix& CelestialBody::GetRmatrixParameter(const Integer id) const
//{
//   if (id == SIJ)               return sij;
//   if (id == CIJ)               return cij;
//   
//   return SpacePoint::GetRmatrixParameter(id);
//}

//------------------------------------------------------------------------------
//  const Rmatrix&  SetRmatrixParameter(const Integer id, const Rmatrix& value)
//------------------------------------------------------------------------------
/**
 * This method sets the Rmatrix parameter value, given the input
 * parameter ID.
 *
 * @param <id> ID for the requested parameter.
 * @param <value> Rmatrix value for the requested parameter.
 *
 * @return  success flag.
 *
 */
//------------------------------------------------------------------------------
//const Rmatrix& CelestialBody::SetRmatrixParameter(const Integer id,
//                                                  const Rmatrix &value)
//{
//   if (id == SIJ) 
//   {
//      sij = value;
//      return true;
//   }
//   if (id == CIJ)
//   {
//      cij = value;
//      return true;
//   }
//
//   return SpacePoint::SetRmatrixParameter(id,value);
//}

//------------------------------------------------------------------------------
//  const Rmatrix&  GetRmatrixParameter(const std::string &label)
//------------------------------------------------------------------------------
/**
 * This method gets the Rmatrix parameter value, given the input
 * parameter ID.
 *
 * @param <label> string ID for the requested parameter.
 *
 * @return  success flag.
 *
 */
//------------------------------------------------------------------------------
//const Rmatrix& CelestialBody::GetRmatrixParameter(const std::string &label) const
//{
//   return GetRmatrixParameter(GetParameterID(label));
//}

//------------------------------------------------------------------------------
//  const Rmatrix&  SetRmatrixParameter(const std::string &label,
//                                      const Rmatrix& value)
//------------------------------------------------------------------------------
/**
 * This method sets the Rmatrix parameter value, given the input
 * parameter ID.
 *
 * @param <label> string ID for the requested parameter.
 * @param <value> Rmatrix value for the requested parameter.
 *
 * @return  success flag.
 *
 */
//------------------------------------------------------------------------------
//const Rmatrix& CelestialBody::SetRmatrixParameter(const std::string &label,
//                                                  const Rmatrix &value)
//{
//   return SetRmatrixParameter(GetParameterID(label), value);
//}

//------------------------------------------------------------------------------
//  const StringArray&   GetStringArrayParameter((const Integer id) const
//------------------------------------------------------------------------------
/**
 * This method returns the StringArray parameter value, given the input
 * parameter ID.
 *
 * @param <id> ID for the requested parameter.
 *
 * @return  StringArray value of the requested parameter.
 *
 */
//------------------------------------------------------------------------------
const StringArray& CelestialBody::GetStringArrayParameter(const Integer id) const
{
   return SpacePoint::GetStringArrayParameter(id);
}


//------------------------------------------------------------------------------
//  GmatBase* GetRefObject(const Gmat::ObjectType type,
//                         const std::string &name)
//------------------------------------------------------------------------------
/**
 * This method returns a reference object from the CelestialBody class.
 *
 * @param type  type of the reference object requested
 * @param name  name of the reference object requested
 *
 * @return pointer to the reference object requested.
 *
 */
//------------------------------------------------------------------------------
GmatBase* CelestialBody::GetRefObject(const Gmat::ObjectType type,
                                      const std::string &name)
{
   switch (type)
   {
      case Gmat::SPACE_POINT:
      case Gmat::CELESTIAL_BODY:
         if ((cb) && (name == centralBody))     return cb;
         break;
      default:
         break;
   }

   // Not handled here -- invoke the next higher GetRefObject call
   return SpacePoint::GetRefObject(type, name);
}


//------------------------------------------------------------------------------
//  const StringArray& GetRefObjectNameArray(const Gmat::ObjectType type)
//------------------------------------------------------------------------------
/**
 * Returns the names of the reference object. (Derived classes should implement
 * this as needed.)
 *
 * @param <type> reference object type.  Gmat::UnknownObject returns all of the
 *               ref objects.
 *
 * @return The names of the reference object.
 */
//------------------------------------------------------------------------------
const StringArray& CelestialBody::GetRefObjectNameArray(
                                  const Gmat::ObjectType type)
{
   if ((type == Gmat::UNKNOWN_OBJECT) ||
       (type == Gmat::CELESTIAL_BODY))
   {
      static StringArray refs = SpacePoint::GetRefObjectNameArray(type);

      refs.push_back(centralBody);

      #ifdef DEBUG_REFERENCE_SETTING
         MessageInterface::ShowMessage("+++ReferenceObjects:\n");
         for (StringArray::iterator i = refs.begin(); i != refs.end(); ++i)
            MessageInterface::ShowMessage("   %s\n", i->c_str());
      #endif

      return refs;
   }

   // Not handled here -- invoke the next higher GetRefObject call
   return SpacePoint::GetRefObjectNameArray(type);
}


//------------------------------------------------------------------------------
//  bool SetRefObject(GmatBase *obj, const Gmat::ObjectType type,
//                    const std::string &name)
//------------------------------------------------------------------------------
/**
 * This method sets a reference object for the CelestialBody class.
 *
 * @param obj   pointer to the reference object
 * @param type  type of the reference object
 * @param name  name of the reference object
 *
 * @return true if successful; otherwise, false.
 *
 */
//------------------------------------------------------------------------------
bool CelestialBody::SetRefObject(GmatBase *obj,
                                 const Gmat::ObjectType type,
                                 const std::string &name)
{
   bool foundHere = false;
   bool trySP     = false;
   if (obj->IsOfType("CelestialBody"))
   {
      if (name == centralBody)
      {
         #ifdef DEBUG_REFERENCE_SETTING
            MessageInterface::ShowMessage("Setting %s as primary for %s\n",
                                          name.c_str(), instanceName.c_str());
         #endif
         cb = (CelestialBody*) obj;
         foundHere = true;
      }
   }

   // may also be the right object for a higher level parameter ...
   try
   {
      trySP = SpacePoint::SetRefObject(obj, type, name);
   }
   catch (GmatBaseException &gbe)
   {
      if (!foundHere) throw;
   }
   if (foundHere || trySP) return true;
   return false;
}


//------------------------------------------------------------------------------
// bool IsParameterReadOnly(const Integer id) const
//------------------------------------------------------------------------------
bool CelestialBody::IsParameterReadOnly(const Integer id) const
{
   // if we're not using an analytic model, those parameters are read-only
   if (posVelSrc != Gmat::ANALYTIC)
   {
      if ((id == ANALYTIC_DATE_FORMAT)   || (id == ANALYTIC_STATE_TYPE) ||
          (id == ANALYTIC_INITIAL_EPOCH) || (id == ANALYTIC_SMA)        ||
          (id == ANALYTIC_ECC)           || (id == ANALYTIC_INC)        ||
          (id == ANALYTIC_RAAN)          || (id == ANALYTIC_AOP)        ||
          (id == ANALYTIC_TA)            || (id == ANALYTIC_METHOD)      )
      {
         #ifdef DEBUG_CB_ANALYTIC
            MessageInterface::ShowMessage(
            "In CB::IParameterReadOnly, id = %d, returning TRUE\n",
            id);
         #endif
         return true;
      }
   }
   return SpacePoint::IsParameterReadOnly(id);
}

//------------------------------------------------------------------------------
// bool CelestialBody::IsParameterReadOnly(const std::string &label) const
//------------------------------------------------------------------------------
bool CelestialBody::IsParameterReadOnly(const std::string &label) const
{
   return IsParameterReadOnly(GetParameterID(label));
}


//------------------------------------------------------------------------------
// protected methods
//------------------------------------------------------------------------------
//------------------------------------------------------------------------------
//  void  InitializeBody(std::string withBodyType)
//------------------------------------------------------------------------------
/**
 * This method initializes the data values for the body.
 *
 * @param <withBodyType> string representation of the body type.
 *
 */
//------------------------------------------------------------------------------
void CelestialBody::InitializeBody(std::string withBodyType)
{
   #ifdef DEBUG_CB_INIT
   MessageInterface::ShowMessage
      ("CelestialBody::InitializeBody(%s) entered\n", withBodyType.c_str());
   #endif
   
   // assuming derived classes will fill in all the specific things with
   // appropriate default values
   usePotentialFile  = false;
   potentialFileName = "";
   sourceFilename    = "";
   theSourceFile     = NULL;
   stateTime         = 0.0;
   state             = Rvector6(0.0,0.0,0.0,0.0,0.0,0.0);
   angularVelocity   = Rvector3(0.0,0.0,0.0);
   potentialFileRead = false;
   atmModel          = NULL;
   int i;
   bodyType = Gmat::PLANET;  // default to Planet
   for (i = 0; i < (Integer) Gmat::BodyTypeCount; i++)
      if (withBodyType == Gmat::BODY_TYPE_STRINGS[i]) bodyType = (Gmat::BodyType) i;
   angularVelocity(0) = 0.0;
   angularVelocity(1) = 0.0;
   angularVelocity(2) = 7.29211585530e-5;  // should I do this here or in Planet??

   isFirstTimeMu = true;
   isFirstTimeRadius = true;
   rotationSrc = Gmat::NOT_APPLICABLE;
}

//------------------------------------------------------------------------------
//  bool  ReadPotentialFile()
//------------------------------------------------------------------------------
/**
 * This method reads the potential file, if requested, and gets the mu, radius,
 * and spherical harmonic coefficients, sij and cij, from the file.
 *
 * @return flag indicating success of the file-reading.
 *
 */
//------------------------------------------------------------------------------
bool CelestialBody::ReadPotentialFile()
{
   if (potentialFileRead) return true;
   if (potentialFileName == "") return false;
   
   GravityFile gf;
   Integer fileDeg, fileOrd;
   try
   {
      if (!gf.GetFileInfo(potentialFileName, fileDeg, fileOrd, mu,
                          equatorialRadius))
      {
         throw SolarSystemException
            ("Error reading mu and equatorial radius of " + instanceName
             + " from "+ potentialFileName);
      }
   }
   catch (BaseException &e)
   {
      throw SolarSystemException(e.GetFullMessage());
   }
   
   
   potentialFileRead = true;
   // recompute polar radius
   polarRadius = (1.0 - flattening) * equatorialRadius;
   // recompute mass
   mass = mu / GmatPhysicalConst::UNIVERSAL_GRAVITATIONAL_CONSTANT;
   return true;
}


//------------------------------------------------------------------------------
//  bool IsBlank(char* aLine)
//------------------------------------------------------------------------------
/**
 * This method returns true if the string is empty or is all white space.
 *
 * @return success flag.
 */
//------------------------------------------------------------------------------
bool CelestialBody::IsBlank(char* aLine)
{
   Integer i;
   for (i=0;i<(int)strlen(aLine);i++)
   {
      if (!isspace(aLine[i])) return false;
   }
   return true;
}


//------------------------------------------------------------------------------
//  Real GetJulianDaysFromTCBEpoch(const A1Mjd &forTime)
//------------------------------------------------------------------------------
/**
 * This method computes the Julian days from the TCB Epoch.
 *
 * @return number of Julian days since the TCB epoch.
 *
 * @note If the overrideTime flag is set, this actually computes the Julian Days
 *       from TT epoch.
 */
//------------------------------------------------------------------------------
Real CelestialBody::GetJulianDaysFromTCBEpoch(const A1Mjd &forTime) const
{
   Real jdTime = 0.0;
   Real mjdTT  = TimeConverterUtil::Convert(forTime.Get(),
                                            TimeConverterUtil::A1MJD,
                                            TimeConverterUtil::TTMJD, 
                                            GmatTimeUtil::JD_JAN_5_1941);
   jdTime      = mjdTT + GmatTimeUtil::JD_JAN_5_1941; 
   return (jdTime - JD_EPOCH_2000_TT);
}

//------------------------------------------------------------------------------
//  Rvector6 ComputeLowFidelity(const A1Mjd &forTime)
//------------------------------------------------------------------------------
/**
 * This method computes the position and velocity at time forTime
 *
 * @return body state (position, velocity) at time forTime, with respect to
 *         the Earth.
 *
 */
//------------------------------------------------------------------------------
Rvector6 CelestialBody::ComputeLowFidelity(const A1Mjd &forTime)
{
   // Since we want the state in MJ2000Eq Earth-centered
   if (instanceName == SolarSystem::EARTH_NAME) 
      return Rvector6(0.0,0.0,0.0,0.0,0.0,0.0);

   Rvector6 cbState = cb->GetState(forTime);
   Rvector6 posvel = KeplersProblem(forTime);
   
   return (KeplersProblem(forTime) + cbState);    
}


//------------------------------------------------------------------------------
//  Rvector6 KeplersProblem(const A1Mjd &forTime)
//------------------------------------------------------------------------------
/**
 * This method computes the position and velocity at time forTime
 *
 * @return body state (position, velocity) at time forTime, with respect to
 *         the central body.
 *
 * @note This is based on Algorithm 8 on pp. 101-2 (and algorithm 1 on
 *       p. 71) of "Fundamentals of Astrodynamics and Applications",
 *       Second Edition, by David A. Vallado.
 */
//------------------------------------------------------------------------------
Rvector6 CelestialBody::KeplersProblem(const A1Mjd &forTime)
{   
   Real     cbMu  = cb->GetGravitationalConstant() + mu;
   Rvector6 cart;  // or MA???
   Real     dTime;
   if (newAnalytic)
   {
      cart  = CoordUtil::KeplerianToCartesian(analyticKepler, cbMu, CoordUtil::TA);  // or MA???
      dTime = forTime.Subtract(analyticEpoch) * GmatTimeUtil::SECS_PER_DAY;
   }
   else
   {
      cart  = prevAnalyticState;
      dTime = forTime.Subtract(prevAnalyticEpoch) * GmatTimeUtil::SECS_PER_DAY;
   }
   Rvector3 r0    = cart.GetR();
   Rvector3 v0    = cart.GetV();
   Real     rMag  = r0.GetMagnitude();
   Real     vMag  = v0.GetMagnitude();
   Real     alpha = (-vMag * vMag / cbMu) + (2.0 / rMag);
   Real     x0    = -999.999;
   Real     rDotv = r0 * v0;
   
   // Determine initial guess .......
   // for a circle or ellipse
   if (alpha > KEPLER_TOL)  
   {
      x0 = GmatMathUtil::Sqrt(cbMu) * dTime * cbMu;
      if (alpha == 1.0) 
         throw SolarSystemException("Low fidelity model error for body "
                                    + instanceName);
   }
   // for a parabola
   else if (GmatMathUtil::Abs(alpha) < KEPLER_TOL)
   {
      Rvector3 h    = Cross(r0, v0);
      Real     hMag = h.GetMagnitude();
      Real     p    = (hMag * hMag) / cbMu;
      Real     s    = (1.0 / 2.0) * (PI_OVER_TWO - 
                      ATan(3.0 * Sqrt(cbMu / (p * p * p)) * dTime));
      Real     w    = ATan(Pow(Tan(s), (1.0 / 3.0)));
      x0            = Sqrt(p) * 2.0 / Tan(2.0 * w);
   }
   // for a hyperbola
   else if (alpha < -KEPLER_TOL)
   {
      Real     a     = 1.0 / alpha;
      Real     signT;
      if (dTime >= 0.0) signT =  1.0;
      else              signT = -1.0;
      Real     num   = -2.0 * cbMu * alpha * dTime;
      Real     den   = rDotv + signT * Sqrt(-cbMu * a) * 
                       (1.0 - rMag * alpha);
      x0             = signT * Sqrt(-a) * Ln(num / den);
   }
   // Loop until difference falls within tolerance
   Real psi, rVal, xNew;
   Real xn    = x0;
   bool done  = false;
   Real c2    = -999.99;
   Real c3    = -999.99;
   while (!done)
   {
      psi = xn * xn * alpha;
      
      // compute c2 and c3, per Algorithm 1, p. 71
      if (psi > KEPLER_TOL)
      {
         c2 = (1.0 - Cos(Sqrt(psi))) / psi;
         c3 = (Sqrt(psi) - Sin(Sqrt(psi))) / Sqrt(psi * psi * psi);
      }
      else if (psi < -KEPLER_TOL)
      {
         c2 = (1.0 - Cosh(Sqrt(-psi))) / psi;
         c3 = (Sinh(Sqrt(-psi)) - Sqrt(-psi)) / Sqrt((-psi) * (-psi) * (-psi));
      }
      else
      {
         c2 = 1.0 / 2.0;
         c3 = 1.0 / 6.0;
      }
      rVal = (xn * xn * c2) + (rDotv / Sqrt(cbMu)) * xn * (1.0 - psi * c3) +
              rMag * (1.0 - psi * c2);
      xNew = xn + ((Sqrt(cbMu) * dTime) - (xn * xn * xn * c3) - 
                   (rDotv / Sqrt(cbMu)) * (xn * xn * c2) -
                   rMag * xn * (1.0 - psi *c3)) / rVal;
      
      if (Abs(xn - xNew) < KEPLER_TOL) done = true;
      xn = xNew;
   }
   
   Real f     = 1.0 - ((xn * xn) / rMag) * c2;
   Real g     = dTime - ((xn * xn * xn) / Sqrt(cbMu)) * c3;
   Real gDot  = 1.0 - ((xn * xn) / rVal) * c2;
   Real fDot  = (Sqrt(cbMu) / (rVal * rMag)) * xn * (psi * c3 - 1.0);
   Rvector3 r = f    * r0 + g    * v0;
   Rvector3 v = fDot * r0 + gDot * v0;
   
   if (!IsEqual((f * gDot - g * fDot), 1.0, 1.0e-9))
      throw SolarSystemException(
            "Error computing low fidelity ephemeris for body "
            + instanceName);
   
   Rvector6 newState(r,v);
   prevAnalyticEpoch = forTime;
   prevAnalyticState = newState;
   newAnalytic       = false;
   /* debug stuff
   static std::ofstream foutMarsFromEarth;
   static bool first = true;
   if (first)
   {
      foutMarsFromEarth.open("./TestLowMarsData.out");
      foutMarsFromEarth.setf(ios::fixed);
      foutMarsFromEarth.precision(30);
      first = false;
   }
   if (instanceName == SolarSystem::MARS_NAME)
   {
      Real  td = (Real) forTime.Subtract(lfEpoch) * GmatTimeUtil::SECS_PER_DAY;
      foutMarsFromEarth << td << "  " << newState[0] << " " << newState[1] << " " << newState[2]
         << "  " << newState[3] << " " << newState[4] << " " << newState[5] << std::endl;

   }
   */
   
   return newState;
}

//------------------------------------------------------------------------------
// private methods
//------------------------------------------------------------------------------
// none at this time
