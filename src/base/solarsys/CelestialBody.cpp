//$Header$
//------------------------------------------------------------------------------
//                                  CelestialBody
//------------------------------------------------------------------------------
// GMAT: Goddard Mission Analysis Tool.
//
// Author: Wendy C. Shoan
// Created: 2004/01/28
//
/**
 * Implementation of the CelestialBody class.
 *
 * @note This is an abstract class.
 *
 * @note GetHourAngle currently only handles Earth data.
 * @note Class (initial shell only) automatically generated by Dev-C++ New
 *       Class wizard (heavily modified after that)
 */
//------------------------------------------------------------------------------


#include <iostream>
#include <fstream>
#include <sstream>
#include <iomanip>
#include "gmatdefs.hpp"
#include "SpacePoint.hpp"
#include "CelestialBody.hpp"
#include "PlanetaryEphem.hpp"
#include "SolarSystemException.hpp"
#include "PlanetaryEphemException.hpp"
#include "Rvector3.hpp"
#include "Rvector6.hpp"
#include "Rmatrix.hpp"
#include "AtmosphereModel.hpp"
#include "MessageInterface.hpp"
#include "PhysicalConstants.hpp"
#include "TimeSystemConverter.hpp"
#include "UtcDate.hpp"
#include "TimeTypes.hpp"
#include "AngleUtil.hpp"

using namespace GmatMathUtil;
using namespace std; 

//---------------------------------
// static data
//---------------------------------
const std::string
CelestialBody::PARAMETER_TEXT[CelestialBodyParamCount - SpacePointParamCount] =
{
   "BodyType",
   "Mass",
   "EquatorialRadius",
   "Flattening",
   "PolarRadius",
   "Mu",
   "PosVelSOurce",
   "AnalyticMethod",
   "State",
   "StateTime",
   //"Order",
   //"Degree",
   "CentralBody",
   "BodyNumber",
   "RefBodyNumber",
   "SourceFilename",
   "SourceFile",
   "UsePotentialFileFlag",
   "PotentialFileName",
   "AngularVelocity",
   //"CoefficientSize",
   //"Sij",
   //"Cij",
   "HourAngle",
   "AtmosphereModelName",
   //"SupportedAtmosModels",
};

const Gmat::ParameterType
CelestialBody::PARAMETER_TYPE[CelestialBodyParamCount - SpacePointParamCount] =
{
Gmat::STRING_TYPE,
Gmat::REAL_TYPE,
Gmat::REAL_TYPE,
Gmat::REAL_TYPE,
Gmat::REAL_TYPE,
Gmat::REAL_TYPE,
Gmat::STRING_TYPE,
Gmat::STRING_TYPE,
Gmat::RVECTOR_TYPE,
Gmat::A1MJD_TYPE,
//Gmat::INTEGER_TYPE,
//Gmat::INTEGER_TYPE,
Gmat::STRING_TYPE,
Gmat::INTEGER_TYPE,
Gmat::INTEGER_TYPE,
Gmat::STRING_TYPE,
Gmat::OBJECT_TYPE,
Gmat::BOOLEAN_TYPE,
Gmat::STRING_TYPE,
Gmat::RVECTOR3_TYPE,
//Gmat::INTEGER_TYPE,
//Gmat::RMATRIX_TYPE,
//Gmat::RMATRIX_TYPE,
Gmat::REAL_TYPE,
Gmat::STRING_TYPE,
//Gmat::STRINGARRAY_TYPE,
};


const std::string CelestialBody::BODY_TYPE_STRINGS[Gmat::BodyTypeCount] =
{
   "Star", "Planet", "Moon", "Asteroid", "Comet"
};

const std::string CelestialBody::POS_VEL_STRINGS[Gmat::PosVelSourceCount] =
{
   "Analytic", "SLP", "DE_200", "DE_405"   // add more as implemented
};

const std::string CelestialBody::ANALYTIC_METHOD_STRINGS[Gmat::AnalyticMethodCount] =
{
   "NoAnalyticMethod", "TwoBody", "EarthAnalytic", "MoonAnalytic", "NumAnalytic"
};

//------------------------------------------------------------------------------
// public methods
//------------------------------------------------------------------------------
//------------------------------------------------------------------------------
//  CelestialBody(std::string itsBodyType, std::string name)
//------------------------------------------------------------------------------
/**
 * This method creates an object of the CelestialBody class
 * (additional constructor).
 *
 * @param <itsBodyType> string representation of its body type
 * @param <name> parameter indicating the name of the celestial body.
 */
//------------------------------------------------------------------------------
CelestialBody::CelestialBody(std::string itsBodyType, std::string name) :
SpacePoint(Gmat::CELESTIAL_BODY, itsBodyType, name)
{
   parameterCount = CelestialBodyParamCount;
   Initialize(itsBodyType);
}

//------------------------------------------------------------------------------
//  CelestialBody(Gmat::BodyType itsBodyType, std::string name)
//------------------------------------------------------------------------------
/**
 * This method creates an object of the CelestialBody class
 * (additional constructor).
 *
 * @param <itsBodyType> its body type
 * @param <name> parameter indicating the name of the celestial body.
 */
//------------------------------------------------------------------------------
CelestialBody::CelestialBody(Gmat::BodyType itsBodyType, std::string name) :
SpacePoint(Gmat::CELESTIAL_BODY,
           CelestialBody::BODY_TYPE_STRINGS[itsBodyType], name)
{
   parameterCount = CelestialBodyParamCount;
   Initialize(CelestialBody::BODY_TYPE_STRINGS[itsBodyType]);
}

//------------------------------------------------------------------------------
//  CelestialBody(const CelestialBody &cb)
//------------------------------------------------------------------------------
/**
 * This method creates an object of the CelestialBody class as a copy of the
 * specified CelestialBody class (copy constructor).
 *
 * @param <cb> CelestialBody object to copy.
 */
//------------------------------------------------------------------------------
CelestialBody::CelestialBody(const CelestialBody &cb) :
SpacePoint          (cb),
bodyType            (cb.bodyType),
mass                (cb.mass),
equatorialRadius    (cb.equatorialRadius),
flattening          (cb.flattening),
polarRadius         (cb.polarRadius),
mu                  (cb.mu),
posVelSrc           (cb.posVelSrc),
analyticMethod      (cb.analyticMethod),
centralBody         (cb.centralBody),
bodyNumber          (cb.bodyNumber),
referenceBodyNumber (cb.referenceBodyNumber),
sourceFilename      (cb.sourceFilename),
theSourceFile       (cb.theSourceFile), // ????????????????
usePotentialFile    (cb.usePotentialFile),
potentialFileName   (cb.potentialFileName),
hourAngle           (cb.hourAngle),
//coefficientSize     (cb.coefficientSize),
//dCbar               (cb.dCbar),
//dSbar               (cb.dSbar),
order               (cb.order),
degree              (cb.degree),
sij                 (cb.sij),
cij                 (cb.cij)//,
//atmModel            (cb.atmModel)
{
   
   state                  = cb.state;
   stateTime              = cb.stateTime;
   angularVelocity        = cb.angularVelocity;
   defaultMu              = cb.defaultMu;
   defaultEqRadius        = cb.defaultEqRadius;
   potentialFileRead      = false;
   if (cb.atmModel)
   {
      if (atmModel) delete atmModel;   // do I want to do this?
      atmModel = (AtmosphereModel*)(cb.atmModel)->Clone();
   }
   else
      atmModel = NULL;
   //defaultCoefSize        = cb.defaultCoefSize;
   //defaultSij             = cb.defaultSij;
   //defaultCij             = cb.defaultCij;
}

//------------------------------------------------------------------------------
//  CelestialBody& operator= (const CelestialBody& cb)
//------------------------------------------------------------------------------
/**
 * Assignment operator for the CelestialBody class.
 *
 * @param <cb> the CelestialBody object whose data to assign to "this"
 *            solar system.
 *
 * @return "this" CelestialBody with data of input CelestialBody cb.
 */
//------------------------------------------------------------------------------
CelestialBody& CelestialBody::operator=(const CelestialBody &cb)
{
   if (&cb == this)
      return *this;

   SpacePoint::operator=(cb);
   bodyType            = cb.bodyType;
   mass                = cb.mass;
   equatorialRadius    = cb.equatorialRadius;
   flattening          = cb.flattening;
   polarRadius         = cb.polarRadius;
   mu                  = cb.mu;
   posVelSrc           = cb.posVelSrc;
   analyticMethod      = cb.analyticMethod;
   state               = cb.state;
   stateTime           = cb.stateTime;
   centralBody         = cb.centralBody;
   bodyNumber          = cb.bodyNumber;
   referenceBodyNumber = cb.referenceBodyNumber;
   sourceFilename      = cb.sourceFilename;
   theSourceFile       = cb.theSourceFile;   // ??????????????
   usePotentialFile    = cb.usePotentialFile;
   potentialFileName   = cb.potentialFileName;
   angularVelocity     = cb.angularVelocity;
   hourAngle           = cb.hourAngle;
   if (cb.atmModel)
   {
      if (atmModel) delete atmModel;   // do I want to do this?
      atmModel = (AtmosphereModel*)(cb.atmModel)->Clone();
   }
   else
      atmModel = NULL;
   potentialFileRead   = false;
   defaultMu           = cb.defaultMu;
   defaultEqRadius     = cb.defaultEqRadius;

   //coefficientSize     = cb.coefficientSize;  // what about all of these?
   //sij                 = cb.sij;
   //cij                 = cb.cij;
   //dCbar               = cb.dCbar;
   //dSbar               = cb.dSbar;
   //order               = cb.order;
   //degree              = cb.degree;
   return *this;
}

//------------------------------------------------------------------------------
//  ~CelestialBody()
//------------------------------------------------------------------------------
/**
 * Destructor for the CelestialBody class.
 */
//------------------------------------------------------------------------------
CelestialBody::~CelestialBody()
{
   delete atmModel;  
}

//------------------------------------------------------------------------------
//  const Rvector6& GetState(A1Mjd atTime)
//------------------------------------------------------------------------------
/**
 * This method returns the state (position and velocity) of the body at the
 * requested time.
 *
 * @param <atTime>  time for which state of the body is requested.
 *
 * @return state of the body at the requested time.
 *
 * @exception <PlanetaryEphemException> thrown when the requested Pos/Vel
 *            source is set to SLP or DE***, but the source file has not
 *            been set.
 *
 */
//------------------------------------------------------------------------------
const Rvector6&  CelestialBody::GetState(A1Mjd atTime)
{
   Real*     posVel = NULL;
   switch (posVelSrc)
   {
      case Gmat::SLP :
//      case Gmat::DE_102 :
      case Gmat::DE_200 :
//      case Gmat::DE_202 :
//      case Gmat::DE_403 :
      case Gmat::DE_405 :
//      case Gmat::DE_406 :
         if (!theSourceFile)
         {
            throw PlanetaryEphemException(
                  "SLP or DE file requested, but no file specified");
         }
         // figure out the ID of the body
         bodyNumber = theSourceFile->GetBodyID(instanceName);
         posVel     = theSourceFile->GetPosVel(bodyNumber,atTime);
         break;
      case Gmat::ANALYTIC :
         switch (analyticMethod)
         {
            case Gmat::NO_ANALYTIC_METHOD :
               throw SolarSystemException("No analytic method specified for body " +
                                          instanceName);
            case Gmat::TWO_BODY :
               // call the two body stuff here ...........
               break;
            case Gmat::EARTH_ANALYTIC :
               // call the earth analytic stuff here ....... but what is it?
               break;
            case Gmat::MOON_ANALYTIC :
               // call the moon analytic stuff here ........ but what is it?
               break;
            case Gmat::NUM_ANALYTIC :
               // call the num analytic stuff here ......... but what is it?
               break;
            default:
               break;
         }
//      case Gmat::EPHEMERIS :  
//         break; // other cases later <<<<<<<<<<<<<<<<
      default:
         break;
   }
   stateTime  = atTime;
   state.SetElement(0,posVel[0]);
   state.SetElement(1,posVel[1]);
   state.SetElement(2,posVel[2]);
   state.SetElement(3,posVel[3]);
   state.SetElement(4,posVel[4]);
   state.SetElement(5,posVel[5]);
   return state;
}

//------------------------------------------------------------------------------
//  const Rvector6& GetState(Real atTime)
//------------------------------------------------------------------------------
 /**
 * This method returns the state (position and velocity) of the body at the
 * requested time.
 *
 * @param <atTime>  time for which state of the body is requested.
 *
 * @return state of the body at the requested time.
 *
 * @exception <PlanetaryEphemException> thrown when the requested Pos/Vel
 *            source is set to SLP or DE***, but the source file has not
 *            been set.
 *
 */
//------------------------------------------------------------------------------
const Rvector6&  CelestialBody::GetState(Real atTime)
{
   A1Mjd forTime(atTime);
   return GetState(forTime);
}
   
//------------------------------------------------------------------------------
//  Gmat::BodyType GetBodyType() const
//------------------------------------------------------------------------------
/**
 * This method returns the body type of the body.
 *
 * @return body type of the body.
 *
 */
//------------------------------------------------------------------------------
Gmat::BodyType CelestialBody::GetBodyType() const
{
   return bodyType;
}

//------------------------------------------------------------------------------
//  const std::string& GetCentralBody() const
//------------------------------------------------------------------------------
/**
 * This method returns the name of the central body of the body.
 *
 * @return name of the central body of the body.
 *
 */
//------------------------------------------------------------------------------
const std::string& CelestialBody::GetCentralBody() const
{
   return centralBody;
}

//------------------------------------------------------------------------------
//  Real GetGravitationalConstant() 
//------------------------------------------------------------------------------
/**
 * This method returns the gravitational constant (km^3/s^2) of the body.
 *
 * @return gravitational constant of the body.
 *
 */
//------------------------------------------------------------------------------
Real CelestialBody::GetGravitationalConstant() 
{
   //loj: 5/6/04 temp. code to show message only first time
   static bool firstTimeMu = true;
   
   if (usePotentialFile == true)
   {
      if (!potentialFileRead)
      {
         if (!ReadPotentialFile())
         {
            if (firstTimeMu)
            {
               MessageInterface::ShowMessage(
               "For body %s, cannot read file \"%s\", so using default value (%lf) for mu\n",
               instanceName.c_str(), potentialFileName.c_str(), defaultMu);
               firstTimeMu = false;
            }
         
            mu = defaultMu;
         }
         //throw SolarSystemException(
         //   "Cannot read potential file to get gravitational constant.");
      }
   }
   //else
   //{
   //   mu = defaultMu;
   //}
   // recompute mass
   mass = mu / GmatPhysicalConst::UNIVERSAL_GRAVITATIONAL_CONSTANT;
   return mu;
}

//------------------------------------------------------------------------------
//  Real GetEquatorialRadius() 
//------------------------------------------------------------------------------
/**
* This method returns the equatorial radius (km) of the body.
 *
 * @return equatorial radius of the body.
 *
 */
//------------------------------------------------------------------------------
Real CelestialBody::GetEquatorialRadius() 
{
   //loj: 5/6/04 temp. code to show message only first time
   static bool firstTimeRadius = true;
   
   if ((usePotentialFile == true) && (!potentialFileRead))
   {
      if (!ReadPotentialFile())
      {
         if (firstTimeRadius)
         {
             MessageInterface::ShowMessage(
              "For body %s, cannot read file \"%s\", so using default value (%lf) for radius\n",
               instanceName.c_str(), potentialFileName.c_str(), defaultEqRadius);
            firstTimeRadius = false;
         }
         equatorialRadius = defaultEqRadius;
      }
      //throw SolarSystemException(
      //   "Cannot read potential file to get equatorial radius.");
   }
   // recompute the polar radius
   polarRadius = (1.0 - flattening) * equatorialRadius;
   return equatorialRadius;
}

//------------------------------------------------------------------------------
//  Real GetFlattening() const
//------------------------------------------------------------------------------
/**
 * This method returns the flattening value of the body.
 *
 * @return flattening of the body.
 *
 */
//------------------------------------------------------------------------------
Real CelestialBody::GetFlattening() const
{
   return flattening;
}

//------------------------------------------------------------------------------
//  Real GetPolarRadius() 
//------------------------------------------------------------------------------
/**
 * This method returns the polar radius (km) of the body.
 *
 * @return polar radius of the body.
 *
 */
//------------------------------------------------------------------------------
Real CelestialBody::GetPolarRadius() 
{
   // make sure it is computed correctly
   polarRadius = (1.0 - flattening) * equatorialRadius;
   return polarRadius;   
}

//------------------------------------------------------------------------------
//  Real GetMass() 
//------------------------------------------------------------------------------
/**
 * This method returns the mass (kg) of the body.
 *
 * @return mass of the body.
 *
 */
//------------------------------------------------------------------------------
 Real CelestialBody::GetMass() 
{
   // make sure it is computed correctly
   mass = mu / GmatPhysicalConst::UNIVERSAL_GRAVITATIONAL_CONSTANT;
   return mass;
}

//------------------------------------------------------------------------------
//  Gmat::PosVelSource GetPosVelSource() const
//------------------------------------------------------------------------------
/**
 * This method returns the source of position and velocity for the body.
 *
 * @return position/velocity source for the body.
 *
 */
//------------------------------------------------------------------------------
Gmat::PosVelSource  CelestialBody::GetPosVelSource() const
{
   return posVelSrc;
}

//------------------------------------------------------------------------------
//  Gmat::AnalyticMethod GetAnalyticMethod() const
//------------------------------------------------------------------------------
/**
 * This method returns the analytic method used for the body.
 *
 * @return analytic method for the body.
 *
 */
//------------------------------------------------------------------------------
Gmat::AnalyticMethod CelestialBody::GetAnalyticMethod() const
{
   return analyticMethod;
}

//------------------------------------------------------------------------------
//  bool CelestialBody::GetUsePotentialFile() const
//------------------------------------------------------------------------------
/**
 * This method returns the flag indicating whether to use the potential file
 * or not used for the body.
 *
 * @return flag indicating whether or not to use the potential file to determine
 *         mu, radius, and spherical harmonic coefficients.
 *
 */
//------------------------------------------------------------------------------
bool CelestialBody::GetUsePotentialFile() const
{
   return usePotentialFile;
}

//------------------------------------------------------------------------------
//  const Rvector3& CelestialBody::GetAngularVelocity() 
//------------------------------------------------------------------------------
/**
 * This method returns the angular velocity for the body.
 *
 * @return angular velocity (Real[3]) for the body.
 *
 */
//------------------------------------------------------------------------------
const Rvector3& CelestialBody::GetAngularVelocity() 
{
   return angularVelocity; 
}


//------------------------------------------------------------------------------
//  Real CelestialBody::GetHourAngle(A1Mjd atTime)
//------------------------------------------------------------------------------
/**
 * This method returns the hour angle for the body, referenced from the
 * Prime Meridian, measured westward
 *
 * @param <atTime> time for which to compute the hour angle
 *
 * @return hour angle for the body, in degrees, from the Prime Meridian
 *
 * @note algorithm 15, Vallado p. 192
 * @todo move this to Planet?  Add generic calculation here.
 *
 */
//------------------------------------------------------------------------------
Real  CelestialBody:: GetHourAngle(A1Mjd atTime) 
{
   // Convert the time to a UT1 MJD
   Ut1Mjd ut1Time  = atTime.ToUt1Mjd();
   // Now convert to UT1 Julian Date
   Real ut1Jd      = ((Real) ut1Time) + GmatTimeUtil::JULIAN_DATE_OF_010541;
   Real timeUt1    = (ut1Jd - 2451545.0) / 36525;

   // compute mean sidereal time, in degrees
   // according to Vallado Eq. 3-45, converted to degrees, where
   // 1 hour = 15 degrees and 1 second = 1/240 of a second

   Real mst        = (67310.54841 / 240) +
      (((876600 * 15) + (8640184.812866 / 240)) * timeUt1) +
      ((0.093104 / 240) * timeUt1 * timeUt1) -
      ((6.2e-06 / 240) * timeUt1 * timeUt1 * timeUt1);

   // reduce to a quantity within one day (86400 seconds, 360.0 degrees)
   hourAngle = AngleUtil::PutAngleInDegRange(mst,0.0,360.0);

   return hourAngle; 
}

//------------------------------------------------------------------------------
//  const Rmatrix& GetHarmonicCoefficientsSij() 
//------------------------------------------------------------------------------
/**
 * This method returns the spherical harmonic coefficients sij for the body.  It
 * will read the potential file if that is requested.
 *
 * @return sij spherical harmonic coefficients for the body.
 *
 *
 * @exception <SolarSystemException> thown if there is an error getting the data.
 */
//------------------------------------------------------------------------------
const Rmatrix& CelestialBody::GetHarmonicCoefficientsSij() 
{
//   if ((usePotentialFile == true) & (!potentialFileRead))
//   {
//      bool OK = ReadPotentialFile();
//      if (!OK) throw SolarSystemException("Unable to read potential file"); 
//   }
   return sij;
}

//------------------------------------------------------------------------------
//  const Rmatrix& GetHarmonicCoefficientsCij() 
//------------------------------------------------------------------------------
/**
 * This method returns the spherical harmonic coefficients cij for the body.  It
 * will read the potential file if that is requested.
 *
 * @return cij spherical harmonic coefficients for the body.
 *
 * @exception <SolarSystemException> thown if there is an error getting the data.
 */
//------------------------------------------------------------------------------
const Rmatrix& CelestialBody::GetHarmonicCoefficientsCij() 
{
//   if ((usePotentialFile == true) & (!potentialFileRead))
//   {
//      bool OK = ReadPotentialFile();
//      if (!OK) throw SolarSystemException("Unable to read potential file");
//   }
   return cij;
}

//------------------------------------------------------------------------------
//  const Rmatrix& GetCoefDriftS()
//------------------------------------------------------------------------------
/**
 * This method returns the dSbar coefficient drift matrix for the body.  It
 * will read the potential file if that is requested.
 *
 * @return dSbar  coefficient drift matrix for the body.
 *
 * @exception <SolarSystemException> thown if there is an error getting the data.
 */
//------------------------------------------------------------------------------
//const Rmatrix& CelestialBody::GetCoefDriftS()
//{
//   if ((usePotentialFile == true) & (!potentialFileRead))
//   {
//      bool OK = ReadPotentialFile();
//      if (!OK) throw SolarSystemException("Unable to read potential file");
//   }
//   return dSbar;
//}

//------------------------------------------------------------------------------
//  const Rmatrix& GetCoefDriftC()
//------------------------------------------------------------------------------
/**
 * This method returns the dCbar coefficient drift matrix for the body.  It
 * will read the potential file if that is requested.
 *
 * @return dCbar  coefficient drift matrix for the body.
 *
 * @exception <SolarSystemException> thown if there is an error getting the data.
 */
//------------------------------------------------------------------------------
//const Rmatrix& CelestialBody::GetCoefDriftC()
//{
//   if ((usePotentialFile == true) & (!potentialFileRead))
//   {
//      bool OK = ReadPotentialFile();
//      if (!OK) throw SolarSystemException("Unable to read potential file");
//   }
//   return dCbar;
//}

//------------------------------------------------------------------------------
// Integer GetDegree()
//------------------------------------------------------------------------------
/**
 * This method returns the degree of the gravity coefficients for the body.  It
 * will read the potential file if that is requested.
 *
 * @return degree  degree of the coefficients for the body.
 *
 * @exception <SolarSystemException> thown if there is an error getting the data.
 */
//------------------------------------------------------------------------------
Integer CelestialBody::GetDegree()
{
//   if ((usePotentialFile == true) & (!potentialFileRead))
//   {
//      bool OK = ReadPotentialFile();
//      if (!OK) throw SolarSystemException("Unable to read potential file");
//   }
   return degree;
}

//------------------------------------------------------------------------------
// Integer GetOrder()
//------------------------------------------------------------------------------
/**
 * This method returns the order of the gravity coefficients for the body.  It
 * will read the potential file if that is requested.
 *
 * @return degree  order of the coefficients for the body.
 *
 * @exception <SolarSystemException> thown if there is an error getting the data.
 */
//------------------------------------------------------------------------------
Integer CelestialBody::GetOrder()
{
//   if ((usePotentialFile == true) & (!potentialFileRead))
//   {
//      bool OK = ReadPotentialFile();
//      if (!OK) throw SolarSystemException("Unable to read potential file");
//   }
   return order;
}

//------------------------------------------------------------------------------
//  std::string GetAtmosphereModelType()
//------------------------------------------------------------------------------
/**
 * This method returns the name (type) of the current atmosphere model for
 * the body.
 *
 * @return the name (type) of the current atmosphere model for the body.
 *
 */
//------------------------------------------------------------------------------
std::string  CelestialBody::GetAtmosphereModelType()
{
   // DJC added the following 2 lines:
   if (!atmModel)
      return "Undefined";

   return atmModel->GetTypeName();  // or should I go through the AtmManager?
}

//------------------------------------------------------------------------------
//  AtmosphereModel* GetAtmosphereModel()
//------------------------------------------------------------------------------
/**
 * This method returns a pointer to the current atmosphere model for the body.
 *
 * @return a pointer to the current atmosphere model for the body.
 *
 */
//------------------------------------------------------------------------------
AtmosphereModel* CelestialBody::GetAtmosphereModel()
{
   return atmModel;
      
}

//------------------------------------------------------------------------------
//  bool GetDensity(Real *position, Real *density, Real epoch, Integer count)
//------------------------------------------------------------------------------
/**
 * Calculates the atmospheric density at a specified location.
 *
 * Density if the core calculation provided by classes derived from this one.
 * The outpur array, density, must contain the density at the requested
 * locations, expressed in kg / m^3.
 *
 *  @param position  The input vector of spacecraft states
 *  @param density   The array of output densities
 *  @param epoch     The current TAIJulian epoch
 *  @param count     The number of spacecraft contained in position
 */
//------------------------------------------------------------------------------
bool CelestialBody::GetDensity(Real *position, Real *density, Real epoch,
                               Integer count)
{
   if (!atmModel) return false;
   return atmModel->Density(position,density,epoch,count);
}

//------------------------------------------------------------------------------
//  bool SetBodyType(Gmat::BodyType bType)
//------------------------------------------------------------------------------
/**
 * This method sets the body type for the body.
 *
 * @param <bType> body type for the body.
 *
 * @return flag indicating success of the method.
 *
 */
//------------------------------------------------------------------------------
bool CelestialBody::SetBodyType(Gmat::BodyType bType)
{
   return (bodyType = bType); // will need to change default parameters here too, if they
                     // are set to values that make no sense for this type of body?
}

//------------------------------------------------------------------------------
//  bool SetCentralBody(const std::string &cBody)
//------------------------------------------------------------------------------
/**
 * This method sets the central body for the body.
 *
 * @param <cBody> central body name for the body.
 *
 * @return flag indicating success of the method.
 *
 */
//------------------------------------------------------------------------------
bool CelestialBody::SetCentralBody(const std::string &cBody)
{
   centralBody = cBody;
   return true;
}

//------------------------------------------------------------------------------
//  bool SetGravitationalConstant(Real newMu)
//------------------------------------------------------------------------------
/**
 * This method sets the gravitational constant for the body.
 *
 * @param <newMw> gravitational constant (km^3/s^2) for the body.
 *
 * @return flag indicating success of the method.
 *
 */
//------------------------------------------------------------------------------
bool CelestialBody::SetGravitationalConstant(Real newMu)
{
   mu   = newMu;
   mass = mu / GmatPhysicalConst::UNIVERSAL_GRAVITATIONAL_CONSTANT;
   return true;
}

//------------------------------------------------------------------------------
//  bool SetEquatorialRadius(Real newEqRadius)
//------------------------------------------------------------------------------
/**
 * This method sets the equatorial radius for the body.
 *
 * @param <newEqRadius> equatorial radius (km) for the body.
 *
 * @return flag indicating success of the method.
 *
 */
//------------------------------------------------------------------------------
bool CelestialBody::SetEquatorialRadius(Real newEqRadius)
{
   equatorialRadius = newEqRadius;
   polarRadius      = (1.0 - flattening) * equatorialRadius;
   return true;
}

//------------------------------------------------------------------------------
//  bool SetFlattening(Real flat)
//------------------------------------------------------------------------------
/**
 * This method sets the flattening value for the body.
 *
 * @param <flat> flattening value for the body.
 *
 * @return flag indicating success of the method.
 *
 */
//------------------------------------------------------------------------------
bool CelestialBody::SetFlattening(Real flat) 
{
   flattening  = flat;
   polarRadius = (1.0 - flattening) * equatorialRadius;
   return true;
}

//------------------------------------------------------------------------------
//  bool SetMass(Real newMass)
//------------------------------------------------------------------------------
/**
 * This method sets the mass for the body.
 *
 * @param <newMass> mass (kg) for the body.
 *
 * @return flag indicating success of the method.
 *
 */
//------------------------------------------------------------------------------
//bool CelestialBody::SetMass(Real newMass) 
//{
//   mass = newMass;
//   return true;
//}

//------------------------------------------------------------------------------
//  bool SetSource(Gmat::PosVelSource pvSrc)
//------------------------------------------------------------------------------
/**
 * This method sets the position/velocity source for the body.
 *
 * @param <pcSrc> position/velocity source for the body.
 *
 * @return flag indicating success of the method.
 *
 */
//------------------------------------------------------------------------------
bool CelestialBody::SetSource(Gmat::PosVelSource pvSrc)
{
   return (posVelSrc = pvSrc);
}

//------------------------------------------------------------------------------
//  bool SetSourceFile(PlanetaryEphem *src)
//------------------------------------------------------------------------------
/**
 * This method sets the position/velocity source file for the body.
 *
 * @param <src> position/velocity source file for the body.
 *
 * @return flag indicating success of the method.
 *
 */
//------------------------------------------------------------------------------
bool CelestialBody::SetSourceFile(PlanetaryEphem *src)
{
   // should I delete the old one here???
   theSourceFile = src;
   sourceFilename = theSourceFile->GetName();
   return true;
}

//------------------------------------------------------------------------------
//  bool SetAnalyticMethod(Gmat::AnalyticMethod aM)
//------------------------------------------------------------------------------
/**
* This method sets the analytic method for the body.
 *
 * @param <aM> analytic method for the body.
 *
 * @return flag indicating success of the method.
 *
 */
//------------------------------------------------------------------------------
bool CelestialBody::SetAnalyticMethod(Gmat::AnalyticMethod aM)
{
   return (analyticMethod = aM); 
}

//------------------------------------------------------------------------------
//  bool SetUsePotentialFile(bool useIt)
//------------------------------------------------------------------------------
/**
 * This method sets the flag indicating whether or not to get the mu, radius,
 * and harmonic coefficients from the potential file.
 *
 * @param <useIt> use the potential file?.
 *
 * @return flag indicating success of the method.
 *
 */
//------------------------------------------------------------------------------
bool CelestialBody::SetUsePotentialFile(bool useIt)
{
   if ((usePotentialFile == false) && (useIt == true))
   {
      potentialFileRead = false;
   }
   else if ((usePotentialFile == true) && (useIt == false))
   {
      mu               = defaultMu;
      equatorialRadius = defaultEqRadius;
      // recompute polar radius
      polarRadius = (1.0 - flattening) * equatorialRadius;
      // recompute mass
      mass = mu / GmatPhysicalConst::UNIVERSAL_GRAVITATIONAL_CONSTANT;
      //coefficientSize  = defaultCoefSize;
      //sij              = defaultSij;
      //cij              = defaultCij;
   }
   return (usePotentialFile = useIt);
}

//------------------------------------------------------------------------------
//  bool SetAtmosphereModelType(std::string toAtmModelType)
//------------------------------------------------------------------------------
/**
* This method sets the atmosphere model type for the body.
 *
 * @param <toAtmModel> name (type) of the atmosphere model to use.
 *
 * @return flag indicating success of the method.
 *
 * @note This method no longer sets the actual atmosphere model pointer.  A call
 *       to SetAtmosphereModel must be executed for that to happen.
 *
 */
//------------------------------------------------------------------------------
bool CelestialBody::SetAtmosphereModelType(std::string toAtmModelType)
{
   atmModelType = toAtmModelType;
   return true;
}

//------------------------------------------------------------------------------
//  bool SetAtmosphereModel(AtmosphereModel *toAtmModel)
//------------------------------------------------------------------------------
/**
 * This method sets the atmosphere model pointer for the body.
 *
 * @param <toAtmModel> pointer to the atmosphere model to use.
 *
 * @return flag indicating success of the method.
 *
 */
//------------------------------------------------------------------------------
bool CelestialBody::SetAtmosphereModel(AtmosphereModel *toAtmModel)
{
   if (atmModel) delete atmModel;
   atmModel = toAtmModel;
   return true;
}


//------------------------------------------------------------------------------
//  bool SetPotentialFilename(const std::string &fn)
//------------------------------------------------------------------------------
/**
 * This method sets potential file name for this HarmonicField object.
 *
 * @param <fn> full path name of the potential file name to use.
 *
 * @return flag indicating success of the operation.
 */
//------------------------------------------------------------------------------
bool CelestialBody::SetPotentialFilename(const std::string &fn)
{
   if (potentialFileName != fn) potentialFileRead = false;
   potentialFileName = fn;
   return true;
}

const Rvector6 CelestialBody::GetMJ2000State(const A1Mjd &atTime)
{
   // If j2000Body is this body, return the zero state vector
   if(j2000Body->GetName() == instanceName) 
      return Rvector6(0.0, 0.0, 0.0, 0.0, 0.0, 0.0);

   Rvector6         stateEphem    = GetState(atTime);
   Rvector6         j2kEphemState;
   Gmat::ObjectType ot            = j2000Body->GetType();
   if (ot == Gmat::CELESTIAL_BODY)
   {
      j2kEphemState = ((CelestialBody*)j2000Body)->GetState(atTime);
   }
   else if (ot == Gmat::CALCULATED_POINT)
   {
      // fill in with calculated point stuff when it's done
      //j2kEphemState = ((CalculatedPoint*)j2000Body)->GetState(atTime);
   }
   else
   {
      throw SolarSystemException("j2000Body is of incorrect type.");
   }
   
   return (stateEphem - j2kEphemState);
   
}
const Rvector3 CelestialBody::GetMJ2000Position(const A1Mjd &atTime)
{
   Rvector6 tmp = GetMJ2000State(atTime);
   return (tmp.GetR());
}

const Rvector3 CelestialBody::GetMJ2000Velocity(const A1Mjd &atTime)
{
   Rvector6 tmp = GetMJ2000State(atTime);
   return (tmp.GetV());
}

//------------------------------------------------------------------------------
//  Rvector3 GetBodyCartographicCoordinates(const A1Mjd &forTime) const
//------------------------------------------------------------------------------
/**
 * This method returns the cartographic coordinates for the body.
 *
 * @return vector containing alpha, delta, W, where:
 *         alpha is the right ascension of the north pole of rotation
 *         delta is the declination of the north pole of rotation
 *         W specifies the ephemeris position of the prime meridian
 *
 * @note currently only implemented for the Star, Planets, and Major Moons of
 *       our Solar System.
 *
 */
//------------------------------------------------------------------------------
Rvector3 CelestialBody::GetBodyCartographicCoordinates(const A1Mjd &forTime) const
{
   // should be implemented in derived classes
   throw SolarSystemException(
         "Cartographic Coordinates not yet computed for body " + instanceName);
}


//------------------------------------------------------------------------------
//  bool SetPhysicalParameters(Real bodyMass, Real bodyEqRad,
//                             Real bodyPolarRad, Real bodyMu,
//                             Integer coeffSize, Rmatrix& bodySij,
//                             Rmatrix& bodyCij);
//------------------------------------------------------------------------------
/**
 * This method sets the physical parameters for the body.
 *
 * @param <bodyMass>     mass (kg) of the body.
 * @param <bodyMEqRad>   equatorial radius (km) of the body.
 * @param <bodyPolarRad> polar radius (km) of the body.
 * @param <bodyMu>       gravitational constant (km^3/s^2) of the body.
 * @param <coeffSize>    size of Sij and Cij for the body.
 * @param <bodySij>      coefficients Sij for the body (coeffSize x coeffSize).
 * @param <bodyCij>      coefficients Cij for the body (coeffSize x coeffSize).
 *
 * @return flag indicating success of the method.
 *
 * @exception <SolarSystemException> thrown if there is an error in the
 *                                   input data.
 */
//------------------------------------------------------------------------------
//bool CelestialBody::SetPhysicalParameters(Real bodyMass, Real bodyEqRad,
//                                          Real bodyPolarRad, Real bodyMu,
//                                          Integer coeffSize, Rmatrix &bodySij,
//                                          Rmatrix &bodyCij)
//{
//   // add data checks later <-
//   mass             = bodyMass;
//   equatorialRadius = bodyEqRad;
//   polarRadius      = bodyPolarRad;
//   mu               = bodyMu;
//   coefficientSize  = coeffSize;
//   Integer r,c;
//   try
//   {
//      bodySij.GetSize(r,c);
//      sij = bodySij;
//   }
//   catch (TableTemplateExceptions::IllegalSize& tte)
//   {
//      throw SolarSystemException("Sij input to body has no dimensions.");
//   }
//   try
//   {
//      bodyCij.GetSize(r,c);
//      cij = bodyCij;
//   }
//   catch (TableTemplateExceptions::IllegalSize& tte)
//   {
//      throw SolarSystemException("Cij input to body has no dimensions.");
//   }
//   return true;
//}
//------------------------------------------------------------------------------
//  std::string  GetParameterText(const Integer id) const
//------------------------------------------------------------------------------
/**
 * This method returns the parameter text, given the input parameter ID.
 *
 * @param <id> Id for the requested parameter text.
 *
 * @return parameter text for the requested parameter.
 *
 */
//------------------------------------------------------------------------------
std::string CelestialBody::GetParameterText(const Integer id) const
{
   if (id >= SpacePointParamCount && id < CelestialBodyParamCount)
      return PARAMETER_TEXT[id - SpacePointParamCount];
   return SpacePoint::GetParameterText(id);
}

//------------------------------------------------------------------------------
//  Integer  GetParameterID(const std::string &str) const
//------------------------------------------------------------------------------
/**
 * This method returns the parameter ID, given the input parameter string.
 *
 * @param <str> string for the requested parameter.
 *
 * @return ID for the requested parameter.
 *
 */
//------------------------------------------------------------------------------
Integer     CelestialBody::GetParameterID(const std::string &str) const
{
   for (Integer i = SpacePointParamCount; i < CelestialBodyParamCount; i++)
   {
      if (str == PARAMETER_TEXT[i - SpacePointParamCount])
         return i;
   }
   
   return SpacePoint::GetParameterID(str);
}

//------------------------------------------------------------------------------
//  Gmat::ParameterType  GetParameterType(const Integer id) const
//------------------------------------------------------------------------------
/**
 * This method returns the parameter type, given the input parameter ID.
 *
 * @param <id> ID for the requested parameter.
 *
 * @return parameter type of the requested parameter.
 *
 */
//------------------------------------------------------------------------------
Gmat::ParameterType CelestialBody::GetParameterType(const Integer id) const
{
   if (id >= SpacePointParamCount && id < CelestialBodyParamCount)
      return PARAMETER_TYPE[id - SpacePointParamCount];
      
   return SpacePoint::GetParameterType(id);
}

//------------------------------------------------------------------------------
//  std::string  GetParameterTypeString(const Integer id) const
//------------------------------------------------------------------------------
/**
 * This method returns the parameter type string, given the input parameter ID.
 *
 * @param <id> ID for the requested parameter.
 *
 * @return parameter type string of the requested parameter.
 *
 */
//------------------------------------------------------------------------------
std::string CelestialBody::GetParameterTypeString(const Integer id) const
{
   return SpacePoint::PARAM_TYPE_STRING[GetParameterType(id)];
}

//------------------------------------------------------------------------------
//  Real  GetRealParameter(const Integer id) const
//------------------------------------------------------------------------------
/**
 * This method returns the Real parameter value, given the input parameter ID.
 *
 * @param <id> ID for the requested parameter value.
 *
 * @return  Real value of the requested parameter.
 *
 */
//------------------------------------------------------------------------------
Real        CelestialBody::GetRealParameter(const Integer id) const
{
   if (id == MASS)               return mass;
   if (id == EQUATORIAL_RADIUS)  return equatorialRadius;
   if (id == FLATTENING)         return flattening;
   if (id == POLAR_RADIUS)       return polarRadius;
   if (id == MU)                 return mu;
   if (id == HOUR_ANGLE)         return hourAngle;

   return SpacePoint::GetRealParameter(id);
}

//------------------------------------------------------------------------------
//  Real  SetRealParameter(const Integer id, const Real value)
//------------------------------------------------------------------------------
/**
 * This method sets the Real parameter value, given the input parameter ID.
 *
 * @param <id> ID for the parameter whose value to change.
 * @param <value> value for the parameter.
 *
 * @return  Real value of the requested parameter.
 *
 */
//------------------------------------------------------------------------------
Real        CelestialBody::SetRealParameter(const Integer id, const Real value)
{
   //if (id == MASS)              return (mass               = value); // make sense?
   if (id == EQUATORIAL_RADIUS)
   {
      equatorialRadius = value;
      polarRadius = (1.0 - flattening) * equatorialRadius;
      return true;
   }
   if (id == FLATTENING)
   {
      flattening = value;
      polarRadius = (1.0 - flattening) * equatorialRadius;
      return true;
   }
   //if (id == POLAR_RADIUS)      return (polarRadius        = value); // make sense?
   if (id == MU)                return (mu                 = value);
   if (id == HOUR_ANGLE)        return (hourAngle          = value);
   
   return SpacePoint::SetRealParameter(id, value);
}

//------------------------------------------------------------------------------
//  Integer  GetIntegerParameter(const Integer id) const
//------------------------------------------------------------------------------
/**
 * This method returns the Integer parameter value, given the input
 * parameter ID.
 *
 * @param <id> ID for the requested parameter.
 *
 * @return  Integer value of the requested parameter.
 *
 */
//------------------------------------------------------------------------------
Integer     CelestialBody::GetIntegerParameter(const Integer id) const
{
   //if (id == ORDER)                return order;
   //if (id == DEGREE)               return degree;
   if (id == BODY_NUMBER)          return bodyNumber;
   if (id == REF_BODY_NUMBER)      return referenceBodyNumber;
  // if (id == COEFFICIENT_SIZE)     return coefficientSize;
   
   return SpacePoint::GetIntegerParameter(id); // add others in later?
}

//------------------------------------------------------------------------------
//  Integer  SetIntegerParameter(const Integer id, const Integer value)
//------------------------------------------------------------------------------
/**
 * This method sets the Integer parameter value, given the input
 * parameter ID.
 *
 * @param <id> ID for the requested parameter.
 * @param <value> Integer value for the requested parameter.
 *
 * @return  Integer value of the requested parameter.
 *
 */
//------------------------------------------------------------------------------
Integer     CelestialBody::SetIntegerParameter(const Integer id,
                                        const Integer value) // const?
{
   //if (id == ORDER)                return (order               = value);
   //if (id == DEGREE)               return (degree              = value);
   if (id == BODY_NUMBER)          return (bodyNumber          = value);
   if (id == REF_BODY_NUMBER)      return (referenceBodyNumber = value);
   //if (id == COEFFICIENT_SIZE)     return (coefficientSize     = value);
   
   return SpacePoint::SetIntegerParameter(id,value);  // add others in later
}

//------------------------------------------------------------------------------
//  std::string  GetStringParameter(const Integer id) const
//------------------------------------------------------------------------------
/**
 * This method returns the string parameter value, given the input
 * parameter ID.
 *
 * @param <id> ID for the requested parameter.
 *
 * @return  string value of the requested parameter.
 *
 */
//------------------------------------------------------------------------------
std::string CelestialBody::GetStringParameter(const Integer id) const
{
   if (id == BODY_TYPE)             return BODY_TYPE_STRINGS[bodyType];
   if (id == POS_VEL_SOURCE)        return POS_VEL_STRINGS[posVelSrc];
   if (id == ANALYTIC_METHOD)       return ANALYTIC_METHOD_STRINGS[analyticMethod];
   if (id == SOURCE_FILENAME)       return sourceFilename;
   if (id == POTENTIAL_FILE_NAME)   return potentialFileName;
   if (id == ATMOS_MODEL_NAME)
   {
      if (atmModel == NULL) return "";
      return atmModel->GetTypeName();
   }
   if (id == CENTRAL_BODY)          return centralBody;

   return SpacePoint::GetStringParameter(id);
}

//------------------------------------------------------------------------------
//  std::string  SetStringParameter(const Integer id, const std::string value)
//------------------------------------------------------------------------------
/**
 * This method sets the string parameter value, given the input
 * parameter ID.
 *
 * @param <id> ID for the requested parameter.
 * @param <value> string value for the requested parameter.
 *
 * @return  success flag.
 *
 */
//------------------------------------------------------------------------------
bool        CelestialBody::SetStringParameter(const Integer id,
                                       const std::string &value) // const?
{
   int i;
   if (id == BODY_TYPE)
   {
      for (i=0;i<Gmat::BodyTypeCount;i++)
         if (value == BODY_TYPE_STRINGS[i])
         {
            bodyType = (Gmat::BodyType) i;
            return true;
         }
      return false;
   }
   if (id == POS_VEL_SOURCE)
   {
      for (i=0;i<Gmat::PosVelSourceCount;i++)
         if (value == POS_VEL_STRINGS[i])
         {
            posVelSrc = (Gmat::PosVelSource) i;
            return true;
         }
      return false;
   }
   if (id == ANALYTIC_METHOD)
   {
      for (i=0;i<Gmat::AnalyticMethodCount;i++)
         if (value == ANALYTIC_METHOD_STRINGS[i])
         {
            analyticMethod = (Gmat::AnalyticMethod) i;
            return true;
         }
      return false;
   }
   if (id == SOURCE_FILENAME)
   {
      sourceFilename = value;
      return true;
   }
   if (id == POTENTIAL_FILE_NAME)
   {
      potentialFileName = value;
      return true;
   }
   if (id == ATMOS_MODEL_NAME)
   {
      atmModelType = value;
      return true;
      //return SetAtmosphereModel(value);
   }
   if (id == CENTRAL_BODY)
   {
      centralBody = value;
      return true;
   }
   
   return SpacePoint::SetStringParameter(id, value);
}

//------------------------------------------------------------------------------
//  bool  GetBooleanParameter(const Integer id) const
//------------------------------------------------------------------------------
/**
 * This method returns the bool parameter value, given the input
 * parameter ID.
 *
 * @param <id> ID for the requested parameter.
 *
 * @return  bool value of the requested parameter.
 *
 */
//------------------------------------------------------------------------------
bool        CelestialBody::GetBooleanParameter(const Integer id) const
{
   if (id == USE_POTENTIAL_FILE_FLAG)       return usePotentialFile;

   return SpacePoint::GetBooleanParameter(id);
}

//------------------------------------------------------------------------------
//  bool  SetBooleanParameter(const Integer id, const std::string value)
//------------------------------------------------------------------------------
/**
 * This method sets the bool parameter value, given the input
 * parameter ID.
 *
 * @param <id> ID for the requested parameter.
 * @param <value> bool value for the requested parameter.
 *
 * @return  success flag.
 *
 */
//------------------------------------------------------------------------------
bool        CelestialBody::SetBooleanParameter(const Integer id,
                                        const bool value) // const?
{
   if (id == USE_POTENTIAL_FILE_FLAG)   return (usePotentialFile = value); 

   return SpacePoint::SetBooleanParameter(id,value);
}

//------------------------------------------------------------------------------
//  const Rvector&  GetRvectorParameter(const Integer id)
//------------------------------------------------------------------------------
/**
 * This method gets the Rvector parameter value, given the input
 * parameter ID.
 *
 * @param <id> ID for the requested parameter.
 *
 * @return  success flag.
 *
 */
//------------------------------------------------------------------------------
const Rvector&  CelestialBody::GetRvectorParameter(const Integer id) const
{
   if (id == STATE)               return state;
   if (id == ANGULAR_VELOCITY)    return angularVelocity;

   return SpacePoint::GetRvectorParameter(id);
}

//------------------------------------------------------------------------------
//  const Rvector&  SetRvectorParameter(const Integer id, const Rvector& value)
//------------------------------------------------------------------------------
/**
 * This method sets the Rvector parameter value, given the input
 * parameter ID.
 *
 * @param <id> ID for the requested parameter.
 * @param <value> Rvector value for the requested parameter.
 *
 * @return  success flag.
 *
 */
//------------------------------------------------------------------------------
const Rvector&  CelestialBody::SetRvectorParameter(const Integer id,
                                              const Rvector &value)
{
   Integer sz = value.GetSize();
   Integer i;
   
   if (id == STATE)
   {
      if (sz != 6) throw SolarSystemException(
                  "Incorrectly sized Rvector passed in for state.");
      for (i=0;i<6;i++) state(i) = value(i);
      return state;
   }
   if (id == ANGULAR_VELOCITY)
   {
      if (sz != 3) throw SolarSystemException(
                   "Incorrectly sized Rvector passed in for angular velocity.");
      for (i=0;i<3;i++) angularVelocity(i) = value(i);
      return angularVelocity;
   }

   return SpacePoint::SetRvectorParameter(id,value);
}

//------------------------------------------------------------------------------
//  const Rvector&  GetRvectorParameter(const std::string &label)
//------------------------------------------------------------------------------
/**
 * This method gets the Rvector parameter value, given the input
 * parameter ID.
 *
 * @param <label> string ID for the requested parameter.
 *
 * @return  success flag.
 *
 */
//------------------------------------------------------------------------------
const Rvector& CelestialBody::GetRvectorParameter(const std::string &label) const
{
   return GetRvectorParameter(GetParameterID(label));
}

//------------------------------------------------------------------------------
//  const Rvector&  SetRvectorParameter(const std::string &label,
//                                      const Rvector& value)
//------------------------------------------------------------------------------
/**
 * This method sets the Rvector parameter value, given the input
 * parameter ID.
 *
 * @param <label> string ID for the requested parameter.
 * @param <value> Rvector value for the requested parameter.
 *
 * @return  success flag.
 *
 */
//------------------------------------------------------------------------------
const Rvector& CelestialBody::SetRvectorParameter(const std::string &label,
                                              const Rvector &value)
{
   return SetRvectorParameter(GetParameterID(label), value);
}

//------------------------------------------------------------------------------
//  const Rmatrix&  GetRmatrixParameter(const Integer id)
//------------------------------------------------------------------------------
/**
 * This method gets the Rmatrix parameter value, given the input
 * parameter ID.
 *
 * @param <id> ID for the requested parameter.
 *
 * @return  success flag.
 *
 */
//------------------------------------------------------------------------------
//const Rmatrix& CelestialBody::GetRmatrixParameter(const Integer id) const
//{
//   if (id == SIJ)               return sij;
//   if (id == CIJ)               return cij;
//   
//   return SpacePoint::GetRmatrixParameter(id);
//}

//------------------------------------------------------------------------------
//  const Rmatrix&  SetRmatrixParameter(const Integer id, const Rmatrix& value)
//------------------------------------------------------------------------------
/**
 * This method sets the Rmatrix parameter value, given the input
 * parameter ID.
 *
 * @param <id> ID for the requested parameter.
 * @param <value> Rmatrix value for the requested parameter.
 *
 * @return  success flag.
 *
 */
//------------------------------------------------------------------------------
//const Rmatrix& CelestialBody::SetRmatrixParameter(const Integer id,
//                                                  const Rmatrix &value)
//{
//   if (id == SIJ)               return (sij = value);
//   if (id == CIJ)               return (cij = value);
//
//   return SpacePoint::SetRmatrixParameter(id,value);
//}

//------------------------------------------------------------------------------
//  const Rmatrix&  GetRmatrixParameter(const std::string &label)
//------------------------------------------------------------------------------
/**
 * This method gets the Rmatrix parameter value, given the input
 * parameter ID.
 *
 * @param <label> string ID for the requested parameter.
 *
 * @return  success flag.
 *
 */
//------------------------------------------------------------------------------
//const Rmatrix& CelestialBody::GetRmatrixParameter(const std::string &label) const
//{
//   return GetRmatrixParameter(GetParameterID(label));
//}

//------------------------------------------------------------------------------
//  const Rmatrix&  SetRmatrixParameter(const std::string &label,
//                                      const Rmatrix& value)
//------------------------------------------------------------------------------
/**
 * This method sets the Rmatrix parameter value, given the input
 * parameter ID.
 *
 * @param <label> string ID for the requested parameter.
 * @param <value> Rmatrix value for the requested parameter.
 *
 * @return  success flag.
 *
 */
//------------------------------------------------------------------------------
//const Rmatrix& CelestialBody::SetRmatrixParameter(const std::string &label,
//                                                  const Rmatrix &value)
//{
//   return SetRmatrixParameter(GetParameterID(label), value);
//}

//------------------------------------------------------------------------------
//  const StringArray&   GetStringArrayParameter((const Integer id) const
//------------------------------------------------------------------------------
/**
 * This method returns the StringArray parameter value, given the input
 * parameter ID.
 *
 * @param <id> ID for the requested parameter.
 *
 * @return  StringArray value of the requested parameter.
 *
 */
//------------------------------------------------------------------------------
const StringArray& CelestialBody::GetStringArrayParameter(const Integer id) const
{
   //if (id == SUPPORTED_ATMOS_MODELS)
   //{
   //   return GetSupportedAtmospheres();
   //}

   return SpacePoint::GetStringArrayParameter(id);
}

//------------------------------------------------------------------------------
// protected methods
//------------------------------------------------------------------------------
//------------------------------------------------------------------------------
//  void  Initialize(std::string withBodyType)
//------------------------------------------------------------------------------
/**
 * This method initializes the data values for the body.
 *
 * @param <withBodyType> string representation of the body type.
 *
 */
//------------------------------------------------------------------------------
void CelestialBody::Initialize(std::string withBodyType)
{
   // assuming derived classes will fill in all the specific things with
   // appropriate default values
   usePotentialFile  = true;
   potentialFileName = "";
   sourceFilename    = "";
   theSourceFile     = NULL;
   stateTime         = 0.0;
   state             = Rvector6(0.0,0.0,0.0,0.0,0.0,0.0);
   angularVelocity   = Rvector3(0.0,0.0,0.0);
   potentialFileRead = false;
   atmModel          = NULL;
   int i;
   bodyType = Gmat::PLANET;  // default to Planet
   for (i = 0; i < (Integer) Gmat::BodyTypeCount; i++)
      if (withBodyType == BODY_TYPE_STRINGS[i]) bodyType = (Gmat::BodyType) i;
   angularVelocity(0) = 0.0;
   angularVelocity(1) = 0.0;
   angularVelocity(2) = 7.29211585530e-5;  // should I so this here or in Planet??
}

//------------------------------------------------------------------------------
//  bool  ReadPotentialFile()
//------------------------------------------------------------------------------
/**
 * This method reads the potential file, if requested, and gets the mu, radius,
 * and spherical harmonic coefficients, sij and cij, from the file.
 *
 * @return flag indicating success of the file-reading.
 *
 */
//------------------------------------------------------------------------------
bool CelestialBody::ReadPotentialFile()
{
   if (potentialFileRead) return true;
   if (potentialFileName == "") return false;

   // Determine the type of file  --> add switch later!!!!!!!!!!
   if ((potentialFileName.find(".dat",0) != std::string::npos) ||
       (potentialFileName.find(".DAT",0) != std::string::npos) )
   {
      if (!ReadDatFile())
         throw SolarSystemException(
            "Error reading mu and equatorial radius of " + instanceName
                                    + " from "+ potentialFileName);
   }
   else if ((potentialFileName.find(".grv",0) != std::string::npos) ||
            (potentialFileName.find(".GRV",0) != std::string::npos) )
   {
      if (!ReadGrvFile())
         throw SolarSystemException(
            "Error reading mu and equatorial radius of " + instanceName
                                    + " from " + potentialFileName);
   }
   else if ((potentialFileName.find(".cof",0) != std::string::npos) ||
            (potentialFileName.find(".COF",0) != std::string::npos) )
   {
      if (!ReadCofFile())
         throw SolarSystemException(
           "Error reading mu and equatorial radius of " + instanceName
                                    + " from " + potentialFileName);
   }
   else
   {
      throw SolarSystemException("Gravity file " + potentialFileName +
                                " is of unknown format.");
   }
   potentialFileRead = true;
   // recompute polar radius
   polarRadius = (1.0 - flattening) * equatorialRadius;
   // recompute mass
   mass = mu / GmatPhysicalConst::UNIVERSAL_GRAVITATIONAL_CONSTANT;
   return true;
}

//------------------------------------------------------------------------------
//  bool ReadCofFile()
//------------------------------------------------------------------------------
/**
 * This method reads a ???????? file to get the gravity parameters.
 *
 * @return success flag.
 */
//------------------------------------------------------------------------------
bool CelestialBody::ReadCofFile()
{
   Integer       fileOrder, fileDegree;
   Integer       noIdea;
   Real          noClue;
   Real          tmpMu;
   Real          tmpA;

   std::ifstream inFile;
   inFile.open(potentialFileName.c_str());
   if (!inFile)
      throw SolarSystemException("Cannot open file " + potentialFileName);
   std::string s;
   std::string firstStr;
   while (!inFile.eof())
   {
      getline(inFile,s);
      std::istringstream lineStr;
      lineStr.str(s);
      // ignore comment lines
      if (s[0] != 'C')
      {
         lineStr >> firstStr;
         if (firstStr == "END") break;
         if (firstStr == "POTFIELD")
         {
            lineStr >> fileDegree >> fileOrder >> noIdea >> tmpMu >> tmpA >> noClue;
            if (tmpMu == 0.0)
               mu = defaultMu;
            else
               mu = tmpMu / 1.0e09;  // -> Km^3/sec^2
            if (tmpA  == 0.0)
               equatorialRadius  = defaultEqRadius;
            else
               equatorialRadius = tmpA / 1000.0;  // -> km
            break;  // stop after reading the mu and a
         }
         else
         {
            // ignore anything else
         }
      }
   }

   return true; 
}

//------------------------------------------------------------------------------
//  bool ReadGrvFile()
//------------------------------------------------------------------------------
/**
 * This method reads a ???????? file to get the gravity parameters.
 *
 * @return success flag.
 */
//------------------------------------------------------------------------------
bool CelestialBody::ReadGrvFile()
{
   Integer       fileOrder, fileDegree;
   //char          buf[CelestialBody::BUFSIZE];
   //char          firstToken[CelestialBody::BUFSIZE];
   Real          tmpMu = 0.0;
   Real          tmpA  = 0.0;
   std::string   isNormalized;

   std::ifstream inFile;
   inFile.open(potentialFileName.c_str());
   if (!inFile)
      throw SolarSystemException("Cannot open file " + potentialFileName);
   std::string s;
   std::string firstStr;
   while (!inFile.eof())
   {
      getline(inFile,s);
      std::istringstream lineStr;
      lineStr.str(s);
      // ignore comment lines
      if (s[0] != '#')
      {
         lineStr >> firstStr;
         if (firstStr == "END") break;
         
         // ignore the stk version and blank lines
         if ((strcasecmp(firstStr.c_str(),"Model") == 0) ||
               (strcasecmp(firstStr.c_str(),"BEGIN") == 0))
         {
            // do nothing - we don't need to know this
         }
         else if (strcasecmp(firstStr.c_str(),"Degree") == 0)
         {
            lineStr >> fileDegree;
         }
         else if (strcasecmp(firstStr.c_str(),"Order") == 0)
         {
            lineStr >> fileOrder;
         }
         else if (strcasecmp(firstStr.c_str(),"Gm") == 0)
         {
            lineStr >> tmpMu;
            if (tmpMu == 0.0)
               mu = defaultMu;
            else
               mu = tmpMu / 1.0e09;     // -> Km^3/sec^2
            // break as soon as both mu and a are read
            if ((tmpMu != 0.0) && (tmpA != 0.0)) break;
         }
         else if (strcasecmp(firstStr.c_str(),"RefDistance") == 0)
         {
            lineStr >> tmpA;
            if (tmpA == 0.0)
               equatorialRadius = defaultEqRadius;
            else
               equatorialRadius = tmpA / 1000.0;  // -> Km
            // break as soon as both mu and a are read
            if ((tmpMu != 0.0) && (tmpA != 0.0)) break;            
         }
         else if (strcasecmp(firstStr.c_str(),"Normalized") == 0)
         {
            lineStr >> isNormalized;
            if (isNormalized == "No")
               throw SolarSystemException(
                     "File " + potentialFileName + " is not normalized.");
            }
         else
         {
            // ignore
         }
      }
   }

   return true;  
}

//------------------------------------------------------------------------------
//  bool ReadDatFile()
//------------------------------------------------------------------------------
/**
 * This method reads a ???????? file to get the gravity parameters.
 *
 * @return success flag.
 */
//------------------------------------------------------------------------------
bool CelestialBody::ReadDatFile()
{
   Integer      iscomment, rtn;
   char         buf[CelestialBody::BUFSIZE];
   FILE        *fp;

   
   /* read coefficients from file */
   fp = fopen( potentialFileName.c_str(), "r");
   if (!fp)
   {
      return false;
   }

   iscomment = 1;
   while ( iscomment )
   {
      rtn = fgetc( fp );
      if ( (char)rtn == '#' )
      {
         fgets( buf, CelestialBody::BUFSIZE, fp );
      }
      else
      {
         ungetc( rtn, fp );
         iscomment = 0;
      }
   }

   fscanf(fp, "%lg\n", &mu ); mu = (Real)mu;
   fscanf(fp, "%lg\n", &equatorialRadius ); equatorialRadius = (Real)equatorialRadius;
   equatorialRadius  = equatorialRadius / 1000.0;  // -> Km
   mu                = mu / 1.0e09;                // -> Km^3/sec^2
   return true;
}

//------------------------------------------------------------------------------
//  bool IsBlank(char* aLine)
//------------------------------------------------------------------------------
/**
 * This method returns true if teh string is empty or is all white space.
 *
 * @return success flag.
 */
//------------------------------------------------------------------------------
bool CelestialBody::IsBlank(char* aLine)
{
   Integer i;
   for (i=0;i<(int)strlen(aLine);i++)
   {
      if (!isspace(aLine[i])) return false;
   }
   return true;
}

Real CelestialBody::GetJulianDaysFromTCBEpoch(const A1Mjd &forTime) const
{
   Real mjdTCB = TimeConverterUtil::Convert(forTime.Get(),
                 "A1Mjd", "TcbMjd", GmatTimeUtil::JD_JAN_5_1941);      
   Real jdTCB  = mjdTCB + GmatTimeUtil::JD_JAN_5_1941; 
   return (jdTCB - JD_EPOCH_2000_TCB);
}

//------------------------------------------------------------------------------
// private methods
//------------------------------------------------------------------------------
// none at this time

