//$Header$
//------------------------------------------------------------------------------
//                                  CelestialBody
//------------------------------------------------------------------------------
// GMAT: Goddard Mission Analysis Tool.
//
// **Legal**
//
// Developed jointly by NASA/GSFC and Thinking Systems, Inc. under contract
// number S-67573-G
//
// Author: Wendy C. Shoan
// Created: 2004/01/28
//
/**
 * This is the base class for celestial bodies.
 *
 * @note This is an abstract class.
 * @note Class (initial shell only) automatically generated by Dev-C++ New
 *       Class wizard (heavily modified after that)
 */
//------------------------------------------------------------------------------

#ifndef CelestialBody_hpp
#define CelestialBody_hpp

#include <math.h>
#include "gmatdefs.hpp"
#include "GmatBase.hpp"
#include "SpacePoint.hpp"
#include "A1Mjd.hpp"
#include "PlanetaryEphem.hpp"
#include "AtmosphereModel.hpp"
#include "Rmatrix.hpp"
#include "Rvector6.hpp"
#include "TimeTypes.hpp"

// Add needed things to Gmat namespace
namespace Gmat
{
   // possible sources of position and velocity data for celestial bodies
   enum PosVelSource
   {
      ANALYTIC = 0,
      SLP,
//      DE_102,
      DE_200,
//      DE_202,
//      DE_403,
      DE_405,
//      DE_406,
//      EPHEMERIS,           // do we need more?
      PosVelSourceCount
   };
   
   const std::string POS_VEL_SOURCE_STRINGS[PosVelSourceCount] = 
   {
      "Analytic",
      "SLP",
      "DE_200", 
      "DE_405",
   };

   // if using an analytical method, which one?
   enum AnalyticMethod
   {
      NO_ANALYTIC_METHOD = 0,
      LOW_FIDELITY,
      AnalyticMethodCount
   };

   const std::string ANALYTIC_METHOD_STRINGS[AnalyticMethodCount] = 
   {
      "NoAnalyticMethod",
      "LowFidelity",
   };
   
   // possible types of celestial bodies
   enum BodyType
   {
      STAR = 0,
      PLANET,
      MOON,
      ASTEROID,             // asteroids not yet implemented
      COMET,                // comets not yet implemented
      KBO,                  // KBOs not yet implemented
      BodyTypeCount
   };
   
   const std::string BODY_TYPE_STRINGS[BodyTypeCount] = 
   {
      "Star",
      "Planet",
      "Moon",
      "Asteroid",           // asteroids not yet implemented
      "Comet",              // comets not yet implemented
      "KuiperBeltObject",   // KBOs not yet implemented
   };
      
   // types of environment models for a body
   enum ModelType
   {
      ATMOSPHERE_MODEL = 0,
      GRAVITY_FIELD,
      MAGNETIC_FIELD,
      ModelTypeCount
   };
   
   const std::string MODEL_TYPE_STRINGS[ModelTypeCount] =
   {
      "AtmosphereModel",
      "GravityField",
      "MagneticField",
   };
};

/**
 * CelestialBody base class, from which all types of celestial bodies will derive.
 *
 * The CelestialBody class is primarily an intermediate base class, from which
 * all types of celestial bodies will derive.  CelestialBody itself derives from
 * SpacePoint.
 */
class GMAT_API CelestialBody : public SpacePoint
{
public:
   
   // additional constructor, specifying body type (as string) and name
   CelestialBody(std::string itsBodyType, std::string name);
   // additional constructor, specifying type (as Gmat::BodyType) and name
   CelestialBody(Gmat::BodyType itsBodyType, std::string name);
   // copy constructor
   CelestialBody(const CelestialBody &cBody);
   // operator=
   CelestialBody& operator=(const CelestialBody &cBody);
   // destructor
   virtual ~CelestialBody();

   virtual bool Initialize();
   
   // method to return the state (position and velocity) of the body at
   // the specified time, using the specified method
   virtual const Rvector6&      GetState(A1Mjd atTime);
   virtual const Rvector6&      GetState(Real atTime); 
   
   // methods to return the body type, central body, gravitational constant,
   // radius, mass, posvel source, and analytic method 
   virtual Gmat::BodyType       GetBodyType() const;
   virtual const std::string&   GetCentralBody() const;
   virtual Real                 GetGravitationalConstant();
   virtual Real                 GetEquatorialRadius();
   virtual Real                 GetFlattening() const;
   virtual Real                 GetPolarRadius();
   virtual Real                 GetMass();
   virtual Gmat::PosVelSource   GetPosVelSource() const;
   virtual std::string          GetSourceFileName() const;
   virtual PlanetaryEphem*      GetSourceFile() const;
   virtual Gmat::AnalyticMethod GetAnalyticMethod() const;
   virtual bool                 GetUsePotentialFile() const;
   virtual bool                 GetOverrideTimeSystem() const;
   virtual Real                 GetEphemUpdateInterval() const;
   virtual StringArray          GetValidModelList(Gmat::ModelType m) const;
   virtual const Rvector3&      GetAngularVelocity();             // rad/sec

   virtual Real                 GetHourAngle(A1Mjd atTime); 
   
   virtual const Rmatrix&       GetHarmonicCoefficientsSij(); 
   virtual const Rmatrix&       GetHarmonicCoefficientsCij(); 
   virtual Integer              GetDegree();
   virtual Integer              GetOrder();
   virtual std::string          GetAtmosphereModelType();
   virtual AtmosphereModel*     GetAtmosphereModel();
   virtual bool                 GetDensity(Real *position, Real *density,
                                        Real epoch = 21545.0,
                                        Integer count = 1);
   // methods to get the initial epoch and keplerian elements 
   virtual A1Mjd                GetLowFidelityEpoch() const;
   virtual Rvector6             GetLowFidelityElements() const; 
   

   // methods to return the body type, central body,
   // posvel source, and analytic method
   virtual bool           SetBodyType(Gmat::BodyType bType);
   virtual bool           SetCentralBody(const std::string &cBody);
   virtual bool           SetGravitationalConstant(Real newMu);
   virtual bool           SetEquatorialRadius(Real newEqRadius);
   virtual bool           SetFlattening(Real flat);
   //virtual bool           SetPolarRadius(Real newPolarRadius);
   //virtual bool           SetMass(Real newMass);
   virtual bool           SetSource(Gmat::PosVelSource pvSrc);
   virtual bool           SetSourceFile(PlanetaryEphem *src);
   virtual bool           SetAnalyticMethod(Gmat::AnalyticMethod aM);
   virtual bool           SetUsePotentialFile(bool useIt);
   
   virtual bool           SetOverrideTimeSystem(bool overrideIt);
   virtual bool           SetEphemUpdateInterval(Real intvl);
   virtual bool           AddValidModelName(Gmat::ModelType m, 
                                            const std::string &newModel);
   virtual bool           RemoveValidModelName(Gmat::ModelType m, 
                                               const std::string &modelName);

   
   virtual bool           SetAtmosphereModelType(std::string toAtmModelType);
   virtual bool           SetAtmosphereModel(AtmosphereModel *toAtmModel);
   virtual bool           SetPotentialFilename(const std::string &fn);
   virtual bool           SetLowFidelityEpoch(const A1Mjd &toTime);
   virtual bool           SetLowFidelityElements(const Rvector6 &kepl);

   // methods inherited from SpacePoint, that must be implemented here (and/or
   // in the derived classes
   virtual const Rvector6 GetMJ2000State(const A1Mjd &atTime);
   virtual const Rvector3 GetMJ2000Position(const A1Mjd &atTime);
   virtual const Rvector3 GetMJ2000Velocity(const A1Mjd &atTime);

   // method to return the alpha, delta, W, and Wdot for the body (specifying
   // the direction of the north pole of rotation (right ascension and
   // declination) and the prime meridian.  
   // Units are degrees (alpha), degrees (delta), and degrees (W); also,
   // the time derivative of W (deg/day)
   // For more information, see
   // "Report of the IAU/IAG Working Group on Cartographic Coordinates and
   // Rotational Elements of the Planets and Satellites: 2000"
   virtual Rvector       GetBodyCartographicCoordinates(const A1Mjd &forTime) const;
   
   
   // Parameter access methods - overridden from GmatBase
   virtual std::string    GetParameterText(const Integer id) const;     // const?
   virtual Integer        GetParameterID(const std::string &str) const; // const?
   virtual Gmat::ParameterType
                          GetParameterType(const Integer id) const;
   virtual std::string    GetParameterTypeString(const Integer id) const;

   virtual Real           GetRealParameter(const Integer id) const;
   virtual Real           SetRealParameter(const Integer id,
                                           const Real value);
   virtual Integer        GetIntegerParameter(const Integer id) const; // const?
   virtual Integer        SetIntegerParameter(const Integer id,
                                              const Integer value); // const?
   virtual std::string    GetStringParameter(const Integer id) const; // const?
   virtual bool           SetStringParameter(const Integer id, 
                                             const std::string &value); // const?
   virtual bool           GetBooleanParameter(const Integer id) const; // const?
   virtual bool           SetBooleanParameter(const Integer id,
                                              const bool value); // const?
   virtual const Rvector&    GetRvectorParameter(const Integer id) const;
   virtual const Rvector&    SetRvectorParameter(const Integer id,
                                                 const Rvector &value);
   virtual const Rvector&    GetRvectorParameter(const std::string &label) const;
   virtual const Rvector&    SetRvectorParameter(const std::string &label,
                                                 const Rvector &value);
   //virtual const Rmatrix&    GetRmatrixParameter(const Integer id) const;
   //virtual const Rmatrix&    SetRmatrixParameter(const Integer id,
   //                                              const Rmatrix &value);
   //virtual const Rmatrix&    GetRmatrixParameter(const std::string &label) const;
   //virtual const Rmatrix&    SetRmatrixParameter(const std::string &label,
   //                                              const Rmatrix &value);
   virtual const StringArray& GetStringArrayParameter(const Integer id) const;

   virtual GmatBase*   GetRefObject(const Gmat::ObjectType type,
                                    const std::string &name);
   const StringArray&  GetRefObjectNameArray(const Gmat::ObjectType type);
   virtual bool        SetRefObject(GmatBase *obj, const Gmat::ObjectType type,
                                    const std::string &name = "");
   
   // need methods to get/set stateTime (a1MJD type)?

   //virtual const Rmatrix&       GetCoefDriftS();
   //virtual const Rmatrix&       GetCoefDriftC();
   //virtual bool           SetPhysicalParameters(Real bodyMass, Real bodyEqRad,
   //                                             Real bodyPolarRad, Real bodyMu,
   //                                             Integer coeffSize, Rmatrix& bodySij,
   //                                             Rmatrix& bodyCij);
   

   
   //------------------------------------------------------------------------------
   // virtual CelestialBody* Clone(void) const
   //------------------------------------------------------------------------------
   /**
     * Method used to create a copy of the object
     * Each class that can be instantiated provides an implementation of this
     * method so that copies can be made from a base class pointer.
     */
   //------------------------------------------------------------------------------
   //virtual CelestialBody* Clone(void) const = 0;

   // strings representing the possible celestial body types
   static const std::string BODY_TYPE_STRINGS[Gmat::BodyTypeCount];
   static const std::string POS_VEL_STRINGS[Gmat::PosVelSourceCount];
   static const std::string ANALYTIC_METHOD_STRINGS[Gmat::AnalyticMethodCount];

   // local constants
   static const Integer BUFSIZE               = 256;
   
   //static const Integer MAX_DEGREE            = 360;
   //static const Integer MAX_ORDER             = 360;
   //static const Integer GRAV_MAX_DRIFT_DEGREE = 2;

protected:

   enum
   {
      BODY_TYPE = SpacePointParamCount, 
      MASS,
      EQUATORIAL_RADIUS,
      FLATTENING,
      POLAR_RADIUS,
      MU,
      POS_VEL_SOURCE,
      ANALYTIC_METHOD,
      STATE,
      STATE_TIME,
      CENTRAL_BODY,
      BODY_NUMBER,
      REF_BODY_NUMBER,
      SOURCE_FILENAME,
      SOURCE_FILE,
      USE_POTENTIAL_FILE_FLAG,
      POTENTIAL_FILE_NAME,
      ANGULAR_VELOCITY,
      //COEFFICIENT_SIZE,
      HOUR_ANGLE,
      ATMOS_MODEL_NAME,
      //SUPPORTED_ATMOS_MODELS,
      ORDER,  // may need to access these through general methods at some point
      DEGREE,
      //SIJ,
      //CIJ,
      CelestialBodyParamCount
   };
   static const std::string PARAMETER_TEXT[CelestialBodyParamCount - SpacePointParamCount];

   static const Gmat::ParameterType PARAMETER_TYPE[CelestialBodyParamCount - SpacePointParamCount];
   static const Real JD_EPOCH_2000_TCB;
   static const Real JD_EPOCH_2000_TT;
   //static const Real dDot              = 1.0 / GmatTimeUtil::SECS_PER_DAY;
   //static const Real TDot              = dDot / 36525.0;
   static const Real dDot;
   static const Real TDot;
   static const Real KEPLER_TOL;
   
   // body type of the body
   Gmat::BodyType         bodyType;
   // mass
   Real                   mass;
   /// radius of the body at the equator
   Real                   equatorialRadius;
   /// flattening - used to compute polar radius
   Real                   flattening;
   /// radius of the body from center to the pole
   Real                   polarRadius;
   /// gravitational constant in km^3/s^2
   Real                   mu;
   /// source for position and velocity
   Gmat::PosVelSource     posVelSrc;
   /// analytic method to use
   Gmat::AnalyticMethod   analyticMethod;
   /// state of the body 0-2 position 3-5 velocity
   Rvector6               state ;
   // time of the state
   A1Mjd                  stateTime;

   /// name of central body around which this body revolves
   std::string            centralBody;
   /// central body around which this body revolves
   CelestialBody          *cb;
   /// body number for the SLP file
   Integer                bodyNumber;
   /// body number of origin of coordinate system for file
   Integer                referenceBodyNumber;
   /// name of file that is the source of position and velocity for this body
   std::string            sourceFilename;
   // the source file
   PlanetaryEphem*        theSourceFile;

   /// flag indicating whether or not to get data from potential file
   bool                   usePotentialFile;
   /// file name of the potential file to use
   std::string            potentialFileName;
   /// angular velocity
   Rvector3               angularVelocity;
   /// the hour angle 
   Real                   hourAngle;
   /// pointer to the atmosphere model to use for the body
   AtmosphereModel*       atmModel;
   /// the type of the atmosphere model (e.g. "Exponential")
   std::string            atmModelType;

   /// has the potential file been read already?
   bool                   potentialFileRead;

   /// defaults mu to use if potential file is not used
   Real                   defaultMu;
   /// defaults eauatorial radius to use if potential file is not used
   Real                   defaultEqRadius;
   
   /// order of the gravity model
   Integer                order;    
   /// degree of the gravity model
   Integer                degree;  
   /// spherical harmonic coefficients (Sij) for the body
   Rmatrix                sij;
   /// spherical harmonic coefficients (Cij) for the body
   Rmatrix                cij;
   /// Initial epoch for low fidelity analytic model
   A1Mjd                  lfEpoch;
   /// initial Keplerian elements for low fidelity analytic model 
   /// (with respect to central body)
   Rvector6               lfKepler; 
   /// most recent epoch for low fidelity model
   A1Mjd                  prevLFEpoch;  
   /// most recent state (cartesian - wrt the Earth) for low fidelity model
   Rvector6               prevLFState;
   /// flag indicating whether or not the low fidelity epoch and 
   /// state have been modified
   bool                   newLF;
   /// flag indicating whether or not to override the TDB/TCB tiems with TT
   bool                   overrideTime;
   /// update interval for the ephemeris calsulations (file-reading)
   Real                   ephemUpdateInterval;
   /// last time that the state was calculated
   A1Mjd                  lastEphemTime;
   /// last state value calculated
   Rvector6               lastState;
   
   /// lists of valid models
   StringArray            models[Gmat::ModelTypeCount];
   
   /// date and time of start of source file
   //A1Mjd                  sourceStart;      // currently unused
   /// date and time of end of sourcce file
   //A1Mjd                  sourceEnd;        // currently unused
   //Integer                coefficientSize;      // n   // same as degree, order above?
   //Rmatrix                Cbar, Sbar;
   //Rmatrix                dCbar, dSbar; // from original GravityField
   //Integer                defaultCoefSize;
   //Rmatrix                defaultSij;
   //Rmatrix                defaultCij;


   
   // initialze the body
   void             InitializeBody(std::string withBodyType = "Planet");
   // methods to read the potential file, if requested
   bool             ReadPotentialFile();
   bool             ReadCofFile();
   bool             ReadGrvFile();
   bool             ReadDatFile();
   
   bool             IsBlank(char* aLine);
   virtual Real     GetJulianDaysFromTCBEpoch(const A1Mjd &forTime) const;
   virtual Rvector6 ComputeLowFidelity(const A1Mjd &forTime);
   virtual Rvector6 KeplersProblem(const A1Mjd &forTime);
   
private:

   bool isFirstTimeMu;
   bool isFirstTimeRadius;
};
#endif // CelestialBody_hpp

