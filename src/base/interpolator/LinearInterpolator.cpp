//$Header$
//------------------------------------------------------------------------------
//                             LinearInterpolator
//------------------------------------------------------------------------------
// GMAT: Goddard Mission Analysis Tool.
//
// Author: Darrel J. Conway
// Created: 2003/10/15
//
// Developed jointly by NASA/GSFC and Thinking Systems, Inc. under contract
// number S-67573-G
//
/**
 * Insert descriptive text here.
 *
 * @note Any notes here.
 */
//------------------------------------------------------------------------------




// Class automatically generated by Dev-C++ New Class wizard

#include "LinearInterpolator.hpp" // class's header file

// class constructor
LinearInterpolator::LinearInterpolator(Integer dim) :
    Interpolator        ("LinearInterpolator", dim)
{
	// insert your code here
}

// class destructor
LinearInterpolator::~LinearInterpolator(void)
{
}


LinearInterpolator::LinearInterpolator(const LinearInterpolator &li) :
    Interpolator        (li)
{
}


LinearInterpolator& LinearInterpolator::operator=(const LinearInterpolator &li)
{
    if (&li == this)
        return *this;
        
    Interpolator::operator=(li);
    return *this;
}


bool LinearInterpolator::Interpolate(const Real ind, Real *results)
{
    if (pointCount < requiredPoints)
        return false;
        
    Integer index = latestPoint, previousPoint = latestPoint-1,
            valid = pointCount, i;
    Real delta;
    
    while ((previousPoint != latestPoint) && valid > 0) {
        if (previousPoint < 0)
            previousPoint += bufferSize;
        if (index < 0)
            index += bufferSize;
        // Check to see that ind is in the valid range
        SetRange();
        if ((ind < range[0]) || (ind > range[1]))
            return false;
            
        if (ind > independent[previousPoint])
        {
            // Found the bounding points
            delta = independent[index] - independent[previousPoint];
            if (delta == 0.0)
                return false;
            delta = (ind - independent[previousPoint]) / delta;
            for (i = 0; i < dimension; ++i)
                results[i] = dependent[previousPoint][i] + delta *
                             (dependent[index][i]-dependent[previousPoint][i]);
                             
            return true;
        }
        
        index = previousPoint;
        --previousPoint;
        --valid;
    }

    return false;
}

