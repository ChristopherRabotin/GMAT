//$Header$
//------------------------------------------------------------------------------
//                                  Interpreter
//------------------------------------------------------------------------------
// GMAT: Goddard Mission Analysis Tool.
//
// Author: Darrel J. Conway
// Created: 2003/08/28
//
// Developed jointly by NASA/GSFC and Thinking Systems, Inc. under contract
// number S-67573-G
//
/**
 * Class implementation for the Interpreter base class
 */
//------------------------------------------------------------------------------




// Class automatically generated by Dev-C++ New Class wizard

#include "Interpreter.hpp" // class's header file

#include "Moderator.hpp"
#include "PhysicalModel.hpp"


/// class constructor
Interpreter::Interpreter() :
    instream            (NULL),
    outstream           (NULL)
{
    moderator = Moderator::Instance();
    
    if (moderator) {
        // Set up the mapping for the core types
        typemap["Spacecraft"] = Gmat::SPACECRAFT;
        typemap["GroundStation"] = Gmat::GROUND_STATION;
        typemap["Command"] = Gmat::COMMAND;
        typemap["Propagator"] = Gmat::PROPAGATOR;
        typemap["ForceModel"] = Gmat::FORCE_MODEL;
        typemap["Force"] = Gmat::PHYSICAL_MODEL;
        typemap["SolarSystem"] = Gmat::SOLAR_SYSTEM;
        typemap["CelestialBody"] = Gmat::CELESTIAL_BODY;
        typemap["Parameter"] = Gmat::PARAMETER;
//        typemap["StoppingCondition"] = Gmat::STOP_CONDITION;
        typemap["Subscriber"] = Gmat::SUBSCRIBER;
//        typemap["PropagatorSetup"] = Gmat::PROP_SETUP;
        
        // Build a similar mapping for all of the defined commands
//        StringArray cmds = moderator->GetListOfFactoryItems(Gmat::COMMAND);
//        copy(cmds.begin(), cmds.end(), back_inserter(cmdmap));
    } 
}

/// class destructor
Interpreter::~Interpreter()
{
}


bool Interpreter::SetInStream(std::istream *str)
{
    instream = str;
    return true;
}


bool Interpreter::SetOutStream(std::ostream *str)
{
    outstream = str;
    return true;
}


// The "Interpret" methods translate text streams (e.g. scripts and 
// subscripts) into GMAT objects 
bool Interpreter::Interpret(void)
{
    return false;
}


bool Interpreter::InterpretObject(std::string objecttype, std::string objectname)
{
    return false;
}


// The "Build" methods take GMAT objects and write out scripts or subscripts
bool Interpreter::Build(void)
{
    return false;
}


bool Interpreter::BuildObject(std::string objectname)
{
    return false;
}



// The "Create" methods make calls, through the Moderator, to the Factories
// to get new instances of the requested objects
Spacecraft* Interpreter::CreateSpacecraft(std::string satname)
{
    return NULL;
}


Command* Interpreter::CreateCommand(std::string commandtype)
{
    return NULL;
}


Propagator* Interpreter::CreatePropagator(std::string proptype)
{
    return NULL;
}


ForceModel* Interpreter::CreateForceModel(std::string modelname)
{
    return NULL;
}


PhysicalModel* Interpreter::CreatePhysicalModel(std::string forcetype)
{
    return NULL;
}


SolarSystem* Interpreter::CreateSolarSystem(std::string ssname)
{
    return NULL;
}


CelestialBody* Interpreter::CreateCelestialBody(std::string cbname, std::string type)
{
    return NULL;
}


Parameter* Interpreter::CreateParameter(std::string name, std::string type)
{
    return NULL;
}


//StoppingCondition* Interpreter::CreateStopCond(std::string conditiontype)
//{
//    return NULL;
//}


Subscriber* Interpreter::CreateSubscriber(std::string name, std::string type)
{
    return NULL;
}


                                                
// The following method signature depends on an open scripting issue: if
// props and force models are named, the following Create method should use
// the names rather than the object pointers
//PropagatorSetup* Interpreter::CreatePropSetup(std::string name, Propagator *prop,
//                                        ForceModel *fm)
//{
//    return NULL;
//}



void Interpreter::ChunkLine(void)
{
    // Break the line into pieces based on while space and special characters
    
}


Integer Interpreter::SkipWhiteSpace(Integer start)
{
    return -1;
}


/**
 * Method to find special characters: = , { } [ ] ( ) ; . %
 */
Integer Interpreter::FindDelimiter(std::string str, std::string specChar)
{
    return -1;
}

