//$Id$
//------------------------------------------------------------------------------
//                                  AttitudeParameters
//------------------------------------------------------------------------------
// GMAT: General Mission Analysis Tool
//
// Copyright (c) 2002-2011 United States Government as represented by the
// Administrator of The National Aeronautics and Space Administration.
// All Other Rights Reserved.
//
// Developed jointly by NASA/GSFC and Thinking Systems, Inc. under contract
// number S-67573-G
//
// Developed further jointly by NASA/GSFC, Thinking Systems, Inc., and 
// Schafer Corp., under AFRL NOVA Contract #FA945104D03990003
//
//
// Author: Daniel Hunter
// Created: 2006/6/26
// Modified:  Dunn Idle (added MRPs)
// Date:      2010/08/24
//
/**
 * Implements Attitude related parameter classes.
 *    DCM11, DCM12, DCM13, DCM21, DCM22, DCM23, DCM31, DCM32, DCM33,
 *    Quat1, Quat2, Quat3, Quat4, EulerAngle1, EulerAngle2, EulerAngle3,
 *    MRP1 , MRP2 , MRP3 , AngVelX, AngVelY, AngVelZ, 
 *    EulerAngleRate1, EulerAngleRate2, EulerAngleRate3
 */
//------------------------------------------------------------------------------

#include "AttitudeParameters.hpp"
#include "ColorTypes.hpp"


// To use preset colors, uncomment this line:
//#define USE_PREDEFINED_COLORS

//------------------------------------------------------------------------------
//------------------------------------------------------------------------------
//  Direction Cosine Matrix  ---------------------------------------------------
//------------------------------------------------------------------------------
//------------------------------------------------------------------------------

//------------------------------------------------------------------------------
//  DCM11
//------------------------------------------------------------------------------
//------------------------------------------------------------------------------
// DCM11(const std::string &name, GmatBase *obj)
//------------------------------------------------------------------------------
DCM11::DCM11(const std::string &name, GmatBase *obj)
   : AttitudeReal(name, "DCM11", obj, "Direction Cosine Matrix 1,1", "")
{
   #ifdef USE_PREDEFINED_COLORS
      mColor = GmatColor::RED32;
   #endif
}
//------------------------------------------------------------------------------
// DCM11(const DCM11 &copy)
//------------------------------------------------------------------------------
DCM11::DCM11(const DCM11 &copy)
   : AttitudeReal(copy)
{
}
//------------------------------------------------------------------------------
// DCM11& operator=(const DCM11 &right)
//------------------------------------------------------------------------------
DCM11& DCM11::operator=(const DCM11 &right)
{
   if (this != &right)
      AttitudeReal::operator=(right);

   return *this;
}
//------------------------------------------------------------------------------
// ~DCM11()
//------------------------------------------------------------------------------
DCM11::~DCM11()
{
}
//------------------------------------------------------------------------------
// bool Evaluate()
//------------------------------------------------------------------------------
bool DCM11::Evaluate()
{
   mRealValue = AttitudeData::GetAttitudeReal(DCM1_1);
   
    
   if (mRealValue == AttitudeData::ATTITUDE_REAL_UNDEFINED)
      return false;
   else
      return true;
}
//------------------------------------------------------------------------------
// GmatBase* DCM11::Clone(void) const
//------------------------------------------------------------------------------
GmatBase* DCM11::Clone(void) const
{
   return new DCM11(*this);
}

//------------------------------------------------------------------------------
//  DCM12
//------------------------------------------------------------------------------
//------------------------------------------------------------------------------
// DCM12(const std::string &name, GmatBase *obj)
//------------------------------------------------------------------------------
DCM12::DCM12(const std::string &name, GmatBase *obj)
   : AttitudeReal(name, "DCM12", obj, "Direction Cosine Matrix 1,2", "")
{
   #ifdef USE_PREDEFINED_COLORS
      mColor = GmatColor::YELLOW32;
   #endif
}
//------------------------------------------------------------------------------
// DCM12(const DCM12 &copy)
//------------------------------------------------------------------------------
DCM12::DCM12(const DCM12 &copy)
   : AttitudeReal(copy)
{
}
//------------------------------------------------------------------------------
// DCM12& operator=(const DCM12 &right)
//------------------------------------------------------------------------------
DCM12& DCM12::operator=(const DCM12 &right)
{
   if (this != &right)
      AttitudeReal::operator=(right);

   return *this;
}
//------------------------------------------------------------------------------
// ~DCM12()
//------------------------------------------------------------------------------
DCM12::~DCM12()
{
}
//------------------------------------------------------------------------------
// bool Evaluate()
//------------------------------------------------------------------------------
bool DCM12::Evaluate()
{
   mRealValue = AttitudeData::GetAttitudeReal(DCM1_2);
    
   if (mRealValue == AttitudeData::ATTITUDE_REAL_UNDEFINED)
      return false;
   else
      return true;
}
//------------------------------------------------------------------------------
// GmatBase* DCM12::Clone(void) const
//------------------------------------------------------------------------------
GmatBase* DCM12::Clone(void) const
{
   return new DCM12(*this);
}

//------------------------------------------------------------------------------
//  DCM13
//------------------------------------------------------------------------------
//------------------------------------------------------------------------------
// DCM13(const std::string &name, GmatBase *obj)
//------------------------------------------------------------------------------
DCM13::DCM13(const std::string &name, GmatBase *obj)
   : AttitudeReal(name, "DCM13", obj, "Direction Cosine Matrix 1,3", "")
{
   #ifdef USE_PREDEFINED_COLORS
      mColor = GmatColor::BLUE32;
   #endif
}
//------------------------------------------------------------------------------
// DCM13(const DCM13 &copy)
//------------------------------------------------------------------------------
DCM13::DCM13(const DCM13 &copy)
   : AttitudeReal(copy)
{
}
//------------------------------------------------------------------------------
// DCM13& operator=(const DCM13 &right)
//------------------------------------------------------------------------------
DCM13& DCM13::operator=(const DCM13 &right)
{
   if (this != &right)
      AttitudeReal::operator=(right);

   return *this;
}
//------------------------------------------------------------------------------
// ~DCM13()
//------------------------------------------------------------------------------
DCM13::~DCM13()
{
}
//------------------------------------------------------------------------------
// bool Evaluate()
//------------------------------------------------------------------------------
bool DCM13::Evaluate()
{
   mRealValue = AttitudeData::GetAttitudeReal(DCM1_3);
    
   if (mRealValue == AttitudeData::ATTITUDE_REAL_UNDEFINED)
      return false;
   else
      return true;
}
//------------------------------------------------------------------------------
// GmatBase* DCM13::Clone(void) const
//------------------------------------------------------------------------------
GmatBase* DCM13::Clone(void) const
{
   return new DCM13(*this);
}

//------------------------------------------------------------------------------
//  DCM21
//------------------------------------------------------------------------------
//------------------------------------------------------------------------------
// DCM21(const std::string &name, GmatBase *obj)
//------------------------------------------------------------------------------
DCM21::DCM21(const std::string &name, GmatBase *obj)
   : AttitudeReal(name, "DCM21", obj, "Direction Cosine Matrix 2,1", "")
{
   #ifdef USE_PREDEFINED_COLORS
      mColor = GmatColor::GREEN32;
   #endif
}
//------------------------------------------------------------------------------
// DCM21(const DCM21 &copy)
//------------------------------------------------------------------------------
DCM21::DCM21(const DCM21 &copy)
   : AttitudeReal(copy)
{
}
//------------------------------------------------------------------------------
// DCM21& operator=(const DCM21 &right)
//------------------------------------------------------------------------------
DCM21& DCM21::operator=(const DCM21 &right)
{
   if (this != &right)
      AttitudeReal::operator=(right);

   return *this;
}
//------------------------------------------------------------------------------
// ~DCM21()
//------------------------------------------------------------------------------
DCM21::~DCM21()
{
}
//------------------------------------------------------------------------------
// bool Evaluate()
//------------------------------------------------------------------------------
bool DCM21::Evaluate()
{
   mRealValue = AttitudeData::GetAttitudeReal(DCM2_1);
    
   if (mRealValue == AttitudeData::ATTITUDE_REAL_UNDEFINED)
      return false;
   else
      return true;
}
//------------------------------------------------------------------------------
// GmatBase* DCM21::Clone(void) const
//------------------------------------------------------------------------------
GmatBase* DCM21::Clone(void) const
{
   return new DCM21(*this);
}

//------------------------------------------------------------------------------
//  DCM22
//------------------------------------------------------------------------------
//------------------------------------------------------------------------------
// DCM22(const std::string &name, GmatBase *obj)
//------------------------------------------------------------------------------
DCM22::DCM22(const std::string &name, GmatBase *obj)
   : AttitudeReal(name, "DCM22", obj, "Direction Cosine Matrix 2,2", "")
{
   #ifdef USE_PREDEFINED_COLORS
      mColor = GmatColor::ORANGE32;
   #endif
}
//------------------------------------------------------------------------------
// DCM22(const DCM22 &copy)
//------------------------------------------------------------------------------
DCM22::DCM22(const DCM22 &copy)
   : AttitudeReal(copy)
{
}
//------------------------------------------------------------------------------
// DCM22& operator=(const DCM22 &right)
//------------------------------------------------------------------------------
DCM22& DCM22::operator=(const DCM22 &right)
{
   if (this != &right)
      AttitudeReal::operator=(right);

   return *this;
}
//------------------------------------------------------------------------------
// ~DCM22()
//------------------------------------------------------------------------------
DCM22::~DCM22()
{
}
//------------------------------------------------------------------------------
// bool Evaluate()
//------------------------------------------------------------------------------
bool DCM22::Evaluate()
{
   mRealValue = AttitudeData::GetAttitudeReal(DCM2_2);
    
   if (mRealValue == AttitudeData::ATTITUDE_REAL_UNDEFINED)
      return false;
   else
      return true;
}
//------------------------------------------------------------------------------
// GmatBase* DCM22::Clone(void) const
//------------------------------------------------------------------------------
GmatBase* DCM22::Clone(void) const
{
   return new DCM22(*this);
}

//------------------------------------------------------------------------------
//  DCM23
//------------------------------------------------------------------------------
//------------------------------------------------------------------------------
// DCM23(const std::string &name, GmatBase *obj)
//------------------------------------------------------------------------------
DCM23::DCM23(const std::string &name, GmatBase *obj)
   : AttitudeReal(name, "DCM23", obj, "Direction Cosine Matrix 2,3", "")
{
   #ifdef USE_PREDEFINED_COLORS
      mColor = GmatColor::CHESTNUT;
   #endif
}
//------------------------------------------------------------------------------
// DCM23(const DCM23 &copy)
//------------------------------------------------------------------------------
DCM23::DCM23(const DCM23 &copy)
   : AttitudeReal(copy)
{
}
//------------------------------------------------------------------------------
// DCM23& operator=(const DCM23 &right)
//------------------------------------------------------------------------------
DCM23& DCM23::operator=(const DCM23 &right)
{
   if (this != &right)
      AttitudeReal::operator=(right);

   return *this;
}
//------------------------------------------------------------------------------
// ~DCM23()
//------------------------------------------------------------------------------
DCM23::~DCM23()
{
}
//------------------------------------------------------------------------------
// bool Evaluate()
//------------------------------------------------------------------------------
bool DCM23::Evaluate()
{
   mRealValue = AttitudeData::GetAttitudeReal(DCM2_3);
    
   if (mRealValue == AttitudeData::ATTITUDE_REAL_UNDEFINED)
      return false;
   else
      return true;
}
//------------------------------------------------------------------------------
// GmatBase* DCM23::Clone(void) const
//------------------------------------------------------------------------------
GmatBase* DCM23::Clone(void) const
{
   return new DCM23(*this);
}

//------------------------------------------------------------------------------
//  DCM31
//------------------------------------------------------------------------------
//------------------------------------------------------------------------------
// DCM31(const std::string &name, GmatBase *obj)
//------------------------------------------------------------------------------
DCM31::DCM31(const std::string &name, GmatBase *obj)
   : AttitudeReal(name, "DCM31", obj, "Direction Cosine Matrix 3,1", "")
{
   #ifdef USE_PREDEFINED_COLORS
      mColor = GmatColor::PURPLE32;
   #endif
}
//------------------------------------------------------------------------------
// DCM31(const DCM31 &copy)
//------------------------------------------------------------------------------
DCM31::DCM31(const DCM31 &copy)
   : AttitudeReal(copy)
{
}
//------------------------------------------------------------------------------
// DCM31& operator=(const DCM31 &right)
//------------------------------------------------------------------------------
DCM31& DCM31::operator=(const DCM31 &right)
{
   if (this != &right)
      AttitudeReal::operator=(right);

   return *this;
}
//------------------------------------------------------------------------------
// ~DCM31()
//------------------------------------------------------------------------------
DCM31::~DCM31()
{
}
//------------------------------------------------------------------------------
// bool Evaluate()
//------------------------------------------------------------------------------
bool DCM31::Evaluate()
{
   mRealValue = AttitudeData::GetAttitudeReal(DCM3_1);
    
   if (mRealValue == AttitudeData::ATTITUDE_REAL_UNDEFINED)
      return false;
   else
      return true;
}
//------------------------------------------------------------------------------
// GmatBase* DCM31::Clone(void) const
//------------------------------------------------------------------------------
GmatBase* DCM31::Clone(void) const
{
   return new DCM31(*this);
}

//------------------------------------------------------------------------------
//  DCM32
//------------------------------------------------------------------------------
//------------------------------------------------------------------------------
// DCM32(const std::string &name, GmatBase *obj)
//------------------------------------------------------------------------------
DCM32::DCM32(const std::string &name, GmatBase *obj)
   : AttitudeReal(name, "DCM32", obj, "Direction Cosine Matrix 3,2", "")
{
   #ifdef USE_PREDEFINED_COLORS
      mColor = GmatColor::LIME32;
   #endif
}
//------------------------------------------------------------------------------
// DCM32(const DCM32 &copy)
//------------------------------------------------------------------------------
DCM32::DCM32(const DCM32 &copy)
   : AttitudeReal(copy)
{
}
//------------------------------------------------------------------------------
// DCM32& operator=(const DCM32 &right)
//------------------------------------------------------------------------------
DCM32& DCM32::operator=(const DCM32 &right)
{
   if (this != &right)
      AttitudeReal::operator=(right);

   return *this;
}
//------------------------------------------------------------------------------
// ~DCM32()
//------------------------------------------------------------------------------
DCM32::~DCM32()
{
}
//------------------------------------------------------------------------------
// bool Evaluate()
//------------------------------------------------------------------------------
bool DCM32::Evaluate()
{
   mRealValue = AttitudeData::GetAttitudeReal(DCM3_2);
    
   if (mRealValue == AttitudeData::ATTITUDE_REAL_UNDEFINED)
      return false;
   else
      return true;
}
//------------------------------------------------------------------------------
// GmatBase* DCM32::Clone(void) const
//------------------------------------------------------------------------------
GmatBase* DCM32::Clone(void) const
{
   return new DCM32(*this);
}

//------------------------------------------------------------------------------
//  DCM33
//------------------------------------------------------------------------------
//------------------------------------------------------------------------------
// DCM33(const std::string &name, GmatBase *obj)
//------------------------------------------------------------------------------
DCM33::DCM33(const std::string &name, GmatBase *obj)
   : AttitudeReal(name, "DCM33", obj, "Direction Cosine Matrix 3,3", "")
{
   #ifdef USE_PREDEFINED_COLORS
      mColor = GmatColor::AQUA32;
   #endif
}
//------------------------------------------------------------------------------
// DCM33(const DCM33 &copy)
//------------------------------------------------------------------------------
DCM33::DCM33(const DCM33 &copy)
   : AttitudeReal(copy)
{
}
//------------------------------------------------------------------------------
// DCM33& operator=(const DCM33 &right)
//------------------------------------------------------------------------------
DCM33& DCM33::operator=(const DCM33 &right)
{
   if (this != &right)
      AttitudeReal::operator=(right);

   return *this;
}
//------------------------------------------------------------------------------
// ~DCM33()
//------------------------------------------------------------------------------
DCM33::~DCM33()
{
}
//------------------------------------------------------------------------------
// bool Evaluate()
//------------------------------------------------------------------------------
bool DCM33::Evaluate()
{
   mRealValue = AttitudeData::GetAttitudeReal(DCM3_3);
    
   if (mRealValue == AttitudeData::ATTITUDE_REAL_UNDEFINED)
      return false;
   else
      return true;
}
//------------------------------------------------------------------------------
// GmatBase* DCM33::Clone(void) const
//------------------------------------------------------------------------------
GmatBase* DCM33::Clone(void) const
{
   return new DCM33(*this);
}

//------------------------------------------------------------------------------
//------------------------------------------------------------------------------
//  Euler Angles  --------------------------------------------------------------
//------------------------------------------------------------------------------
//------------------------------------------------------------------------------
//------------------------------------------------------------------------------
//  EulerAngle1
//------------------------------------------------------------------------------
//------------------------------------------------------------------------------
// EulerAngle1::EulerAngle1(const std::string &name, GmatBase *obj)
//------------------------------------------------------------------------------
EulerAngle1::EulerAngle1(const std::string &name, GmatBase *obj)
   : AttitudeReal(name, "EulerAngle1", obj, "Euler Angle 1", "deg")
{
   #ifdef USE_PREDEFINED_COLORS
      mColor = GmatColor::RED32;
   #endif
   mIsAngleParam = true;
   mCycleType = GmatParam::PLUS_MINUS_180;
}
//------------------------------------------------------------------------------
// EulerAngle1(const EulerAngle1 &copy)
//------------------------------------------------------------------------------
EulerAngle1::EulerAngle1(const EulerAngle1 &copy)
   : AttitudeReal(copy)
{
}
//------------------------------------------------------------------------------
// EulerAngle1& operator=(const EulerAngle1 &right)
//------------------------------------------------------------------------------
EulerAngle1& EulerAngle1::operator=(const EulerAngle1 &right)
{
   if (this != &right)
      AttitudeReal::operator=(right);

   return *this;
}
//------------------------------------------------------------------------------
// ~EulerAngle1()
//------------------------------------------------------------------------------
EulerAngle1::~EulerAngle1()
{
}
//------------------------------------------------------------------------------
// bool Evaluate()
//------------------------------------------------------------------------------
bool EulerAngle1::Evaluate()
{
   mRealValue = AttitudeData::GetAttitudeReal(EULERANGLE1);
    
   if (mRealValue == AttitudeData::ATTITUDE_REAL_UNDEFINED)
      return false;
   else
      return true;
}
//------------------------------------------------------------------------------
// GmatBase* Clone(void) const
//------------------------------------------------------------------------------
GmatBase* EulerAngle1::Clone(void) const
{
   return new EulerAngle1(*this);
}

//------------------------------------------------------------------------------
//  EulerAngle2
//------------------------------------------------------------------------------
//------------------------------------------------------------------------------
// EulerAngle2::EulerAngle2(const std::string &name, GmatBase *obj)
//------------------------------------------------------------------------------
EulerAngle2::EulerAngle2(const std::string &name, GmatBase *obj)
   : AttitudeReal(name, "EulerAngle2", obj, "Euler Angle 2", "deg")
{
   #ifdef USE_PREDEFINED_COLORS
      mColor = GmatColor::YELLOW32;
   #endif
   mIsAngleParam = true;
   mCycleType = GmatParam::PLUS_MINUS_180;
}
//------------------------------------------------------------------------------
// EulerAngle2(const EulerAngle2 &copy)
//------------------------------------------------------------------------------
EulerAngle2::EulerAngle2(const EulerAngle2 &copy)
   : AttitudeReal(copy)
{
}
//------------------------------------------------------------------------------
// EulerAngle2& operator=(const EulerAngle2 &right)
//------------------------------------------------------------------------------
EulerAngle2& EulerAngle2::operator=(const EulerAngle2 &right)
{
   if (this != &right)
      AttitudeReal::operator=(right);

   return *this;
}
//------------------------------------------------------------------------------
// ~EulerAngle2()
//------------------------------------------------------------------------------
EulerAngle2::~EulerAngle2()
{
}
//------------------------------------------------------------------------------
// bool Evaluate()
//------------------------------------------------------------------------------
bool EulerAngle2::Evaluate()
{
   mRealValue = AttitudeData::GetAttitudeReal(EULERANGLE2);
    
   if (mRealValue == AttitudeData::ATTITUDE_REAL_UNDEFINED)
      return false;
   else
      return true;
}
//------------------------------------------------------------------------------
// GmatBase* Clone(void) const
//------------------------------------------------------------------------------
GmatBase* EulerAngle2::Clone(void) const
{
   return new EulerAngle2(*this);
}

//------------------------------------------------------------------------------
//  EulerAngle3
//------------------------------------------------------------------------------
//------------------------------------------------------------------------------
// EulerAngle3::EulerAngle3(const std::string &name, GmatBase *obj)
//------------------------------------------------------------------------------
EulerAngle3::EulerAngle3(const std::string &name, GmatBase *obj)
   : AttitudeReal(name, "EulerAngle3", obj, "Euler Angle 3", "deg")
{
   #ifdef USE_PREDEFINED_COLORS
      mColor = GmatColor::BLUE32;
   #endif
   mIsAngleParam = true;
   mCycleType = GmatParam::PLUS_MINUS_180;
}
//------------------------------------------------------------------------------
// EulerAngle3(const EulerAngle3 &copy)
//------------------------------------------------------------------------------
EulerAngle3::EulerAngle3(const EulerAngle3 &copy)
   : AttitudeReal(copy)
{
}
//------------------------------------------------------------------------------
// EulerAngle3& operator=(const EulerAngle3 &right)
//------------------------------------------------------------------------------
EulerAngle3& EulerAngle3::operator=(const EulerAngle3 &right)
{
   if (this != &right)
      AttitudeReal::operator=(right);

   return *this;
}
//------------------------------------------------------------------------------
// ~EulerAngle3()
//------------------------------------------------------------------------------
EulerAngle3::~EulerAngle3()
{
}
//------------------------------------------------------------------------------
// bool Evaluate()
//------------------------------------------------------------------------------
bool EulerAngle3::Evaluate()
{
   mRealValue = AttitudeData::GetAttitudeReal(EULERANGLE3);
    
   if (mRealValue == AttitudeData::ATTITUDE_REAL_UNDEFINED)
      return false;
   else
      return true;
}
//------------------------------------------------------------------------------
// GmatBase* Clone(void) const
//------------------------------------------------------------------------------
GmatBase* EulerAngle3::Clone(void) const
{
   return new EulerAngle3(*this);
}


//------------------------------------------------------------------------------
//------------------------------------------------------------------------------
//  Modified Rodrigues Parameters - Added by Dunn ------------------------------
//------------------------------------------------------------------------------
//------------------------------------------------------------------------------
//------------------------------------------------------------------------------
//  MRP1
//------------------------------------------------------------------------------
//------------------------------------------------------------------------------
// MRP1::MRP1(const std::string &name, GmatBase *obj)
//------------------------------------------------------------------------------
MRP1::MRP1(const std::string &name, GmatBase *obj)
: AttitudeReal(name, "MRP1", obj, "Mod Rod Param 1", "")
{
   mColor = GmatColor::RED32;
}
//------------------------------------------------------------------------------
// MRP1(const MRP1 &copy)
//------------------------------------------------------------------------------
MRP1::MRP1(const MRP1 &copy)
: AttitudeReal(copy)
{
}
//------------------------------------------------------------------------------
// MRP1& operator=(const MRP1 &right)
//------------------------------------------------------------------------------
MRP1& MRP1::operator=(const MRP1 &right)
{
   if (this != &right)
      AttitudeReal::operator=(right);

   return *this;
}
//------------------------------------------------------------------------------
// ~MRP1()
//------------------------------------------------------------------------------
MRP1::~MRP1()
{
}
//------------------------------------------------------------------------------
// bool Evaluate()
//------------------------------------------------------------------------------
bool MRP1::Evaluate()
{
   mRealValue = AttitudeData::GetAttitudeReal(MRP_1);

   if (mRealValue == AttitudeData::ATTITUDE_REAL_UNDEFINED)
      return false;
   else
      return true;
}
//------------------------------------------------------------------------------
// GmatBase* Clone(void) const
//------------------------------------------------------------------------------
GmatBase* MRP1::Clone(void) const
{
   return new MRP1(*this);
}


//------------------------------------------------------------------------------
//  MRP2 - Added by Dunn
//------------------------------------------------------------------------------
//------------------------------------------------------------------------------
// MRP2::MRP2(const std::string &name, GmatBase *obj)
//------------------------------------------------------------------------------
MRP2::MRP2(const std::string &name, GmatBase *obj)
: AttitudeReal(name, "MRP2", obj, "Mod Rod Param 2", "")
{
   mColor = GmatColor::GREEN32;
}
//------------------------------------------------------------------------------
// MRP2(const MRP2 &copy)
//------------------------------------------------------------------------------
MRP2::MRP2(const MRP2 &copy)
: AttitudeReal(copy)
{
}
//------------------------------------------------------------------------------
// MRP2& operator=(const MRP2 &right)
//------------------------------------------------------------------------------
MRP2& MRP2::operator=(const MRP2 &right)
{
   if (this != &right)
      AttitudeReal::operator=(right);

   return *this;
}
//------------------------------------------------------------------------------
// ~MRP2()
//------------------------------------------------------------------------------
MRP2::~MRP2()
{
}
//------------------------------------------------------------------------------
// bool Evaluate()
//------------------------------------------------------------------------------
bool MRP2::Evaluate()
{
   mRealValue = AttitudeData::GetAttitudeReal(MRP_2);

   if (mRealValue == AttitudeData::ATTITUDE_REAL_UNDEFINED)
      return false;
   else
      return true;
}
//------------------------------------------------------------------------------
// GmatBase* Clone(void) const
//------------------------------------------------------------------------------
GmatBase* MRP2::Clone(void) const
{
   return new MRP2(*this);
}


//------------------------------------------------------------------------------
//  MRP3 - Added by Dunn
//------------------------------------------------------------------------------
//------------------------------------------------------------------------------
// MRP3::MRP3(const std::string &name, GmatBase *obj)
//------------------------------------------------------------------------------
MRP3::MRP3(const std::string &name, GmatBase *obj)
: AttitudeReal(name, "MRP3", obj, "Mod Rod Param 3", "")
{
   mColor = GmatColor::BLUE32;
}
//------------------------------------------------------------------------------
// MRP3(const MRP3 &copy)
//------------------------------------------------------------------------------
MRP3::MRP3(const MRP3 &copy)
: AttitudeReal(copy)
{
}
//------------------------------------------------------------------------------
// MRP3& operator=(const MRP3 &right)
//------------------------------------------------------------------------------
MRP3& MRP3::operator=(const MRP3 &right)
{
   if (this != &right)
      AttitudeReal::operator=(right);

   return *this;
}
//------------------------------------------------------------------------------
// ~MRP3()
//------------------------------------------------------------------------------
MRP3::~MRP3()
{
}
//------------------------------------------------------------------------------
// bool Evaluate()
//------------------------------------------------------------------------------
bool MRP3::Evaluate()
{
   mRealValue = AttitudeData::GetAttitudeReal(MRP_3);

   if (mRealValue == AttitudeData::ATTITUDE_REAL_UNDEFINED)
      return false;
   else
      return true;
}
//------------------------------------------------------------------------------
// GmatBase* Clone(void) const
//------------------------------------------------------------------------------
GmatBase* MRP3::Clone(void) const
{
   return new MRP3(*this);
}



//------------------------------------------------------------------------------
//------------------------------------------------------------------------------
//  Quaternions  ---------------------------------------------------------------
//------------------------------------------------------------------------------
//------------------------------------------------------------------------------

//------------------------------------------------------------------------------
//  Quat1
//------------------------------------------------------------------------------
//------------------------------------------------------------------------------
// Quat1(const std::string &name, GmatBase *obj)
//------------------------------------------------------------------------------
Quat1::Quat1(const std::string &name, GmatBase *obj)
   : AttitudeReal(name, "Q1", obj, "Quaternion 1", "")
{
   #ifdef USE_PREDEFINED_COLORS
      mColor = GmatColor::RED32;
   #endif
}
//------------------------------------------------------------------------------
// Quat1(const Quat1 &copy)
//------------------------------------------------------------------------------
Quat1::Quat1(const Quat1 &copy)
   : AttitudeReal(copy)
{
}
//------------------------------------------------------------------------------
// Quat1& operator=(const Quat1 &right)
//------------------------------------------------------------------------------
Quat1& Quat1::operator=(const Quat1 &right)
{
   if (this != &right)
      AttitudeReal::operator=(right);

   return *this;
}
//------------------------------------------------------------------------------
// ~Quat1()
//------------------------------------------------------------------------------
Quat1::~Quat1()
{
}
//------------------------------------------------------------------------------
// bool Evaluate()
//------------------------------------------------------------------------------
bool Quat1::Evaluate()
{
   mRealValue = AttitudeData::GetAttitudeReal(QUAT1);
    
   if (mRealValue == AttitudeData::ATTITUDE_REAL_UNDEFINED)
      return false;
   else
      return true;
}
//------------------------------------------------------------------------------
// GmatBase* Quat1::Clone(void) const
//------------------------------------------------------------------------------
GmatBase* Quat1::Clone(void) const
{
   return new Quat1(*this);
}

//------------------------------------------------------------------------------
//  Quat2
//------------------------------------------------------------------------------
//------------------------------------------------------------------------------
// Quat2(const std::string &name, GmatBase *obj)
//------------------------------------------------------------------------------
Quat2::Quat2(const std::string &name, GmatBase *obj)
   : AttitudeReal(name, "Q2", obj, "Quaternion 2", "")
{
   #ifdef USE_PREDEFINED_COLORS
      mColor = GmatColor::YELLOW32;
   #endif
}
//------------------------------------------------------------------------------
// Quat2(const Quat2 &copy)
//------------------------------------------------------------------------------
Quat2::Quat2(const Quat2 &copy)
   : AttitudeReal(copy)
{
}
//------------------------------------------------------------------------------
// Quat2& operator=(const Quat2 &right)
//------------------------------------------------------------------------------
Quat2& Quat2::operator=(const Quat2 &right)
{
   if (this != &right)
      AttitudeReal::operator=(right);

   return *this;
}
//------------------------------------------------------------------------------
// ~Quat2()
//------------------------------------------------------------------------------
Quat2::~Quat2()
{
}
//------------------------------------------------------------------------------
// bool Evaluate()
//------------------------------------------------------------------------------
bool Quat2::Evaluate()
{
   mRealValue = AttitudeData::GetAttitudeReal(QUAT2);
    
   if (mRealValue == AttitudeData::ATTITUDE_REAL_UNDEFINED)
      return false;
   else
      return true;
}
//------------------------------------------------------------------------------
// GmatBase* Clone(void) const
//------------------------------------------------------------------------------
GmatBase* Quat2::Clone(void) const
{
   return new Quat2(*this);
}

//------------------------------------------------------------------------------
//  Quat3
//------------------------------------------------------------------------------
//------------------------------------------------------------------------------
// Quat3(const std::string &name, GmatBase *obj)
//------------------------------------------------------------------------------
Quat3::Quat3(const std::string &name, GmatBase *obj)
   : AttitudeReal(name, "Q3", obj, "Quaternion 3", "")
{
   #ifdef USE_PREDEFINED_COLORS
      mColor = GmatColor::BLUE32;
   #endif
}
//------------------------------------------------------------------------------
// Quat3(const Quat3 &copy)
//------------------------------------------------------------------------------
Quat3::Quat3(const Quat3 &copy)
   : AttitudeReal(copy)
{
}
//------------------------------------------------------------------------------
// Quat3& operator=(const Quat3 &right)
//------------------------------------------------------------------------------
Quat3& Quat3::operator=(const Quat3 &right)
{
   if (this != &right)
      AttitudeReal::operator=(right);

   return *this;
}
//------------------------------------------------------------------------------
// ~Quat3()
//------------------------------------------------------------------------------
Quat3::~Quat3()
{
}
//------------------------------------------------------------------------------
// bool Evaluate()
//------------------------------------------------------------------------------
bool Quat3::Evaluate()
{
   mRealValue = AttitudeData::GetAttitudeReal(QUAT3);
    
   if (mRealValue == AttitudeData::ATTITUDE_REAL_UNDEFINED)
      return false;
   else
      return true;
}
//------------------------------------------------------------------------------
// GmatBase* Clone(void) const
//------------------------------------------------------------------------------
GmatBase* Quat3::Clone(void) const
{
   return new Quat3(*this);
}

//------------------------------------------------------------------------------
//  Quat4
//------------------------------------------------------------------------------
//------------------------------------------------------------------------------
// Quat4::Quat4(const std::string &name, GmatBase *obj)
//------------------------------------------------------------------------------
Quat4::Quat4(const std::string &name, GmatBase *obj)
   : AttitudeReal(name, "Q4", obj, "Quaternion 4", "")
{
   #ifdef USE_PREDEFINED_COLORS
      mColor = GmatColor::GREEN32;
   #endif
}
//------------------------------------------------------------------------------
// Quat4(const Quat4 &copy)
//------------------------------------------------------------------------------
Quat4::Quat4(const Quat4 &copy)
   : AttitudeReal(copy)
{
}
//------------------------------------------------------------------------------
// Quat4& operator=(const Quat4 &right)
//------------------------------------------------------------------------------
Quat4& Quat4::operator=(const Quat4 &right)
{
   if (this != &right)
      AttitudeReal::operator=(right);

   return *this;
}
//------------------------------------------------------------------------------
// ~Quat4()
//------------------------------------------------------------------------------
Quat4::~Quat4()
{
}
//------------------------------------------------------------------------------
// bool Evaluate()
//------------------------------------------------------------------------------
bool Quat4::Evaluate()
{
   mRealValue = AttitudeData::GetAttitudeReal(QUAT4);
    
   if (mRealValue == AttitudeData::ATTITUDE_REAL_UNDEFINED)
      return false;
   else
      return true;
}
//------------------------------------------------------------------------------
// GmatBase* Clone(void) const
//------------------------------------------------------------------------------
GmatBase* Quat4::Clone(void) const
{
   return new Quat4(*this);
}

//------------------------------------------------------------------------------
//------------------------------------------------------------------------------
//  Angular Velocity  ----------------------------------------------------------
//------------------------------------------------------------------------------
//------------------------------------------------------------------------------

//------------------------------------------------------------------------------
//  AngVelX
//------------------------------------------------------------------------------
//------------------------------------------------------------------------------
// AngVelX::AngVelX(const std::string &name, GmatBase *obj)
//------------------------------------------------------------------------------
AngVelX::AngVelX(const std::string &name, GmatBase *obj)
   : AttitudeReal(name, "AngularVelocityX", obj, "Angular Velocity X", "deg/sec")
{
   #ifdef USE_PREDEFINED_COLORS
      mColor = GmatColor::RED32;
   #endif
}
//------------------------------------------------------------------------------
// AngVelX(const AngVelX &copy)
//------------------------------------------------------------------------------
AngVelX::AngVelX(const AngVelX &copy)
   : AttitudeReal(copy)
{
}
//------------------------------------------------------------------------------
// AngVelX& operator=(const AngVelX &right)
//------------------------------------------------------------------------------
AngVelX& AngVelX::operator=(const AngVelX &right)
{
   if (this != &right)
      AttitudeReal::operator=(right);

   return *this;
}
//------------------------------------------------------------------------------
// ~AngVelX()
//------------------------------------------------------------------------------
AngVelX::~AngVelX()
{
}
//------------------------------------------------------------------------------
// bool Evaluate()
//------------------------------------------------------------------------------
bool AngVelX::Evaluate()
{
   mRealValue = AttitudeData::GetAttitudeReal(ANGVELX);
    
   if (mRealValue == AttitudeData::ATTITUDE_REAL_UNDEFINED)
      return false;
   else
      return true;
}
//------------------------------------------------------------------------------
// GmatBase* Clone(void) const
//------------------------------------------------------------------------------
GmatBase* AngVelX::Clone(void) const
{
   return new AngVelX(*this);
}

//------------------------------------------------------------------------------
//  AngVelY
//------------------------------------------------------------------------------
//------------------------------------------------------------------------------
// AngVelY::AngVelY(const std::string &name, GmatBase *obj)
//------------------------------------------------------------------------------
AngVelY::AngVelY(const std::string &name, GmatBase *obj)
   : AttitudeReal(name, "AngularVelocityY", obj, "Angular Velocity Y", "deg/sec")
{
   #ifdef USE_PREDEFINED_COLORS
      mColor = GmatColor::YELLOW32;
   #endif
}
//------------------------------------------------------------------------------
// AngVelY(const AngVelY &copy)
//------------------------------------------------------------------------------
AngVelY::AngVelY(const AngVelY &copy)
   : AttitudeReal(copy)
{
}
//------------------------------------------------------------------------------
// AngVelY& operator=(const AngVelY &right)
//------------------------------------------------------------------------------
AngVelY& AngVelY::operator=(const AngVelY &right)
{
   if (this != &right)
      AttitudeReal::operator=(right);

   return *this;
}
//------------------------------------------------------------------------------
// ~AngVelY()
//------------------------------------------------------------------------------
AngVelY::~AngVelY()
{
}
//------------------------------------------------------------------------------
// bool Evaluate()
//------------------------------------------------------------------------------
bool AngVelY::Evaluate()
{
   mRealValue = AttitudeData::GetAttitudeReal(ANGVELY);
    
   if (mRealValue == AttitudeData::ATTITUDE_REAL_UNDEFINED)
      return false;
   else
      return true;
}
//------------------------------------------------------------------------------
// GmatBase* Clone(void) const
//------------------------------------------------------------------------------
GmatBase* AngVelY::Clone(void) const
{
   return new AngVelY(*this);
}

//------------------------------------------------------------------------------
//  AngVelZ
//------------------------------------------------------------------------------
//------------------------------------------------------------------------------
// AngVelZ::AngVelZ(const std::string &name, GmatBase *obj)
//------------------------------------------------------------------------------
AngVelZ::AngVelZ(const std::string &name, GmatBase *obj)
   : AttitudeReal(name, "AngularVelocityZ", obj, "Angular Velocity Z", "deg/sec")
{
   #ifdef USE_PREDEFINED_COLORS
      mColor = GmatColor::BLUE32;
   #endif
}
//------------------------------------------------------------------------------
// AngVelZ(const AngVelZ &copy)
//------------------------------------------------------------------------------
AngVelZ::AngVelZ(const AngVelZ &copy)
   : AttitudeReal(copy)
{
}
//------------------------------------------------------------------------------
// AngVelZ& operator=(const AngVelZ &right)
//------------------------------------------------------------------------------
AngVelZ& AngVelZ::operator=(const AngVelZ &right)
{
   if (this != &right)
      AttitudeReal::operator=(right);

   return *this;
}
//------------------------------------------------------------------------------
// ~AngVelZ()
//------------------------------------------------------------------------------
AngVelZ::~AngVelZ()
{
}
//------------------------------------------------------------------------------
// bool Evaluate()
//------------------------------------------------------------------------------
bool AngVelZ::Evaluate()
{
   mRealValue = AttitudeData::GetAttitudeReal(ANGVELZ);
    
   if (mRealValue == AttitudeData::ATTITUDE_REAL_UNDEFINED)
      return false;
   else
      return true;
}
//------------------------------------------------------------------------------
// GmatBase* Clone(void) const
//------------------------------------------------------------------------------
GmatBase* AngVelZ::Clone(void) const
{
   return new AngVelZ(*this);
}

//------------------------------------------------------------------------------
//------------------------------------------------------------------------------
//  Euler Angle Rates  ---------------------------------------------------------
//------------------------------------------------------------------------------
//------------------------------------------------------------------------------
//------------------------------------------------------------------------------
//  EulerAngleRate1
//------------------------------------------------------------------------------
//------------------------------------------------------------------------------
// EulerAngleRate1::EulerAngleRate1(const std::string &name, GmatBase *obj)
//------------------------------------------------------------------------------
EulerAngleRate1::EulerAngleRate1(const std::string &name, GmatBase *obj)
   : AttitudeReal(name, "EulerAngleRate1", obj, "Euler Angle Rate 1", "deg/sec")
{
   #ifdef USE_PREDEFINED_COLORS
      mColor = GmatColor::RED32;
   #endif
}
//------------------------------------------------------------------------------
// EulerAngleRate1(const EulerAngleRate1 &copy)
//------------------------------------------------------------------------------
EulerAngleRate1::EulerAngleRate1(const EulerAngleRate1 &copy)
   : AttitudeReal(copy)
{
}
//------------------------------------------------------------------------------
// EulerAngleRate1& operator=(const EulerAngleRate1 &right)
//------------------------------------------------------------------------------
EulerAngleRate1& EulerAngleRate1::operator=(const EulerAngleRate1 &right)
{
   if (this != &right)
      AttitudeReal::operator=(right);

   return *this;
}
//------------------------------------------------------------------------------
// ~EulerAngleRate1()
//------------------------------------------------------------------------------
EulerAngleRate1::~EulerAngleRate1()
{
}
//------------------------------------------------------------------------------
// bool Evaluate()
//------------------------------------------------------------------------------
bool EulerAngleRate1::Evaluate()
{
   mRealValue = AttitudeData::GetAttitudeReal(EULERANGLERATE1);
    
   if (mRealValue == AttitudeData::ATTITUDE_REAL_UNDEFINED)
      return false;
   else
      return true;
}
//------------------------------------------------------------------------------
// GmatBase* Clone(void) const
//------------------------------------------------------------------------------
GmatBase* EulerAngleRate1::Clone(void) const
{
   return new EulerAngleRate1(*this);
}

//------------------------------------------------------------------------------
//  EulerAngleRate2
//------------------------------------------------------------------------------
//------------------------------------------------------------------------------
// EulerAngleRate2::EulerAngleRate2(const std::string &name, GmatBase *obj)
//------------------------------------------------------------------------------
EulerAngleRate2::EulerAngleRate2(const std::string &name, GmatBase *obj)
   : AttitudeReal(name, "EulerAngleRate2", obj, "Euler Angle Rate 2", "deg/sec")
{
   #ifdef USE_PREDEFINED_COLORS
      mColor = GmatColor::YELLOW32;
   #endif
}
//------------------------------------------------------------------------------
// EulerAngleRate2(const EulerAngleRate2 &copy)
//------------------------------------------------------------------------------
EulerAngleRate2::EulerAngleRate2(const EulerAngleRate2 &copy)
   : AttitudeReal(copy)
{
}
//------------------------------------------------------------------------------
// EulerAngleRate2& operator=(const EulerAngleRate2 &right)
//------------------------------------------------------------------------------
EulerAngleRate2& EulerAngleRate2::operator=(const EulerAngleRate2 &right)
{
   if (this != &right)
      AttitudeReal::operator=(right);

   return *this;
}
//------------------------------------------------------------------------------
// ~EulerAngleRate2()
//------------------------------------------------------------------------------
EulerAngleRate2::~EulerAngleRate2()
{
}
//------------------------------------------------------------------------------
// bool Evaluate()
//------------------------------------------------------------------------------
bool EulerAngleRate2::Evaluate()
{
   mRealValue = AttitudeData::GetAttitudeReal(EULERANGLERATE2);
    
   if (mRealValue == AttitudeData::ATTITUDE_REAL_UNDEFINED)
      return false;
   else
      return true;
}
//------------------------------------------------------------------------------
// GmatBase* Clone(void) const
//------------------------------------------------------------------------------
GmatBase* EulerAngleRate2::Clone(void) const
{
   return new EulerAngleRate2(*this);
}

//------------------------------------------------------------------------------
//  EulerAngleRate3
//------------------------------------------------------------------------------
//------------------------------------------------------------------------------
// EulerAngleRate3::EulerAngleRate3(const std::string &name, GmatBase *obj)
//------------------------------------------------------------------------------
EulerAngleRate3::EulerAngleRate3(const std::string &name, GmatBase *obj)
   : AttitudeReal(name, "EulerAngleRate3", obj, "Euler Angle Rate 3", "deg/sec")
{
   #ifdef USE_PREDEFINED_COLORS
      mColor = GmatColor::BLUE32;
   #endif
}
//------------------------------------------------------------------------------
// EulerAngleRate3(const EulerAngleRate3 &copy)
//------------------------------------------------------------------------------
EulerAngleRate3::EulerAngleRate3(const EulerAngleRate3 &copy)
   : AttitudeReal(copy)
{
}
//------------------------------------------------------------------------------
// EulerAngleRate3& operator=(const EulerAngleRate3 &right)
//------------------------------------------------------------------------------
EulerAngleRate3& EulerAngleRate3::operator=(const EulerAngleRate3 &right)
{
   if (this != &right)
      AttitudeReal::operator=(right);

   return *this;
}
//------------------------------------------------------------------------------
// ~EulerAngleRate3()
//------------------------------------------------------------------------------
EulerAngleRate3::~EulerAngleRate3()
{
}
//------------------------------------------------------------------------------
// bool Evaluate()
//------------------------------------------------------------------------------
bool EulerAngleRate3::Evaluate()
{
   mRealValue = AttitudeData::GetAttitudeReal(EULERANGLERATE3);
    
   if (mRealValue == AttitudeData::ATTITUDE_REAL_UNDEFINED)
      return false;
   else
      return true;
}
//------------------------------------------------------------------------------
// GmatBase* Clone(void) const
//------------------------------------------------------------------------------
GmatBase* EulerAngleRate3::Clone(void) const
{
   return new EulerAngleRate3(*this);
}

