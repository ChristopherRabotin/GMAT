//$Id$
//------------------------------------------------------------------------------
//                              RandomNumber
//------------------------------------------------------------------------------
// GMAT: General Mission Analysis Tool
//
// **Legal**
//
// Developed by Dr. Matthew P. Wilkins, Schafer Corporation
//
// Author: Matthew P. Wilkins
// Created: 2008/09/08
//
/**
 * GMAT's Random Number Class
 *
 * This class implements the double precision SIMD oriented Fast 
 * Mersenne Twister pseudorandom number generator (dSFMT) version 2.1. 
 *
 * SFMT is a new variant of Mersenne Twister (MT) introduced by Mutsuo Saito and 
 * Makoto Matsumoto in 2006. The algorithm was reported at MCQMC 2006 
 * (http://mcqmc.uni-ulm.de/). The article was published in the proceedings of 
 * MCQMC2006. (see Prof. Matsumoto's Papers on random number generation.)
 *
 * SFMT is a Linear Feedbacked Shift Register (LFSR) generator that generates 
 * a 128-bit pseudorandom integer at one step. SFMT is designed with recent 
 * parallelism of modern CPUs, such as multi-stage pipelining and SIMD 
 * (e.g. 128-bit integer) instructions. It supports 32-bit and 64-bit integers, 
 * as well as double precision floating point as output.
 * 
 * SFMT is much faster than MT, in most platforms. Not only the speed, but also 
 * the dimensions of equidistributions at v-bit precision are improved. 
 * In addition, recovery from 0-excess initial state is much faster. See 
 * Master's Thesis of Mutsuo Saito for detail.
 *
 * This program is based on the IEEE Standard for Binary Floating-Point 
 * Arithmetic (ANSI/IEEE Std 754-1985) format. dSFMT ver. 2.xx is completely 
 * different from dSFMT ver. 1.xx. The recursion formula is changed and the 
 * output sequences are changed. This version uses structure of C language. 
 * Don't use different DSFMT_MEXP for compiling dSFMT.c and your program. 
 * This Project provides pseudorandom number generators of various 
 * Mersenne Prime Period: from 2521-1 to 2216091-1.
 *
 * The purpose of dSFMT is to speed up the generation by avoiding the expensive 
 * conversion of integer to double (floating point). dSFMT directly generates 
 * double precision floating point pseudorandom numbers which have the IEEE 
 * Standard for Binary Floating-Point Arithmetic (ANSI/IEEE Std 754-1985) format. 
 * dSFMT is only available on the CPUs which use IEEE 754 format double precision 
 * floating point numbers.
 * 
 * dSFMT doesn't support integer outputs. dSFMT supports the output of double 
 * precision floating point pseudorandom numbers which distribute in the range 
 * of [1, 2), [0, 1), (0, 1] and (0, 1). And it also supports the various 
 * periods form 2607-1 to 2132049-1. (dSFMT ver. 2.1 supports the periods 
 * from 2521-1 to 2216091-1.)
 *
 * To compute a normally distributed Gaussian random deviate (zero mean, 
 * unit var) Hormann and Derflinger's transformed rejection with decomposition
 * is utilized. "Theoretical considerations and empirical results show that the 
 * one-dimensional quality of non-uniform random numbers is bad and the 
 * discrepancy is high when they are generated by the ratio of uniforms method 
 * combined with linear congruential generators. This observation motivates the 
 * suggestion to replace the ratio of uniforms method by transformed rejection 
 * (also called exact approximation or almost exact inversion), as the above 
 * problem does not occur for this method. Using the function 
 * $G(x) =\left( \frac{a}{1-x}+b\right)x $ with appropriate $a$ and $b$ as 
 * approximation of the inverse distribution function the transformed rejection 
 * method can be used for the same distributions as the ratio of uniforms 
 * method. The resulting algorithms for the normal, the exponential and the 
 * t-distribution are short and easy to implement. Looking at the number of 
 * uniform deviates required, at the code length and at the speed the suggested 
 * algorithms are superior to the ratio of uniforms method and compare well 
 * with other algorithms suggested in literature."
 * 
 * References
 *
 * Mutsuo Saito and Makoto Matsumoto, "SIMD-oriented Fast Mersenne Twister: a 
 * 128-bit Pseudorandom Number Generator", Monte Carlo and Quasi-Monte Carlo 
 * Methods 2006, Springer, 2008, pp. 607--622. DOI:10.1007/978-3-540-74496-2_36
 *
 * http://www.math.sci.hiroshima-u.ac.jp/~m-mat/MT/ARTICLES/sfmt.pdf
 * 
 * M. Matsumoto and T. Nishimura, "Mersenne Twister: A 623-dimensionally 
 * equidistributed uniform pseudorandom number generator", ACM Trans. on 
 * Modeling and Computer Simulation Vol. 8, No. 1, January pp.3-30 (1998) 
 * DOI:10.1145/272991.272995
 * 
 * http://www.math.sci.hiroshima-u.ac.jp/~m-mat/MT/ARTICLES/mt.pdf
 *
 * Hormann, Wolfgang and Derflinger, Gerhard. "The Tranformed Rejection Method
 * for Generating Random Variables, an Alternative to the Ration of Uniforms
 * Method." Communications in Statistics: Simulation and Computation 23, 3, 1994
 *
 * http://statmath.wu-wien.ac.at/papers/94-01-18.wh-der.ps.gz
 *
 */
//------------------------------------------------------------------------------

#include "RandomNumber.hpp"
#include "MessageInterface.hpp"
#include <time.h>
#include <stdlib.h>           // for srand, etc.


//#define DEBUG_CONSTRUCTOR
//#define DEBUG_CALCULATION


RandomNumber* RandomNumber::theInstance = NULL;

RandomNumber* RandomNumber::Instance()
{
   if (theInstance == NULL)
      theInstance = new RandomNumber;
   return theInstance;
}
//------------------------------------------------------------------------------
// RandomNumber()
//------------------------------------------------------------------------------
/**
 * Class constructor that seeds the generator using the clock.
 *
 */
//------------------------------------------------------------------------------
RandomNumber::RandomNumber()
{
#ifdef DEBUG_CONSTRUCTOR
	MessageInterface::ShowMessage("RandomNumber  default constructor\n");
#endif

    //unsigned int clockSeed = time(NULL);
    //srand(clockSeed);
    //currentIndex = 0;

    std::random_device rd;
    generator.seed(rd());

    std::uniform_real_distribution<>::param_type whiteParams(0.0, 1.0);
    white.param(whiteParams);
}


//------------------------------------------------------------------------------
// ~RandomNumber()
//------------------------------------------------------------------------------
/**
 * Class destructor.
 *
 */
//------------------------------------------------------------------------------
RandomNumber::~RandomNumber()
{
}


//------------------------------------------------------------------------------
//  void Seed(unsigned int s)
//------------------------------------------------------------------------------
/**
 *  Set the seed for the random number generator using a specified value.
 *
 *  @param <idum2> input seed
 */
//------------------------------------------------------------------------------
void RandomNumber::Seed(unsigned int s)
{
    //srand(s);
   generator.seed(s);
}


//------------------------------------------------------------------------------
//  void ClockSeed()
//------------------------------------------------------------------------------
/**
 * Set the seed value based upon the current clock time.
 */
//------------------------------------------------------------------------------
void RandomNumber::ClockSeed()
{
   unsigned int clockSeed = time(NULL);
   //srand(clockSeed);
   generator.seed(clockSeed);
}

////------------------------------------------------------------------------------
////  unsigned int UniformInt()
////------------------------------------------------------------------------------
///**
// *  Returns an unsigned 32-bit integer. This should only be used to seed.
// *
// *  @return The random deviate.
// *
// */
////------------------------------------------------------------------------------
//unsigned int RandomNumber::UniformInt()
//{
//     return rand();
//}

//------------------------------------------------------------------------------
//  Real Uniform()
//------------------------------------------------------------------------------
/**
 *  Returns an uniformly distributed random deviate in the range [0,1)
 *  The range includes 0.0 but excludes 1.0;
 *
 *  @return The random deviate.
 *
 */
//------------------------------------------------------------------------------
Real RandomNumber::Uniform()
{
	Real rn;
	do 
	{
	   rn = rrand();
   } while (rn == 1.0);
   
   return rn;
}

//------------------------------------------------------------------------------
//  Real UniformPrimitive()
//------------------------------------------------------------------------------
/**
 *  Returns an uniformly distributed random deviate in the range [1,2).
 *  The range includes 1.0 but excludes 2.0. This is the primitive MT generator
 *  that all other function calls are based upon. This is the fastest method
 *  for generating a random variate.
 *
 *  @return The random deviate.
 *
 */
//------------------------------------------------------------------------------
Real RandomNumber::UniformPrimitive()
{
     return (Uniform() + 1.0);
}

//------------------------------------------------------------------------------
//  Real UniformOpenOpen()
//------------------------------------------------------------------------------
/**
 *  Returns an uniformly distributed random deviate in the range (0,1)
 *  The range excludes both 0.0 and 1.0. This is useful when you need to
 *  avoid a singularity at 0 or 1.
 *
 *  @return The random deviate.
 *
 */
//------------------------------------------------------------------------------
Real RandomNumber::UniformOpenOpen()
{
   Real rn;
   rn = rrand();
   while ((rn == 1.0)||(rn == 0.0))
      rn = rrand();

   return rn;
}

 //------------------------------------------------------------------------------
//  Real UniformOpenClosed()
//------------------------------------------------------------------------------
/**
 *  Returns an uniformly distributed random deviate in the range (0,1]
 *  The range excludes 0.0 but includes 1.0. This is useful when you need to
 *  avoid a singularity at 0.
 *
 *  @return The random deviate.
 *
 */
//------------------------------------------------------------------------------
Real RandomNumber::UniformOpenClosed()
{
   Real rn;
   rn = rrand();
   while (rn == 0.0)
	  rn = rrand();

   return rn;
}

//------------------------------------------------------------------------------
//  Real Uniform(Real a, Real b)
//------------------------------------------------------------------------------
/**
 *  Returns an uniformly distributed random deviate in the range [a,b)
 *  The mean of this distribution is (a+b)/2.
 *  The variance of this distribution is (b-a)^2/12.
 *
 *  @param <a> Distribution start
 *  @param <b> Distribution end
 *  @return The random deviate.
 *
 */
//------------------------------------------------------------------------------
Real RandomNumber::Uniform(const Real a, const Real b)
{
   return a + (b - a)*Uniform();
}

//------------------------------------------------------------------------------
//  Real UniformOpenOpen(Real a, Real b)
//------------------------------------------------------------------------------
/**
 *  Returns an uniformly distributed random deviate in the range (a,b)
 *  The mean of this distribution is (a+b)/2.
 *  The variance of this distribution is (b-a)^2/12.
 *
 *  @param <a> Distribution start
 *  @param <b> Distribution end
 *  @return The random deviate.
 *
 */
//------------------------------------------------------------------------------
Real RandomNumber::UniformOpenOpen(const Real a, const Real b)
{
   return a + (b - a)*UniformOpenOpen();
}

//------------------------------------------------------------------------------
//  Real UniformOpenClosed(Real a, Real b)
//------------------------------------------------------------------------------
/**
 *  Returns an uniformly distributed random deviate in the range (a,b]
 *  The mean of this distribution is (a+b)/2.
 *  The variance of this distribution is (b-a)^2/12.
 *
 *  @param <a> Distribution start
 *  @param <b> Distribution end
 *  @return The random deviate.
 *
 */
//------------------------------------------------------------------------------
Real RandomNumber::UniformOpenClosed(const Real a, const Real b)
{
   return a + (b - a)*UniformOpenClosed();
}

//------------------------------------------------------------------------------
//  Real Gaussian()
//------------------------------------------------------------------------------
/**
 *  Returns a normally distributed Gaussian random deviate (zero mean, unit var)
 *  using transformed rejection with decomposition by Wolfgang Hormann.
 *
 *  Hormann, Wolfgang and Derflinger, Gerhard. "The Tranformed Rejection Method
 *  for Generating Random Variables, an Alternative to the Ration of Uniforms
 *  Method." Communications in Statistics: Simulation and Computation 23, 3, 1994.
 *
 *  @return The random deviate.
 *
 */
//------------------------------------------------------------------------------
Real RandomNumber::Gaussian()
{
   const Real ur = 0.4359971734;
   const Real vr = 0.9296123611;
   const Real a = 0.062794;
   const Real b = 2.530885;
   const Real alpha = 0.8904302215;
   const Real alpha_sq2pi_inv = alpha/GmatMathUtil::Sqrt(GmatMathConstants::TWO_PI);

   bool flag;

   do
   {
	   flag = false;
	   Real V = UniformOpenOpen();
    
	   if( V <= 2*ur*vr )
	   {
	      return G(V/vr-ur,a,b);
	   }
	   else
	   {
	      Real U;  
	 
	      if ( V >= vr )
	      {	
		      U = UniformOpenOpen(-0.5,0.5);
	      }
	      else
	      {
		      U = V/vr - (ur + 0.5);
		      U = 0.5*GmatMathUtil::SignOf(U)-U;
		      V = UniformOpenOpen(0.0,vr);
	      }
	      
	      Real gu = G(U,a,b);
	      
	      if (((V*GmatMathUtil::Exp(0.5*gu*gu)) - b*alpha_sq2pi_inv)*
		       (0.25-GmatMathUtil::Abs(U)+U*U) <= a*alpha_sq2pi_inv)
	      {
		      return gu;
	      }
	      else
	      {	
	         flag = true;
	      }
	    }
    } 
    while (flag);
    
    return 0;
}

//------------------------------------------------------------------------------
//  Real G(const Real x, const Real a, const Real b)
//------------------------------------------------------------------------------
/**
 *  Inline function that is required for the transformed rejection with
 *  decomposition method.
 *
 *  @param <x>  The independent parameter of the function
 *  @param <a>  Optimized parameter specific to distribution
 *  @param <b>  Optimized parameter specific to distribution
 *  @return G(x)
 *
 */
//------------------------------------------------------------------------------
inline Real RandomNumber::G(Real x, Real a, Real b)
{
    return (2.0*a/(0.5-GmatMathUtil::Abs(x))+b)*x;
}

//------------------------------------------------------------------------------
//  Real Gaussian(const Real mean, const Real stdev)
//------------------------------------------------------------------------------
/**
 *  Returns a normally distributed Gaussian random deviate (zero mean, unit var)
 *  using the transformed rejection method.
 *
 *  @param <mean> Mean of Gaussian distribution
 *  @param <stdev> Standard deviation of Gaussian distribution
 *  @return The random deviate.
 *
 */
//------------------------------------------------------------------------------
Real RandomNumber::Gaussian(const Real mean, const Real stdev)
{
    return Gaussian() * stdev + mean;
}

////------------------------------------------------------------------------------
////  void UniformArray(unsigned int *myArray, const Integer size)
////------------------------------------------------------------------------------
///**
// *  Returns an array of uniformly distributed unsigned 32bit integers.
// *  This method is significantly slower than the double precision methods
// *  and should only be used in conjunction with the SeedByArray method.
// *
// *  @param <myArray> Pointer to array where random deviates will be stored
// *  @param <size> size of the array of deviates
// *
// */
////------------------------------------------------------------------------------
//void RandomNumber::UniformArray(unsigned int *myArray, const Integer size)
//{
//    for (Integer i = 0; i < size; i++)
//	   myArray[i] = UniformInt();
//}

//------------------------------------------------------------------------------
//  void UniformArray(Real *myArray, const Integer size)
//------------------------------------------------------------------------------
/**
 *  Returns a uniformly distributed random deviate in the range [0,1)
 *  The range includes 0.0 but excludes 1.0;
 *
 *  @param <myArray> Pointer to array where random deviates will be stored
 *  @param <size> size of the array of deviates
 *
 */
//------------------------------------------------------------------------------
void RandomNumber::UniformArray(Real* myArray, const Integer size)
{
   for (Integer i = 0; i < size; ++i)
      myArray[i] = Uniform(); 
}

//------------------------------------------------------------------------------
//  void UniformPrimitiveArray(Real *myArray, const Integer size)
//------------------------------------------------------------------------------
/**
 *  Returns an uniformly distributed random deviate in the range [1,2).
 *  The range includes 1.0 but excludes 2.0. This is the primitive MT generator
 *  that all other function calls are based upon. This is the fastest method
 *  for generating a random variate.
 *
 *  @param <myArray> Pointer to array where random deviates will be stored
 *  @param <size> size of the array of deviates
 *
 */
//------------------------------------------------------------------------------
void RandomNumber::UniformPrimitiveArray(Real *myArray, const Integer size)
{
   for (Integer i = 0; i < size; ++i)
      myArray[i] = UniformPrimitive(); 
}

//------------------------------------------------------------------------------
//  void UniformOpenOpenArray(Real *myArray, const Integer size)
//------------------------------------------------------------------------------
/**
 *  Returns an uniformly distributed random deviate in the range (0,1)
 *  The range excludes both 0.0 and 1.0. This is useful when you need to
 *  avoid a singularity at 0 or 1.
 *
 *  @param <myArray> Pointer to array where random deviates will be stored
 *  @param <size> size of the array of deviates
 *
 */
//------------------------------------------------------------------------------
void RandomNumber::UniformOpenOpenArray(Real *myArray, const Integer size)
{
   for (Integer i = 0; i < size; ++i)
      myArray[i] = UniformOpenOpen(); 
}

//------------------------------------------------------------------------------
//  void UniformOpenClosedArray(Real *myArray, const Integer size)
//------------------------------------------------------------------------------
/**
 *  Returns an uniformly distributed random deviate in the range (0,1]
 *  The range excludes 0.0 but includes 1.0. This is useful when you need to
 *  avoid a singularity at 0.
 *
 *  @param <myArray> Pointer to array where random deviates will be stored
 *  @param <size> size of the array of deviates
 *
 */
//------------------------------------------------------------------------------
void RandomNumber::UniformOpenClosedArray(Real *myArray, const Integer size)
{
   for (Integer i = 0; i < size; ++i)
      myArray[i] = UniformOpenClosed(); 
}

//------------------------------------------------------------------------------
//  void UniformArray(Real *myArray, Real a, Real b, const Integer size)
//------------------------------------------------------------------------------
/**
 *  Returns an uniformly distributed random deviate in the range [a,b)
 *  The mean of this distribution is (a+b)/2.
 *  The variance of this distribution is (b-a)^2/12.
 *
 *  @param <myArray> Pointer to array where random deviates will be stored
 *  @param <size> size of the array of deviates
 *  @param <a> Distribution start
 *  @param <b> Distribution end
 *
 */
//------------------------------------------------------------------------------
void RandomNumber::UniformArray(Real *myArray, const Integer size, 
	                         const Real a, const Real b)
{
	UniformArray(myArray, size);
    for (Integer i=0; i < size; i++)
       myArray[i] = a + (b - a)*myArray[i];
}

//------------------------------------------------------------------------------
//  void UniformOpenOpenArray(Real *myArray, const Integer size, Real a, Real b)
//------------------------------------------------------------------------------
/**
 *  Returns an uniformly distributed random deviate in the range (a,b)
 *  The mean of this distribution is (a+b)/2.
 *  The variance of this distribution is (b-a)^2/12.
 *
 *  @param <myArray> Pointer to array where random deviates will be stored
 *  @param <size> size of the array of deviates
 *  @param <a> Distribution start
 *  @param <b> Distribution end
 *
 */
//------------------------------------------------------------------------------
void RandomNumber::UniformOpenOpenArray(Real *myArray, const Integer size, 
	                         const Real a, const Real b)
{
   UniformOpenOpenArray(myArray, size);
   for (Integer i=0; i < size; i++)
      myArray[i] = a + (b - a)*myArray[i];
}

//------------------------------------------------------------------------------
// void UniformOpenClosedArray(Real *myArray, const Integer size, 
//			       Real a, Real b)
//------------------------------------------------------------------------------
/**
 *  Returns an uniformly distributed random deviate in the range (a,b]
 *  The mean of this distribution is (a+b)/2.
 *  The variance of this distribution is (b-a)^2/12.
 *
 *  @param <myArray> Pointer to array where random deviates will be stored
 *  @param <size> size of the array of deviates
 *  @param <a> Distribution start
 *  @param <b> Distribution end
 *
 */
//------------------------------------------------------------------------------
void RandomNumber::UniformOpenClosedArray(Real *myArray, const Integer size, 
				          const Real a, const Real b)
{
   UniformOpenClosedArray(myArray, size);
   for (Integer i=0; i < size; i++)
      myArray[i] = a + (b - a)*myArray[i];
}

//------------------------------------------------------------------------------
//  void GaussianArray(Real *myArray, const Integer size)
//------------------------------------------------------------------------------
/**
 *  Returns a normally distributed Gaussian random deviate (zero mean, unit var)
 *
 *  @param <myArray> Pointer to array where random deviates will be stored
 *  @param <size> size of the array of deviates
 *
 */
//------------------------------------------------------------------------------
void RandomNumber::GaussianArray(Real *myArray, const Integer size)
{
     for (Integer i=0; i < size; i++)
     {
         myArray[i] = Gaussian();
     }
}

//------------------------------------------------------------------------------
//  void GaussianArray(Real *myArray, const Integer size,
//	                         const Real mean, const Real stdev)
//------------------------------------------------------------------------------
/**
 *  Returns an array of normally distributed Gaussian random deviates 
 *  with specified mean and variance.
 *
 *  @param <myArray> Pointer to array where random deviates will be stored
 *  @param <size> size of the array of deviates
 *  @param <mean> Mean of Gaussian distribution
 *  @param <stdev> Standard deviation of Gaussian distribution
 *
 */
//------------------------------------------------------------------------------
void RandomNumber::GaussianArray(Real *myArray, const Integer size,
	                         const Real mean, const Real stdev)
{
     for (Integer i=0; i < size; i++)
     {
         myArray[i] = Gaussian() * stdev + mean;
     }
}


union RealNumberType64
{
	double       realNum;
	unsigned int intNum[2];
	unsigned char ch[8];
};
union RealNumberType128
{
	double       realNum;
	unsigned int intNum[4];
	unsigned char ch[16];
};

Real RandomNumber::rrand()
{
   return white(generator);
}


//Real RandomNumber::rrand1()
//{
//#ifdef DEBUG_CALCULATION
////	MessageInterface::ShowMessage("Run rrand() fucntion\n");
//#endif
//
//   // Check machine is using Big indian or Little indian:
//   bool isBigIndian = true;
//   union 
//   {
//	   int intNum;
//	   char  ch[4];
//   } num;
//
//   num.intNum = 1;
//   if (num.ch[0] == '\1')
//      isBigIndian = false;
//
//   // Create a real random number
//   bool found;
//   Real ret_Val;
//   do
//   {
//      if (sizeof(Real) == 8)
//      {
//         RealNumberType64 val;
//
//         for (int i = 0; i < 8; ++i)
//         {
//            Integer k = rand();
//            //         this->Seed(k);
//            //         k = rand();
////            MessageInterface::ShowMessage("k = %d   ", k);
//            val.ch[i] = k; //  rand();
//         }
//
//         if (isBigIndian)
//         {
//            // Set first 12 bits to 0 
//            val.ch[0] = '\0';
//            val.ch[1] = val.ch[1] & 15;
//         }
//         else
//         {
//            //Set first 12 bits to 0
//            val.ch[0] = 0x3F;
//            val.ch[1] = val.ch[1] | 0xF0;
//
//            // Swap to the order of Little indian
//            unsigned char temp;
//            for (int i = 0; i < 4; ++i)
//            {
//               temp = val.ch[i];
//               val.ch[i] = val.ch[7 - i];
//               val.ch[7 - i] = temp;
//            }
//         }
//         //	   MessageInterface::ShowMessage("val.intNum[0] = %8x val.intNum[1] = %8x\n", val.intNum[0], val.intNum[1]);
//         //	   MessageInterface::ShowMessage("%2x  %2x  %2x  %2x  %2x  %2x  %2x  %2x\n", val.ch[0], val.ch[1], val.ch[2], val.ch[3], val.ch[4], val.ch[5], val.ch[6], val.ch[7]);
//         //	   MessageInterface::ShowMessage("val.realNum = %le\n", val.realNum);
//         ret_Val = val.realNum;
//
//      }
//      else if (sizeof(Real) == 16)
//      {
//         RealNumberType128 val;
//
//         for (int i = 0; i < 16; ++i)
//            val.ch[i] = rand();
//         if (isBigIndian)
//         {
//            // Set first 16 bits to 0 
//            val.ch[0] = 0x3F;
//            val.ch[1] = 0xFF;
//         }
//         else
//         {
//            // Set first 16 bits to 0
//            val.ch[0] = val.ch[1] = '\0';
//
//            // Swap to the order of Little indian
//            unsigned char temp;
//            for (int i = 0; i < 8; ++i)
//            {
//               temp = val.ch[i];
//               val.ch[i] = val.ch[15 - i];
//               val.ch[15 - i] = temp;
//            }
//
//         }
//         ret_Val = val.realNum;
//      }
//
//      ret_Val = ret_Val - 1.0;
//
//      found = false;
//      for (Integer i = 0; i < preValue.size(); ++i)
//      {
//         if (ret_Val == preValue[i])
//         {
//            found = true;
//            break;
//         }
//      }
//   } while (found);
//
//
//#ifdef DEBUG_CALCULATION
//      MessageInterface::ShowMessage(" Real random number = %lf\n", ret_Val);
//#endif
//   if (currentIndex < preValue.size())
//      preValue[currentIndex] = ret_Val;
//   else
//   {
//      if (preValue.size() < 1)    // 40)
//         preValue.push_back(ret_Val);
//      else
//      {
//         currentIndex = 0;
//         preValue[currentIndex] = ret_Val;
//      }
//   }
//   ++currentIndex;
//
//   return ret_Val;
//}
