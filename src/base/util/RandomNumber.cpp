//$Id$
//------------------------------------------------------------------------------
//                              RandomNumber
//------------------------------------------------------------------------------
// GMAT: General Mission Analysis Tool
//
// **Legal**
//
// Developed by Dr. Matthew P. Wilkins, Schafer Corporation
//
// Author: Matthew P. Wilkins
// Created: 2008/09/08
//
/**
 * GMAT's Random Number Class
 *
 * This class implements the double precision SIMD oriented Fast 
 * Mersenne Twister pseudorandom number generator (dSFMT) version 2.1. 
 *
 * SFMT is a new variant of Mersenne Twister (MT) introduced by Mutsuo Saito and 
 * Makoto Matsumoto in 2006. The algorithm was reported at MCQMC 2006 
 * (http://mcqmc.uni-ulm.de/). The article was published in the proceedings of 
 * MCQMC2006. (see Prof. Matsumoto's Papers on random number generation.)
 *
 * SFMT is a Linear Feedbacked Shift Register (LFSR) generator that generates 
 * a 128-bit pseudorandom integer at one step. SFMT is designed with recent 
 * parallelism of modern CPUs, such as multi-stage pipelining and SIMD 
 * (e.g. 128-bit integer) instructions. It supports 32-bit and 64-bit integers, 
 * as well as double precision floating point as output.
 * 
 * SFMT is much faster than MT, in most platforms. Not only the speed, but also 
 * the dimensions of equidistributions at v-bit precision are improved. 
 * In addition, recovery from 0-excess initial state is much faster. See 
 * Master's Thesis of Mutsuo Saito for detail.
 *
 * This program is based on the IEEE Standard for Binary Floating-Point 
 * Arithmetic (ANSI/IEEE Std 754-1985) format. dSFMT ver. 2.xx is completely 
 * different from dSFMT ver. 1.xx. The recursion formula is changed and the 
 * output sequences are changed. This version uses structure of C language. 
 * Don't use different DSFMT_MEXP for compiling dSFMT.c and your program. 
 * This Project provides pseudorandom number generators of various 
 * Mersenne Prime Period: from 2521-1 to 2216091-1.
 *
 * The purpose of dSFMT is to speed up the generation by avoiding the expensive 
 * conversion of integer to double (floating point). dSFMT directly generates 
 * double precision floating point pseudorandom numbers which have the IEEE 
 * Standard for Binary Floating-Point Arithmetic (ANSI/IEEE Std 754-1985) format. 
 * dSFMT is only available on the CPUs which use IEEE 754 format double precision 
 * floating point numbers.
 * 
 * dSFMT doesn't support integer outputs. dSFMT supports the output of double 
 * precision floating point pseudorandom numbers which distribute in the range 
 * of [1, 2), [0, 1), (0, 1] and (0, 1). And it also supports the various 
 * periods form 2607-1 to 2132049-1. (dSFMT ver. 2.1 supports the periods 
 * from 2521-1 to 2216091-1.)
 *
 * To compute a normally distributed Gaussian random deviate (zero mean, 
 * unit var) Hormann and Derflinger's transformed rejection with decomposition
 * is utilized. "Theoretical considerations and empirical results show that the 
 * one-dimensional quality of non-uniform random numbers is bad and the 
 * discrepancy is high when they are generated by the ratio of uniforms method 
 * combined with linear congruential generators. This observation motivates the 
 * suggestion to replace the ratio of uniforms method by transformed rejection 
 * (also called exact approximation or almost exact inversion), as the above 
 * problem does not occur for this method. Using the function 
 * $G(x) =\left( \frac{a}{1-x}+b\right)x $ with appropriate $a$ and $b$ as 
 * approximation of the inverse distribution function the transformed rejection 
 * method can be used for the same distributions as the ratio of uniforms 
 * method. The resulting algorithms for the normal, the exponential and the 
 * t-distribution are short and easy to implement. Looking at the number of 
 * uniform deviates required, at the code length and at the speed the suggested 
 * algorithms are superior to the ratio of uniforms method and compare well 
 * with other algorithms suggested in literature."
 * 
 * References
 *
 * Mutsuo Saito and Makoto Matsumoto, "SIMD-oriented Fast Mersenne Twister: a 
 * 128-bit Pseudorandom Number Generator", Monte Carlo and Quasi-Monte Carlo 
 * Methods 2006, Springer, 2008, pp. 607--622. DOI:10.1007/978-3-540-74496-2_36
 *
 * http://www.math.sci.hiroshima-u.ac.jp/~m-mat/MT/ARTICLES/sfmt.pdf
 * 
 * M. Matsumoto and T. Nishimura, "Mersenne Twister: A 623-dimensionally 
 * equidistributed uniform pseudorandom number generator", ACM Trans. on 
 * Modeling and Computer Simulation Vol. 8, No. 1, January pp.3-30 (1998) 
 * DOI:10.1145/272991.272995
 * 
 * http://www.math.sci.hiroshima-u.ac.jp/~m-mat/MT/ARTICLES/mt.pdf
 *
 * Hormann, Wolfgang and Derflinger, Gerhard. "The Tranformed Rejection Method
 * for Generating Random Variables, an Alternative to the Ration of Uniforms
 * Method." Communications in Statistics: Simulation and Computation 23, 3, 1994
 *
 * http://statmath.wu-wien.ac.at/papers/94-01-18.wh-der.ps.gz
 *
 */
//------------------------------------------------------------------------------

#include "RandomNumber.hpp"
#include "MessageInterface.hpp"
#include <time.h>
#include <stdlib.h>           // for srand, etc.


//#define DEBUG_CONSTRUCTOR
//#define DEBUG_CALCULATION


RandomNumber* RandomNumber::theInstance = NULL;

RandomNumber* RandomNumber::Instance()
{
   if (theInstance == NULL)
      theInstance = new RandomNumber;
   return theInstance;
}
//------------------------------------------------------------------------------
// RandomNumber()
//------------------------------------------------------------------------------
/**
 * Class constructor that seeds the generator using the clock.
 *
 */
//------------------------------------------------------------------------------
RandomNumber::RandomNumber()
{
#ifdef DEBUG_CONSTRUCTOR
	MessageInterface::ShowMessage("RandomNumber  default constructor\n");
#endif

    //unsigned int clockSeed = time(NULL);
    //srand(clockSeed);
    //currentIndex = 0;

    std::random_device rd;
    generator.seed(rd());

    std::uniform_real_distribution<>::param_type whiteParams(0.0, 1.0);
    white.param(whiteParams);
}


//------------------------------------------------------------------------------
// ~RandomNumber()
//------------------------------------------------------------------------------
/**
 * Class destructor.
 *
 */
//------------------------------------------------------------------------------
RandomNumber::~RandomNumber()
{
}


//------------------------------------------------------------------------------
//  void Seed(unsigned int s)
//------------------------------------------------------------------------------
/**
 *  Set the seed for the random number generator using a specified value.
 *
 *  @param <idum2> input seed
 */
//------------------------------------------------------------------------------
void RandomNumber::Seed(unsigned int s)
{
    //srand(s);
   generator.seed(s);
}


//------------------------------------------------------------------------------
//  void ClockSeed()
//------------------------------------------------------------------------------
/**
 * Set the seed value based upon the current clock time.
 */
//------------------------------------------------------------------------------
void RandomNumber::ClockSeed()
{
   unsigned int clockSeed = time(NULL);
   //srand(clockSeed);
   generator.seed(clockSeed);
}


Real RandomNumber::rrand()
{
   return white(generator);
}


//------------------------------------------------------------------------------
//  Real Gaussian()
//------------------------------------------------------------------------------
/**
*  Returns a normally distributed Gaussian random deviate (zero mean, unit var)
*
*/
//------------------------------------------------------------------------------
Real RandomNumber::Gaussian()
{
   std::normal_distribution<double> Gauss(0.0, 1.0);
   return Gauss(generator);
}


//------------------------------------------------------------------------------
//  Real Gaussian(const Real mean, const Real stdev)
//------------------------------------------------------------------------------
/**
*  Returns a normally distributed Gaussian random deviate.
*
*  @param <mean> Mean of Gaussian distribution
*  @param <stdev> Standard deviation of Gaussian distribution
*  @return The random deviate.
*
*/
//------------------------------------------------------------------------------
Real RandomNumber::Gaussian(const Real mean, const Real stdev)
{
   std::normal_distribution<double> Gauss(mean, stdev);
   return Gauss(generator);
}


//------------------------------------------------------------------------------
//  void GaussianArray(Real *myArray, const Integer size)
//------------------------------------------------------------------------------
/**
*  Returns a normally distributed Gaussian random deviate (zero mean, unit var)
*
*  @param <myArray> Pointer to array where random deviates will be stored
*  @param <size> size of the array of deviates
*
*/
//------------------------------------------------------------------------------
void RandomNumber::GaussianArray(Real *myArray, const Integer size)
{
   for (Integer i = 0; i < size; i++)
   {
      myArray[i] = Gaussian();
   }
}

//------------------------------------------------------------------------------
//  void GaussianArray(Real *myArray, const Integer size,
//	                         const Real mean, const Real stdev)
//------------------------------------------------------------------------------
/**
*  Returns an array of normally distributed Gaussian random deviates
*  with specified mean and variance.
*
*  @param <myArray> Pointer to array where random deviates will be stored
*  @param <size> size of the array of deviates
*  @param <mean> Mean of Gaussian distribution
*  @param <stdev> Standard deviation of Gaussian distribution
*
*/
//------------------------------------------------------------------------------
void RandomNumber::GaussianArray(Real *myArray, const Integer size,
   const Real mean, const Real stdev)
{
   for (Integer i = 0; i < size; i++)
   {
      myArray[i] = Gaussian(mean, stdev);
   }
}


//------------------------------------------------------------------------------
//  Real Uniform()
//------------------------------------------------------------------------------
/**
*  Returns an uniformly distributed random deviate in the range [0,1)
*  The range includes 0.0 but excludes 1.0;
*
*  @return The random deviate.
*
*/
//------------------------------------------------------------------------------
Real RandomNumber::Uniform()
{
   Real rn;
   do
   {
      rn = rrand();
   } while (rn == 1.0);

   return rn;
}


//------------------------------------------------------------------------------
//  Real Uniform(Real a, Real b)
//------------------------------------------------------------------------------
/**
*  Returns an uniformly distributed random deviate in the range [a,b)
*  The mean of this distribution is (a+b)/2.
*  The variance of this distribution is (b-a)^2/12.
*
*  @param <a> Distribution start
*  @param <b> Distribution end
*  @return The random deviate.
*
*/
//------------------------------------------------------------------------------
Real RandomNumber::Uniform(const Real a, const Real b)
{
   return a + (b - a)*Uniform();
}


//------------------------------------------------------------------------------
//  void UniformArray(Real *myArray, const Integer size)
//------------------------------------------------------------------------------
/**
*  Returns a uniformly distributed random deviate in the range [0,1)
*  The range includes 0.0 but excludes 1.0;
*
*  @param <myArray> Pointer to array where random deviates will be stored
*  @param <size> size of the array of deviates
*
*/
//------------------------------------------------------------------------------
void RandomNumber::UniformArray(Real* myArray, const Integer size)
{
   for (Integer i = 0; i < size; ++i)
      myArray[i] = Uniform();
}


//------------------------------------------------------------------------------
//  void UniformArray(Real *myArray, Real a, Real b, const Integer size)
//------------------------------------------------------------------------------
/**
*  Returns an uniformly distributed random deviate in the range [a,b)
*  The mean of this distribution is (a+b)/2.
*  The variance of this distribution is (b-a)^2/12.
*
*  @param <myArray> Pointer to array where random deviates will be stored
*  @param <size> size of the array of deviates
*  @param <a> Distribution start
*  @param <b> Distribution end
*
*/
//------------------------------------------------------------------------------
void RandomNumber::UniformArray(Real *myArray, const Integer size,
   const Real a, const Real b)
{
   UniformArray(myArray, size);
   for (Integer i = 0; i < size; i++)
      myArray[i] = a + (b - a)*myArray[i];
}


////------------------------------------------------------------------------------
////  unsigned int UniformInt()
////------------------------------------------------------------------------------
///**
// *  Returns an unsigned 32-bit integer. This should only be used to seed.
// *
// *  @return The random deviate.
// *
// */
////------------------------------------------------------------------------------
//unsigned int RandomNumber::UniformInt()
//{
//     return rand();
//}


//------------------------------------------------------------------------------
//  Real UniformPrimitive()
//------------------------------------------------------------------------------
/**
 *  Returns an uniformly distributed random deviate in the range [1,2).
 *  The range includes 1.0 but excludes 2.0. This is the primitive MT generator
 *  that all other function calls are based upon. This is the fastest method
 *  for generating a random variate.
 *
 *  @return The random deviate.
 *
 */
//------------------------------------------------------------------------------
//Real RandomNumber::UniformPrimitive()
//{
//     return (Uniform() + 1.0);
//}

//------------------------------------------------------------------------------
//  Real UniformOpenOpen()
//------------------------------------------------------------------------------
/**
 *  Returns an uniformly distributed random deviate in the range (0,1)
 *  The range excludes both 0.0 and 1.0. This is useful when you need to
 *  avoid a singularity at 0 or 1.
 *
 *  @return The random deviate.
 *
 */
//------------------------------------------------------------------------------
//Real RandomNumber::UniformOpenOpen()
//{
//   Real rn;
//   rn = rrand();
//   while ((rn == 1.0)||(rn == 0.0))
//      rn = rrand();
//
//   return rn;
//}

 //------------------------------------------------------------------------------
//  Real UniformOpenClosed()
//------------------------------------------------------------------------------
/**
 *  Returns an uniformly distributed random deviate in the range (0,1]
 *  The range excludes 0.0 but includes 1.0. This is useful when you need to
 *  avoid a singularity at 0.
 *
 *  @return The random deviate.
 *
 */
//------------------------------------------------------------------------------
//Real RandomNumber::UniformOpenClosed()
//{
//   Real rn;
//   rn = rrand();
//   while (rn == 0.0)
//	  rn = rrand();
//
//   return rn;
//}


//------------------------------------------------------------------------------
//  Real UniformOpenOpen(Real a, Real b)
//------------------------------------------------------------------------------
/**
 *  Returns an uniformly distributed random deviate in the range (a,b)
 *  The mean of this distribution is (a+b)/2.
 *  The variance of this distribution is (b-a)^2/12.
 *
 *  @param <a> Distribution start
 *  @param <b> Distribution end
 *  @return The random deviate.
 *
 */
//------------------------------------------------------------------------------
//Real RandomNumber::UniformOpenOpen(const Real a, const Real b)
//{
//   return a + (b - a)*UniformOpenOpen();
//}

//------------------------------------------------------------------------------
//  Real UniformOpenClosed(Real a, Real b)
//------------------------------------------------------------------------------
/**
 *  Returns an uniformly distributed random deviate in the range (a,b]
 *  The mean of this distribution is (a+b)/2.
 *  The variance of this distribution is (b-a)^2/12.
 *
 *  @param <a> Distribution start
 *  @param <b> Distribution end
 *  @return The random deviate.
 *
 */
//------------------------------------------------------------------------------
//Real RandomNumber::UniformOpenClosed(const Real a, const Real b)
//{
//   return a + (b - a)*UniformOpenClosed();
//}


////------------------------------------------------------------------------------
////  Real G(const Real x, const Real a, const Real b)
////------------------------------------------------------------------------------
///**
// *  Inline function that is required for the transformed rejection with
// *  decomposition method.
// *
// *  @param <x>  The independent parameter of the function
// *  @param <a>  Optimized parameter specific to distribution
// *  @param <b>  Optimized parameter specific to distribution
// *  @return G(x)
// *
// */
////------------------------------------------------------------------------------
//inline Real RandomNumber::G(Real x, Real a, Real b)
//{
//    return (2.0*a/(0.5-GmatMathUtil::Abs(x))+b)*x;
//}


////------------------------------------------------------------------------------
////  void UniformArray(unsigned int *myArray, const Integer size)
////------------------------------------------------------------------------------
///**
// *  Returns an array of uniformly distributed unsigned 32bit integers.
// *  This method is significantly slower than the double precision methods
// *  and should only be used in conjunction with the SeedByArray method.
// *
// *  @param <myArray> Pointer to array where random deviates will be stored
// *  @param <size> size of the array of deviates
// *
// */
////------------------------------------------------------------------------------
//void RandomNumber::UniformArray(unsigned int *myArray, const Integer size)
//{
//    for (Integer i = 0; i < size; i++)
//	   myArray[i] = UniformInt();
//}


//------------------------------------------------------------------------------
//  void UniformPrimitiveArray(Real *myArray, const Integer size)
//------------------------------------------------------------------------------
/**
 *  Returns an uniformly distributed random deviate in the range [1,2).
 *  The range includes 1.0 but excludes 2.0. This is the primitive MT generator
 *  that all other function calls are based upon. This is the fastest method
 *  for generating a random variate.
 *
 *  @param <myArray> Pointer to array where random deviates will be stored
 *  @param <size> size of the array of deviates
 *
 */
//------------------------------------------------------------------------------
//void RandomNumber::UniformPrimitiveArray(Real *myArray, const Integer size)
//{
//   for (Integer i = 0; i < size; ++i)
//      myArray[i] = UniformPrimitive(); 
//}

//------------------------------------------------------------------------------
//  void UniformOpenOpenArray(Real *myArray, const Integer size)
//------------------------------------------------------------------------------
/**
 *  Returns an uniformly distributed random deviate in the range (0,1)
 *  The range excludes both 0.0 and 1.0. This is useful when you need to
 *  avoid a singularity at 0 or 1.
 *
 *  @param <myArray> Pointer to array where random deviates will be stored
 *  @param <size> size of the array of deviates
 *
 */
//------------------------------------------------------------------------------
//void RandomNumber::UniformOpenOpenArray(Real *myArray, const Integer size)
//{
//   for (Integer i = 0; i < size; ++i)
//      myArray[i] = UniformOpenOpen(); 
//}

//------------------------------------------------------------------------------
//  void UniformOpenClosedArray(Real *myArray, const Integer size)
//------------------------------------------------------------------------------
/**
 *  Returns an uniformly distributed random deviate in the range (0,1]
 *  The range excludes 0.0 but includes 1.0. This is useful when you need to
 *  avoid a singularity at 0.
 *
 *  @param <myArray> Pointer to array where random deviates will be stored
 *  @param <size> size of the array of deviates
 *
 */
//------------------------------------------------------------------------------
//void RandomNumber::UniformOpenClosedArray(Real *myArray, const Integer size)
//{
//   for (Integer i = 0; i < size; ++i)
//      myArray[i] = UniformOpenClosed(); 
//}


//------------------------------------------------------------------------------
//  void UniformOpenOpenArray(Real *myArray, const Integer size, Real a, Real b)
//------------------------------------------------------------------------------
/**
 *  Returns an uniformly distributed random deviate in the range (a,b)
 *  The mean of this distribution is (a+b)/2.
 *  The variance of this distribution is (b-a)^2/12.
 *
 *  @param <myArray> Pointer to array where random deviates will be stored
 *  @param <size> size of the array of deviates
 *  @param <a> Distribution start
 *  @param <b> Distribution end
 *
 */
//------------------------------------------------------------------------------
//void RandomNumber::UniformOpenOpenArray(Real *myArray, const Integer size, 
//	                         const Real a, const Real b)
//{
//   UniformOpenOpenArray(myArray, size);
//   for (Integer i=0; i < size; i++)
//      myArray[i] = a + (b - a)*myArray[i];
//}

//------------------------------------------------------------------------------
// void UniformOpenClosedArray(Real *myArray, const Integer size, 
//			       Real a, Real b)
//------------------------------------------------------------------------------
/**
 *  Returns an uniformly distributed random deviate in the range (a,b]
 *  The mean of this distribution is (a+b)/2.
 *  The variance of this distribution is (b-a)^2/12.
 *
 *  @param <myArray> Pointer to array where random deviates will be stored
 *  @param <size> size of the array of deviates
 *  @param <a> Distribution start
 *  @param <b> Distribution end
 *
 */
//------------------------------------------------------------------------------
//void RandomNumber::UniformOpenClosedArray(Real *myArray, const Integer size, 
//				          const Real a, const Real b)
//{
//   UniformOpenClosedArray(myArray, size);
//   for (Integer i=0; i < size; i++)
//      myArray[i] = a + (b - a)*myArray[i];
//}

