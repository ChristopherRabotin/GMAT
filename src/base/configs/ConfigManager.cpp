//$Header$
//------------------------------------------------------------------------------
//                                  ClassName
//------------------------------------------------------------------------------
// GMAT: Goddard Mission Analysis Tool.
//
// Author: Darrel J. Conway
// Created: 2003/10/24
//
// Developed jointly by NASA/GSFC and Thinking Systems, Inc. under contract
// number S-67573-G
//
/**
 * Insert descriptive text here.
 *
 * @note Any notes here.
 */
//------------------------------------------------------------------------------




// Class automatically generated by Dev-C++ New Class wizard

#include "ConfigManager.hpp"
#include "ConfigManagerException.hpp"

ConfigManager* ConfigManager::theConfigManager = NULL;


ConfigManager* ConfigManager::Instance(void)
{
    if (!theConfigManager)
        theConfigManager = new ConfigManager;
        
    return theConfigManager;
}


// class constructor
ConfigManager::ConfigManager()
{
	// insert your code here
}

// class destructor
ConfigManager::~ConfigManager()
{
	// insert your code here
}


void ConfigManager::AddForceModel(ForceModel *fm)
{
    std::string name = fm->GetName();
    if (name == "")
        throw ConfigManagerException("Unnamed objects cannot be managed");
    if (mapping.find(name) != mapping.end()) {
        name += " is already in the configuration table";
        throw ConfigManagerException(name);
    }
    else {
        objects.push_back(fm);
        mapping[name] = fm;
    }
}


void ConfigManager::AddSubscriber(Subscriber *subs)
{
    throw ConfigManagerException("Subscribers cannot be managed yet");
//    std::string name = subs->GetName();
//    if (name == "")
//        throw ConfigManagerException("Unnamed objects cannot be managed");
//    if (mapping.find(name) != mapping.end()) {
//        name += " is already in the configuration table";
//        throw ConfigManagerException(name);
//    }
//    else {
//        objects.push_back(subs);
//        mapping[name] = subs;
//    }
}


void ConfigManager::AddSolarSystem(SolarSystem *solarSys)
{
    throw ConfigManagerException("SolarSystem objects not managed in build 1");
}


void ConfigManager::AddPropSetup(PropSetup* propSetup)
{
    std::string name = propSetup->GetName();
    if (name == "")
        throw ConfigManagerException("Unnamed objects cannot be managed");
    if (mapping.find(name) != mapping.end()) {
        name += " is already in the configuration table";
        throw ConfigManagerException(name);
    }
    else {
        objects.push_back(propSetup);
        mapping[name] = propSetup;
    }
}


void ConfigManager::AddSpacecraft(Spacecraft *sc)
{
    std::string name = sc->GetName();
    if (name == "")
        throw ConfigManagerException("Unnamed objects cannot be managed");
    if (mapping.find(name) != mapping.end()) {
        name += " is already in the configuration table";
        throw ConfigManagerException(name);
    }
    else {
        objects.push_back(sc);
        mapping[name] = sc;
    }
}


void ConfigManager::AddStopCondition(StopCondition* stopCond)
{
    std::string name = stopCond->GetName();
    if (name == "")
        throw ConfigManagerException("Unnamed objects cannot be managed");
    if (mapping.find(name) != mapping.end()) {
        name += " is already in the configuration table";
        throw ConfigManagerException(name);
    }
    else {
        objects.push_back(stopCond);
        mapping[name] = stopCond;
    }
}


bool ConfigManager::SetSolarSystemInUse(const std::string &name)
{
    return false;
}



StringArray ConfigManager::GetListOfItems(Gmat::ObjectType itemType) const
{
    StringArray strarr;
    return strarr;
}



bool ConfigManager::RemoveItem(Gmat::ObjectType type,
                               const std::string &name)
{
    return false;
}


ForceModel* ConfigManager::GetForceModel(const std::string &name)
{
    ForceModel *fm = NULL;
    if (mapping.find(name) != mapping.end()) {
        if (mapping[name]->GetType() != Gmat::FORCE_MODEL) {
            std::string str = mapping[name]->GetName() +
                              " is not a force model";
            throw ConfigManagerException(str);
        }
        fm = (ForceModel *)mapping[name];
    }
    return fm;
}


Spacecraft* ConfigManager::GetSpacecraft(const std::string &name)
{
    Spacecraft *sc = NULL;
    if (mapping.find(name) != mapping.end()) {
        if (mapping[name]->GetType() != Gmat::SPACECRAFT) {
            std::string str = mapping[name]->GetName() +
                              " is not a spacecraft";
            throw ConfigManagerException(str);
        }
        sc = (Spacecraft *)mapping[name];
    }
    return sc;
}


PropSetup* ConfigManager::GetPropSetup(const std::string &name)
{
    PropSetup *ps = NULL;
    if (mapping.find(name) != mapping.end()) {
        if (mapping[name]->GetType() != Gmat::PROP_SETUP) {
            std::string str = mapping[name]->GetName() +
                              " is not a spacecraft";
            throw ConfigManagerException(str);
        }
        ps = (PropSetup *)mapping[name];
    }
    return ps;
}


Subscriber* ConfigManager::GetSubscriber(const std::string &name)
{
    return NULL;
}


SolarSystem* ConfigManager::GetDefaultSolarSystem()
{
    return NULL;
}


SolarSystem* ConfigManager::GetSolarSystemInUse()
{
    return NULL;
}


StopCondition* ConfigManager::GetStopCondition(const std::string &name)
{
    StopCondition *sc = NULL;
    if (mapping.find(name) != mapping.end()) {
        if (mapping[name]->GetType() != Gmat::STOP_CONDITION) {
            std::string str = mapping[name]->GetName() +
                              " is not a spacecraft";
            throw ConfigManagerException(str);
        }
        sc = (StopCondition *)mapping[name];
    }
    return sc;
}


// Methods I'm not sure we need
void ConfigManager::AddCelestialBody(CelestialBody* body)
{
}


void ConfigManager::AddPhysicalModel(PhysicalModel *pm)
{
}


void ConfigManager::AddPropagator(Propagator *prop)
{
}


CelestialBody* ConfigManager::GetCelestialBody(const std::string &name)
{
    return NULL;
}


PhysicalModel* ConfigManager::GetPhysicalModel(const std::string &name)
{
    return NULL;
}


Propagator* ConfigManager::GetPropagator(const std::string &name)
{
    return NULL;
}


void ConfigManager::AddCommand(Command *cmd)
{
}


Command* ConfigManager::GetCommand(const std::string name)
{
    return NULL;
}


// Methods we'll need after build 1
// void ConfigManager::AddParameter(Parameter* parameter,
//                                  std::string &name);
// Parameter* ConfigManager::GetParameter(const std::string &name);


