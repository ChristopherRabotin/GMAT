//$Id$
//------------------------------------------------------------------------------
//                              RandomNumber
//------------------------------------------------------------------------------
// GMAT: General Mission Analysis Tool
//
// **Legal**
//
// Developed by Dr. Matthew P. Wilkins, Schafer Corporation
//
// Author: Matthew P. Wilkins
// Created: 2008/09/08
//
/**
 * GMAT's Random Number Class
 *
 * This class implements the double precision SIMD oriented Fast 
 * Mersenne Twister pseudorandom number generator (dSFMT) version 2.1. 
 *
 * SFMT is a new variant of Mersenne Twister (MT) introduced by Mutsuo Saito and 
 * Makoto Matsumoto in 2006. The algorithm was reported at MCQMC 2006 
 * (http://mcqmc.uni-ulm.de/). The article was published in the proceedings of 
 * MCQMC2006. (see Prof. Matsumoto's Papers on random number generation.)
 *
 * SFMT is a Linear Feedbacked Shift Register (LFSR) generator that generates 
 * a 128-bit pseudorandom integer at one step. SFMT is designed with recent 
 * parallelism of modern CPUs, such as multi-stage pipelining and SIMD 
 * (e.g. 128-bit integer) instructions. It supports 32-bit and 64-bit integers, 
 * as well as double precision floating point as output.
 * 
 * SFMT is much faster than MT, in most platforms. Not only the speed, but also 
 * the dimensions of equidistributions at v-bit precision are improved. 
 * In addition, recovery from 0-excess initial state is much faster. See 
 * Master's Thesis of Mutsuo Saito for detail.
 *
 * This program is based on the IEEE Standard for Binary Floating-Point 
 * Arithmetic (ANSI/IEEE Std 754-1985) format. dSFMT ver. 2.xx is completely 
 * different from dSFMT ver. 1.xx. The recursion formula is changed and the 
 * output sequences are changed. This version uses structure of C language. 
 * Don't use different DSFMT_MEXP for compiling dSFMT.c and your program. 
 * This Project provides pseudorandom number generators of various 
 * Mersenne Prime Period: from 2521-1 to 2216091-1.
 *
 * The purpose of dSFMT is to speed up the generation by avoiding the expensive 
 * conversion of integer to double (floating point). dSFMT directly generates 
 * double precision floating point pseudorandom numbers which have the IEEE 
 * Standard for Binary Floating-Point Arithmetic (ANSI/IEEE Std 754-1985) format. 
 * dSFMT is only available on the CPUs which use IEEE 754 format double precision 
 * floating point numbers.
 * 
 * dSFMT doesn't support integer outputs. dSFMT supports the output of double 
 * precision floating point pseudorandom numbers which distribute in the range 
 * of [1, 2), [0, 1), (0, 1] and (0, 1). And it also supports the various 
 * periods form 2607-1 to 2132049-1. (dSFMT ver. 2.1 supports the periods 
 * from 2521-1 to 2216091-1.)
 *
 * To compute a normally distributed Gaussian random deviate (zero mean, 
 * unit var) Hormann and Derflinger's transformed rejection with decomposition
 * is utilized. "Theoretical considerations and empirical results show that the 
 * one-dimensional quality of non-uniform random numbers is bad and the 
 * discrepancy is high when they are generated by the ratio of uniforms method 
 * combined with linear congruential generators. This observation motivates the 
 * suggestion to replace the ratio of uniforms method by transformed rejection 
 * (also called exact approximation or almost exact inversion), as the above 
 * problem does not occur for this method. Using the function 
 * $G(x) =\left( \frac{a}{1-x}+b\right)x $ with appropriate $a$ and $b$ as 
 * approximation of the inverse distribution function the transformed rejection 
 * method can be used for the same distributions as the ratio of uniforms 
 * method. The resulting algorithms for the normal, the exponential and the 
 * t-distribution are short and easy to implement. Looking at the number of 
 * uniform deviates required, at the code length and at the speed the suggested 
 * algorithms are superior to the ratio of uniforms method and compare well 
 * with other algorithms suggested in literature."
 * 
 * References
 *
 * Mutsuo Saito and Makoto Matsumoto, "SIMD-oriented Fast Mersenne Twister: a 
 * 128-bit Pseudorandom Number Generator", Monte Carlo and Quasi-Monte Carlo 
 * Methods 2006, Springer, 2008, pp. 607--622. DOI:10.1007/978-3-540-74496-2_36
 *
 * http://www.math.sci.hiroshima-u.ac.jp/~m-mat/MT/ARTICLES/sfmt.pdf
 * 
 * M. Matsumoto and T. Nishimura, "Mersenne Twister: A 623-dimensionally 
 * equidistributed uniform pseudorandom number generator", ACM Trans. on 
 * Modeling and Computer Simulation Vol. 8, No. 1, January pp.3-30 (1998) 
 * DOI:10.1145/272991.272995
 * 
 * http://www.math.sci.hiroshima-u.ac.jp/~m-mat/MT/ARTICLES/mt.pdf
 *
 * Hormann, Wolfgang and Derflinger, Gerhard. "The Tranformed Rejection Method
 * for Generating Random Variables, an Alternative to the Ration of Uniforms
 * Method." Communications in Statistics: Simulation and Computation 23, 3, 1994
 *
 * http://statmath.wu-wien.ac.at/papers/94-01-18.wh-der.ps.gz
 *
 */
//------------------------------------------------------------------------------

#ifndef _RandomNumber_hpp
#define _RandomNumber_hpp

// This is for the GSL libraries so that
// extern C will be used
//#define __cplusplus

//#include "estimation_defs.hpp"
#include "gmatdefs.hpp"
#include "RealUtilities.hpp"
#include "UtilityException.hpp"
#include <random>

class GMAT_API RandomNumber
//class ESTIMATION_API RandomNumber
{
public:
	static RandomNumber* Instance();
	~RandomNumber();

    Real Gaussian();
    Real Gaussian(const Real mean, const Real stdev);

    void GaussianArray(Real *myArray, const Integer size);
    void GaussianArray(Real *myArray, const Integer size,  
	               const Real mean, const Real stdev);
    
//    unsigned int UniformInt();
    Real Uniform();
    Real UniformPrimitive();
    Real UniformOpenOpen();
    Real UniformOpenClosed();
    Real Uniform(const Real a, const Real b);
    Real UniformOpenOpen(const Real a, const Real b);
    Real UniformOpenClosed(const Real a, const Real b);

//    void UniformArray(unsigned int *myArray, const Integer size);
    void UniformArray(Real *myArray, const Integer size);
    void UniformPrimitiveArray(Real *myArray, const Integer size);
    void UniformOpenOpenArray(Real *myArray, const Integer size);
    void UniformOpenClosedArray(Real *myArray, const Integer size);
    void UniformArray(Real *myArray, const Integer size, 
	              const Real a, const Real b);
    void UniformOpenOpenArray(Real *myArray, const Integer size, 
	              const Real a, const Real b);
    void UniformOpenClosedArray(Real *myArray, const Integer size, 
	              const Real a, const Real b);

    
    // Set and/or Re-set the seed for the random number generator
    void Seed(unsigned int s);
//    void SeedByArray(unsigned int *mySeed, Integer arraySize);
    void ClockSeed();

private:
	static RandomNumber *theInstance;

   RandomNumber();

	Real G(Real x, Real a, Real b);
	Real rrand();
//   RealArray    preValue;     // previous value of rrand()
//   Integer      currentIndex;


   // Providers used for local RNs
   /// The random number generator
   std::mt19937 generator;
   //std::default_random_engine generator;
   /// The white noise provider
   std::uniform_real_distribution<> white;

};

#endif	/* _RandomNumber_hpp */

