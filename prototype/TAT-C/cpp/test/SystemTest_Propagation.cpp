//------------------------------------------------------------------------------
//                               SystemTest_Propagate
//------------------------------------------------------------------------------
// GMAT: General Mission Analysis Tool
//
// Author: Wendy Shoan
// Created: 2016.05.31
//
/**
 * System tester for propagation
 */
//------------------------------------------------------------------------------

#include <iostream>
#include <string>
#include <ctime>
#include <cmath>
#include "gmatdefs.hpp"
#include "GmatConstants.hpp"
#include "Rvector6.hpp"
#include "Rvector3.hpp"
#include "Rmatrix.hpp"
#include "RealUtilities.hpp"
#include "MessageInterface.hpp"
#include "ConsoleMessageReceiver.hpp"
#include "AbsoluteDate.hpp"
#include "Spacecraft.hpp"
#include "Earth.hpp"
#include "KeyValueStatistics.hpp"
#include "VisiblePOIReport.hpp"
#include "OrbitState.hpp"
#include "PointGroup.hpp"
#include "Propagator.hpp"
#include "ConicalSensor.hpp"
#include "CoverageChecker.hpp"
#include "TimeTypes.hpp"


using namespace std;
using namespace GmatMathUtil;
using namespace GmatMathConstants;

//------------------------------------------------------------------------------
// int main(int argc, char *argv[])
//------------------------------------------------------------------------------
int main(int argc, char *argv[])
{
   std::string outFormat = "%16.9f ";
   Real        tolerance = 1e-15;
   
   ConsoleMessageReceiver *consoleMsg = ConsoleMessageReceiver::Instance();
   MessageInterface::SetMessageReceiver(consoleMsg);
   std::string outPath = "./";
   MessageInterface::SetLogFile(outPath + "GmatLog.txt");
   MessageInterface::ShowMessage("%s\n",
                                 GmatTimeUtil::FormatCurrentTime().c_str());
   
   // Set global format setting
   GmatGlobal *global = GmatGlobal::Instance();
   global->SetActualFormat(false, false, 16, 1, false);
   
   char *buffer = NULL;
   buffer = getenv("OS");
   if (buffer  != NULL)
   {
      MessageInterface::ShowMessage("Current OS is %s\n", buffer);
   }
   else
   {
      MessageInterface::ShowMessage("Buffer is NULL\n");
   }
   
   MessageInterface::ShowMessage("*** START TEST ***\n");
   
   AbsoluteDate *date   = NULL;
   OrbitState   *state  = NULL;
   Spacecraft   *sat1   = NULL;
   
   try
   {
      // Test the PointGroup
      MessageInterface::ShowMessage("*** TEST*** Propagate!!!!\n");
      
      clock_t t0 = clock();
      for (Integer ii = 0; ii < 20; ii++)
      {
         // Create the epoch object and set the initial epoch
         date = new AbsoluteDate();
         date->SetJulianDate(2457473.00);
         
         MessageInterface::ShowMessage("--- date created\n");
         
         // Create the spacecraft state object and set Keplerian elements
         state = new OrbitState();
         state->SetKeplerianState(6500.0,0.002,45.0*RAD_PER_DEG,
                                 75.0*RAD_PER_DEG,10.0*RAD_PER_DEG,270.0*RAD_PER_DEG);
         
         MessageInterface::ShowMessage("--- state created\n");
         
         // Create a spacecraft giving it a state and epoch
         sat1 = new Spacecraft(date,state);
         
         MessageInterface::ShowMessage("--- spacecraft created\n");
         
         // Create the propagator
         Propagator prop(sat1);
         
         MessageInterface::ShowMessage("--- propagator created\n");
         
         // Propagate for a duration and collect data
   //      Real    startDate = date.GetJulianDate();
   //      MessageInterface::ShowMessage("Before propagation, julian date = %12.10f\n",
   //                                    startDate);
   //      Integer count = 0;
         for (Integer stepIdx = 0; stepIdx < 86400/60; stepIdx++) // = 1:86400/60
         {
            // Propagate
            date->Advance(60.0);
   //         MessageInterface::ShowMessage("In iteration %d, julian date = %12.10f\n",
   //                                       stepIdx, date.GetJulianDate());
            prop.Propagate(*date);
         }
      }
      Real timeSpent = ((Real) (clock() - t0)) / CLOCKS_PER_SEC;
      MessageInterface::ShowMessage("TIME SPENT in 20 iterations is %12.10f seconds\n",
                                    timeSpent);
      
      // Comparison against truth below this line
      OrbitState   *orbState = sat1->GetOrbitState();
//      AbsoluteDate  orbEpoch = sat1.GetOrbitEpoch();
//      Real          jDate    = orbEpoch.GetJulianDate();
//      Rvector6      gregDate = orbEpoch.GetGregorianDate();
      Rvector6      kepState = orbState->GetKeplerianState();
      for (Integer ii = 2; ii < 6; ii++)
         kepState(ii) *= DEG_PER_RAD;
      
      //This is generated by this propagator but agrees very well with STK J2
      // analytic propagator
      Rvector6 truthData(6500.0,0.002, 45.0,
                    68.4059136572242, 16.9940847530552, 116.731954192478);
      
      bool errorInProp = false;
      for (Integer ii = 0; ii < 6; ii++)
      {
//         MessageInterface::ShowMessage("   kepState(%d)  = %12.10f\n",
//                                       ii, kepState(ii));
//         MessageInterface::ShowMessage("   truthData(%d) = %12.10f\n",
//                                       ii, truthData(ii));
         if (Abs(kepState(ii) - truthData(ii)) > 1.0e-11)
         {
            errorInProp = true;
            MessageInterface::ShowMessage("Error in J2 Analytic Propagation!\n");
         }
      }
      if (!errorInProp)
         MessageInterface::ShowMessage("OK - J2 propagation is OK!!!\n");
      
      cout << endl;
      cout << "Hit enter to end" << endl;
      cin.get();
      
      delete date;
      delete state;
      delete sat1;
      
      
      MessageInterface::ShowMessage("*** END TEST ***\n");
   }
   catch (BaseException &be)
   {
      MessageInterface::ShowMessage("Exception caught: %s\n", be.GetFullMessage().c_str());
   }
   
}
