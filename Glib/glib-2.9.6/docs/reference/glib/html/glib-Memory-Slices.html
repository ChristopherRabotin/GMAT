<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<title>Memory Slices</title>
<meta name="generator" content="DocBook XSL Stylesheets V1.69.1">
<link rel="start" href="index.html" title="GLib Reference Manual">
<link rel="up" href="glib-data-types.html" title="GLib Data Types">
<link rel="prev" href="glib-data-types.html" title="GLib Data Types">
<link rel="next" href="glib-Memory-Chunks.html" title="Memory Chunks">
<meta name="generator" content="GTK-Doc V1.4 (XML mode)">
<link rel="stylesheet" href="style.css" type="text/css">
<link rel="chapter" href="glib.html" title="GLib Overview">
<link rel="chapter" href="glib-fundamentals.html" title="GLib Fundamentals">
<link rel="chapter" href="glib-core.html" title="GLib Core Application Support">
<link rel="chapter" href="glib-utilities.html" title="GLib Utilities">
<link rel="chapter" href="glib-data-types.html" title="GLib Data Types">
<link rel="chapter" href="tools.html" title="GLib Tools">
<link rel="index" href="ix01.html" title="Index">
<link rel="index" href="ix02.html" title="Index of deprecated symbols">
<link rel="index" href="ix03.html" title="Index of new symbols in 2.2">
<link rel="index" href="ix04.html" title="Index of new symbols in 2.4">
<link rel="index" href="ix05.html" title="Index of new symbols in 2.6">
<link rel="index" href="ix06.html" title="Index of new symbols in 2.8">
<link rel="index" href="ix07.html" title="Index of new symbols in 2.10">
</head>
<body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF">
<table class="navigation" id="top" width="100%" summary="Navigation header" cellpadding="2" cellspacing="2">
<tr valign="middle">
<td><a accesskey="p" href="glib-data-types.html"><img src="left.png" width="24" height="24" border="0" alt="Prev"></a></td>
<td><a accesskey="u" href="glib-data-types.html"><img src="up.png" width="24" height="24" border="0" alt="Up"></a></td>
<td><a accesskey="h" href="index.html"><img src="home.png" width="24" height="24" border="0" alt="Home"></a></td>
<th width="100%" align="center">GLib Reference Manual</th>
<td><a accesskey="n" href="glib-Memory-Chunks.html"><img src="right.png" width="24" height="24" border="0" alt="Next"></a></td>
</tr>
<tr><td colspan="5" class="shortcuts"><nobr><a href="#top_of_page" class="shortcut">Top</a>
                  &#160;|&#160;
                  <a href="#desc" class="shortcut">Description</a></nobr></td></tr>
</table>
<div class="refentry" lang="en">
<a name="glib-Memory-Slices"></a><div class="titlepage"></div>
<div class="refnamediv"><table width="100%"><tr>
<td valign="top">
<h2><span class="refentrytitle"><a name="top_of_page"></a>Memory Slices</span></h2>
<p>Memory Slices &#8212; efficient way to allocate groups of equal-sized chunks of memory.</p>
</td>
<td valign="top" align="right"></td>
</tr></table></div>
<div class="refsynopsisdiv">
<a name="synopsis"></a><h2>Synopsis</h2>
<pre class="synopsis">

#include &lt;glib.h&gt;


<a href="glib-Basic-Types.html#gpointer">gpointer</a>    <a href="glib-Memory-Slices.html#g-slice-alloc">g_slice_alloc</a>                   (<a href="glib-Basic-Types.html#gsize">gsize</a> block_size);
<a href="glib-Basic-Types.html#gpointer">gpointer</a>    <a href="glib-Memory-Slices.html#g-slice-alloc0">g_slice_alloc0</a>                  (<a href="glib-Basic-Types.html#gsize">gsize</a> block_size);
void        <a href="glib-Memory-Slices.html#g-slice-free1">g_slice_free1</a>                   (<a href="glib-Basic-Types.html#gsize">gsize</a> block_size,
                                             <a href="glib-Basic-Types.html#gpointer">gpointer</a> mem_block);
void        <a href="glib-Memory-Slices.html#g-slice-free-chain-with-offset">g_slice_free_chain_with_offset</a>  (<a href="glib-Basic-Types.html#gsize">gsize</a> block_size,
                                             <a href="glib-Basic-Types.html#gpointer">gpointer</a> mem_chain,
                                             <a href="glib-Basic-Types.html#gsize">gsize</a> next_offset);

#define     <a href="glib-Memory-Slices.html#g-slice-new">g_slice_new</a>                     (type)
#define     <a href="glib-Memory-Slices.html#g-slice-new0">g_slice_new0</a>                    (type)
#define     <a href="glib-Memory-Slices.html#g-slice-free">g_slice_free</a>                    (type, mem)
#define     <a href="glib-Memory-Slices.html#g-slice-free-chain">g_slice_free_chain</a>              (type, mem_chain, next)

</pre>
</div>
<div class="refsect1" lang="en">
<a name="desc"></a><h2>Description</h2>
<p>
Memory slices provide a space-efficient and multi-processing scalable
way to allocate equal-sized pieces of memory, just like the original
<span class="type">GMemChunks</span> (from GLib &lt;= 2.8), while avoiding their excessive
memory-waste, scalability and performance problems.
</p>
<p>
To achieve these goals, the slice allocator uses a sophisticated, 
layered design that has been inspired by Bonwick's slab allocator
<sup>[<a name="id3092745" href="#ftn.id3092745">5</a>]</sup>.
It uses <code class="function">posix_memalign()</code> to optimize allocations of many equally-sized 
chunks, and has per-thread free lists (the so-called magazine layer) 
to quickly satisfy allocation requests of already known structure sizes. 
This is accompanied by extra caching logic to keep freed memory around 
for some time before returning it to the system. Memory that is unused 
due to alignment constraints is used for cache colorization (random 
distribution of chunk addresses) to improve CPU cache utilization. The 
caching layer of the slice allocator adapts itself to high lock contention 
to improve scalability.
</p>
<p>
The slice allocator can allocate blocks as small as two pointers, and
unlike <code class="function">malloc()</code>, it does not reserve extra space per block. For large block 
sizes, <a href="glib-Memory-Slices.html#g-slice-new"><code class="function">g_slice_new()</code></a> and <a href="glib-Memory-Slices.html#g-slice-alloc"><code class="function">g_slice_alloc()</code></a> will automatically delegate to the
system <code class="function">malloc()</code> implementation. For newly written code it is recommended
to use the new <code class="literal">g_slice</code> API instead of <a href="glib-Memory-Allocation.html#g-malloc"><code class="function">g_malloc()</code></a> and 
friends, as long as objects are not resized during their lifetime and the 
object size used at allocation time is still available when freeing.
</p>
<div class="example">
<a name="id3092856"></a><p class="title"><b>Example&#160;1.&#160;Using the slice allocator</b></p>
<pre class="programlisting">
  gchar *mem[10000];
  gint i;

  /* Allocate 10000 blocks. */
  for (i = 0; i &lt; 10000; i++)
    {
      mem[i] = g_slice_alloc (50);

      /* Fill in the memory with some junk. */
      for (j = 0; j &lt; 50; j++)
	mem[i][j] = i * j;
    }

  /* Now free all of the blocks. */
  for (i = 0; i &lt; 10000; i++)
    {
      g_slice_free1 (50, mem[i]);
    }
</pre>
</div>
<div class="example">
<a name="id3092877"></a><p class="title"><b>Example&#160;2.&#160;Using the slice allocator with data structures</b></p>
<pre class="programlisting">
  GRealArray *array;

  /* Allocate one block, using the g_slice_new() macro. */
  array = g_slice_new (GRealArray);

  /* We can now use array just like a normal pointer to a structure. */
  array-&gt;data            = NULL;
  array-&gt;len             = 0;
  array-&gt;alloc           = 0;
  array-&gt;zero_terminated = (zero_terminated ? 1 : 0);
  array-&gt;clear           = (clear ? 1 : 0);
  array-&gt;elt_size        = elt_size;

  /* We can free the block, so it can be reused. */
  g_slice_free (GRealArray, array);
</pre>
</div>
</div>
<div class="refsect1" lang="en">
<a name="details"></a><h2>Details</h2>
<div class="refsect2" lang="en">
<a name="id3092913"></a><h3>
<a name="g-slice-alloc"></a>g_slice_alloc ()</h3>
<a class="indexterm" name="id3092927"></a><pre class="programlisting"><a href="glib-Basic-Types.html#gpointer">gpointer</a>    g_slice_alloc                   (<a href="glib-Basic-Types.html#gsize">gsize</a> block_size);</pre>
<p>
Allocates a block of memory from the slice allocator.
The block adress handed out is guaranteed to be aligned
to at least 2 * sizeof (void*).
Note that the underlying slice allocation mechanism can
be changed with the <a href="glib-running.html#G_SLICE">G_SLICE=always-malloc</a>
environment variable.
</p>
<div class="variablelist"><table border="0">
<col align="left" valign="top">
<tbody>
<tr>
<td>
<span class="term"><em class="parameter"><code>block_size</code></em>&#160;:</span></td>
<td>the number of bytes to allocate
</td>
</tr>
<tr>
<td>
<span class="term"><span class="emphasis"><em>Returns</em></span>&#160;:</span></td>
<td>a pointer to the allocated memory block
</td>
</tr>
</tbody>
</table></div>
<p>Since 2.10


</p>
</div>
<hr>
<div class="refsect2" lang="en">
<a name="id3093002"></a><h3>
<a name="g-slice-alloc0"></a>g_slice_alloc0 ()</h3>
<a class="indexterm" name="id3093016"></a><pre class="programlisting"><a href="glib-Basic-Types.html#gpointer">gpointer</a>    g_slice_alloc0                  (<a href="glib-Basic-Types.html#gsize">gsize</a> block_size);</pre>
<p>
Allocates a block of memory via <a href="glib-Memory-Slices.html#g-slice-alloc"><code class="function">g_slice_alloc()</code></a>
and initialize the returned memory to 0.
Note that the underlying slice allocation mechanism can
be changed with the <a href="glib-running.html#G_SLICE">G_SLICE=always-malloc</a>
environment variable.
</p>
<div class="variablelist"><table border="0">
<col align="left" valign="top">
<tbody>
<tr>
<td>
<span class="term"><em class="parameter"><code>block_size</code></em>&#160;:</span></td>
<td>the number of bytes to allocate
</td>
</tr>
<tr>
<td>
<span class="term"><span class="emphasis"><em>Returns</em></span>&#160;:</span></td>
<td>a pointer to the allocated block
</td>
</tr>
</tbody>
</table></div>
<p>Since 2.10


</p>
</div>
<hr>
<div class="refsect2" lang="en">
<a name="id3093099"></a><h3>
<a name="g-slice-free1"></a>g_slice_free1 ()</h3>
<a class="indexterm" name="id3093114"></a><pre class="programlisting">void        g_slice_free1                   (<a href="glib-Basic-Types.html#gsize">gsize</a> block_size,
                                             <a href="glib-Basic-Types.html#gpointer">gpointer</a> mem_block);</pre>
<p>
Frees a block of memory. The memory must have been allocated via
<a href="glib-Memory-Slices.html#g-slice-alloc"><code class="function">g_slice_alloc()</code></a> or <a href="glib-Memory-Slices.html#g-slice-alloc0"><code class="function">g_slice_alloc0()</code></a>
and the <em class="parameter"><code>block_size</code></em> has to match the size specified upon allocation.
Note that the exact release behaviour can be changed with the
<a href="glib-running.html#G_DEBUG">G_DEBUG=gc-friendly</a> environment variable.
</p>
<div class="variablelist"><table border="0">
<col align="left" valign="top">
<tbody>
<tr>
<td>
<span class="term"><em class="parameter"><code>block_size</code></em>&#160;:</span></td>
<td>the size of the block
</td>
</tr>
<tr>
<td>
<span class="term"><em class="parameter"><code>mem_block</code></em>&#160;:</span></td>
<td>a pointer to the block to free
</td>
</tr>
</tbody>
</table></div>
<p>Since 2.10


</p>
</div>
<hr>
<div class="refsect2" lang="en">
<a name="id3093225"></a><h3>
<a name="g-slice-free-chain-with-offset"></a>g_slice_free_chain_with_offset ()</h3>
<a class="indexterm" name="id3093240"></a><pre class="programlisting">void        g_slice_free_chain_with_offset  (<a href="glib-Basic-Types.html#gsize">gsize</a> block_size,
                                             <a href="glib-Basic-Types.html#gpointer">gpointer</a> mem_chain,
                                             <a href="glib-Basic-Types.html#gsize">gsize</a> next_offset);</pre>
<p>
Frees a linked list of memory blocks of structure type <em class="parameter"><code>type</code></em>.
The memory blocks must be equal-sized, allocated via
<a href="glib-Memory-Slices.html#g-slice-alloc"><code class="function">g_slice_alloc()</code></a> or <a href="glib-Memory-Slices.html#g-slice-alloc0"><code class="function">g_slice_alloc0()</code></a>
and linked together by a <em class="parameter"><code>next</code></em> pointer (similar to <a href="glib-Singly-Linked-Lists.html#GSList"><span class="type">GSList</span></a>). The offset 
of the <em class="parameter"><code>next</code></em> field in each block is passed as third argument.
Note that the exact release behaviour can be changed with the
<a href="glib-running.html#G_DEBUG">G_DEBUG=gc-friendly</a> environment variable.
</p>
<div class="variablelist"><table border="0">
<col align="left" valign="top">
<tbody>
<tr>
<td>
<span class="term"><em class="parameter"><code>block_size</code></em>&#160;:</span></td>
<td>the size of the blocks
</td>
</tr>
<tr>
<td>
<span class="term"><em class="parameter"><code>mem_chain</code></em>&#160;:</span></td>
<td> a pointer to the first block of the chain
</td>
</tr>
<tr>
<td>
<span class="term"><em class="parameter"><code>next_offset</code></em>&#160;:</span></td>
<td>the offset of the <em class="parameter"><code>next</code></em> field in the blocks
</td>
</tr>
</tbody>
</table></div>
<p>Since 2.10


</p>
</div>
<hr>
<div class="refsect2" lang="en">
<a name="id3093402"></a><h3>
<a name="g-slice-new"></a>g_slice_new()</h3>
<a class="indexterm" name="id3093417"></a><pre class="programlisting">#define     g_slice_new(type)</pre>
<p>
A convenience macro to allocate a block of memory from the slice allocator.
It calls <a href="glib-Memory-Slices.html#g-slice-alloc"><code class="function">g_slice_alloc()</code></a> with sizeof (<em class="parameter"><code>type</code></em>) and casts the returned pointer
to a pointer of the given type, avoiding a type cast in the source code.
Note that the underlying slice allocation mechanism can
be changed with the <a href="glib-running.html#G_SLICE">G_SLICE=always-malloc</a>
environment variable.
</p>
<div class="variablelist"><table border="0">
<col align="left" valign="top">
<tbody>
<tr>
<td>
<span class="term"><em class="parameter"><code>type</code></em>&#160;:</span></td>
<td>the type to allocate, typically a structure name
</td>
</tr>
<tr>
<td>
<span class="term"><span class="emphasis"><em>Returns</em></span>&#160;:</span></td>
<td>a pointer to the allocated block, cast to a pointer to <em class="parameter"><code>type</code></em>.
</td>
</tr>
</tbody>
</table></div>
<p>Since 2.10


</p>
</div>
<hr>
<div class="refsect2" lang="en">
<a name="id3093501"></a><h3>
<a name="g-slice-new0"></a>g_slice_new0()</h3>
<a class="indexterm" name="id3093517"></a><pre class="programlisting">#define     g_slice_new0(type)</pre>
<p>
A convenience macro to allocate a block of memory from the slice allocator
and set the memory to 0. It calls <a href="glib-Memory-Slices.html#g-slice-alloc0"><code class="function">g_slice_alloc0()</code></a> with sizeof (<em class="parameter"><code>type</code></em>) and
casts the returned pointer to a pointer of the given type, avoiding a type
cast in the source code.
Note that the underlying slice allocation mechanism can
be changed with the <a href="glib-running.html#G_SLICE">G_SLICE=always-malloc</a>
environment variable.
</p>
<div class="variablelist"><table border="0">
<col align="left" valign="top">
<tbody>
<tr>
<td>
<span class="term"><em class="parameter"><code>type</code></em>&#160;:</span></td>
<td>the type to allocate, typically a structure name
</td>
</tr>
<tr>
<td>
<span class="term"><span class="emphasis"><em>Returns</em></span>&#160;:</span></td>
<td>a pointer to the allocated block, cast to a pointer to <em class="parameter"><code>type</code></em>.
</td>
</tr>
</tbody>
</table></div>
<p>Since 2.10


</p>
</div>
<hr>
<div class="refsect2" lang="en">
<a name="id3093602"></a><h3>
<a name="g-slice-free"></a>g_slice_free()</h3>
<a class="indexterm" name="id3093616"></a><pre class="programlisting">#define     g_slice_free(type, mem)</pre>
<p>
A convenience macro to free a block of memory that has been allocated
from the slice allocator. It calls <a href="glib-Memory-Slices.html#g-slice-free1"><code class="function">g_slice_free1()</code></a> using 
<code class="literal">sizeof (type)</code> as the block size.
Note that the exact release behaviour can be changed with the
<a href="glib-running.html#G_DEBUG">G_DEBUG=gc-friendly</a> environment variable.
</p>
<div class="variablelist"><table border="0">
<col align="left" valign="top">
<tbody>
<tr>
<td>
<span class="term"><em class="parameter"><code>type</code></em>&#160;:</span></td>
<td>the type of the block to free, typically a structure name
</td>
</tr>
<tr>
<td>
<span class="term"><em class="parameter"><code>mem</code></em>&#160;:</span></td>
<td>
</td>
</tr>
</tbody>
</table></div>
<p>Since 2.10
</p>
</div>
<hr>
<div class="refsect2" lang="en">
<a name="id3093696"></a><h3>
<a name="g-slice-free-chain"></a>g_slice_free_chain()</h3>
<a class="indexterm" name="id3093711"></a><pre class="programlisting">#define     g_slice_free_chain(type, mem_chain, next)</pre>
<p>
Frees a linked list of memory blocks of structure type <em class="parameter"><code>type</code></em>.
The memory blocks must be equal-sized, allocated via
<a href="glib-Memory-Slices.html#g-slice-alloc"><code class="function">g_slice_alloc()</code></a> or <a href="glib-Memory-Slices.html#g-slice-alloc0"><code class="function">g_slice_alloc0()</code></a> and linked together by a 
<em class="parameter"><code>next</code></em> pointer (similar to <a href="glib-Singly-Linked-Lists.html#GSList"><span class="type">GSList</span></a>). The name of the
<em class="parameter"><code>next</code></em> field in <em class="parameter"><code>type</code></em> is passed as third argument.
Note that the exact release behaviour can be changed with the
<a href="glib-running.html#G_DEBUG">G_DEBUG=gc-friendly</a> environment variable.
</p>
<div class="variablelist"><table border="0">
<col align="left" valign="top">
<tbody>
<tr>
<td>
<span class="term"><em class="parameter"><code>type</code></em>&#160;:</span></td>
<td>       the type of the <em class="parameter"><code>mem_chain</code></em> blocks
</td>
</tr>
<tr>
<td>
<span class="term"><em class="parameter"><code>mem_chain</code></em>&#160;:</span></td>
<td>  a pointer to the first block of the chain
</td>
</tr>
<tr>
<td>
<span class="term"><em class="parameter"><code>next</code></em>&#160;:</span></td>
<td>       the field name of the next pointer in <em class="parameter"><code>type</code></em>
</td>
</tr>
</tbody>
</table></div>
<p>Since 2.10


</p>
</div>
</div>
<div class="footnotes">
<br><hr width="100" align="left">
<div class="footnote"><p><sup>[<a name="ftn.id3092745" href="#id3092745">5</a>] </sup>
<a href="http://citeseer.ist.psu.edu/bonwick94slab.html" target="_top">[Bonwick94]</a> Jeff Bonwick, The slab allocator: An object-caching kernel
memory allocator. USENIX 1994, and  
<a href="http://citeseer.ist.psu.edu/bonwick01magazines.html" target="_top">[Bonwick01]</a> Bonwick and Jonathan Adams, Magazines and vmem: Extending the
slab allocator to many cpu's and arbitrary resources. USENIX 2001
</p></div>
</div>
</div>
</body>
</html>
