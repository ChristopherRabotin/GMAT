<refentry id="gobject-Type-Information">
<refmeta>
<refentrytitle id="top_of_page">GType</refentrytitle>
<manvolnum>3</manvolnum>
<refmiscinfo>GOBJECT Library</refmiscinfo>
</refmeta>

<refnamediv>
<refname>GType</refname>
<refpurpose>The GLib Runtime type identification and management system</refpurpose>
<!--[<xref linkend="desc" endterm="desc.title"/>]-->
</refnamediv>

<refsynopsisdiv id="synopsis">
<title id="synopsis.title">Synopsis</title>

<synopsis>

#include &lt;glib-object.h&gt;


typedef     <link linkend="GType">GType</link>;
#define     <link linkend="G-TYPE-FUNDAMENTAL:CAPS">G_TYPE_FUNDAMENTAL</link>              (type)
#define     <link linkend="G-TYPE-FUNDAMENTAL-MAX:CAPS">G_TYPE_FUNDAMENTAL_MAX</link>
#define     <link linkend="G-TYPE-MAKE-FUNDAMENTAL:CAPS">G_TYPE_MAKE_FUNDAMENTAL</link>         (x)
#define     <link linkend="G-TYPE-IS-ABSTRACT:CAPS">G_TYPE_IS_ABSTRACT</link>              (type)
#define     <link linkend="G-TYPE-IS-DERIVED:CAPS">G_TYPE_IS_DERIVED</link>               (type)
#define     <link linkend="G-TYPE-IS-FUNDAMENTAL:CAPS">G_TYPE_IS_FUNDAMENTAL</link>           (type)
#define     <link linkend="G-TYPE-IS-VALUE-TYPE:CAPS">G_TYPE_IS_VALUE_TYPE</link>            (type)
#define     <link linkend="G-TYPE-HAS-VALUE-TABLE:CAPS">G_TYPE_HAS_VALUE_TABLE</link>          (type)
#define     <link linkend="G-TYPE-IS-CLASSED:CAPS">G_TYPE_IS_CLASSED</link>               (type)
#define     <link linkend="G-TYPE-IS-INSTANTIATABLE:CAPS">G_TYPE_IS_INSTANTIATABLE</link>        (type)
#define     <link linkend="G-TYPE-IS-DERIVABLE:CAPS">G_TYPE_IS_DERIVABLE</link>             (type)
#define     <link linkend="G-TYPE-IS-DEEP-DERIVABLE:CAPS">G_TYPE_IS_DEEP_DERIVABLE</link>        (type)
#define     <link linkend="G-TYPE-IS-INTERFACE:CAPS">G_TYPE_IS_INTERFACE</link>             (type)
            <link linkend="GTypeInterface">GTypeInterface</link>;
            <link linkend="GTypeInstance">GTypeInstance</link>;
            <link linkend="GTypeClass">GTypeClass</link>;
            <link linkend="GTypeInfo">GTypeInfo</link>;
            <link linkend="GTypeFundamentalInfo">GTypeFundamentalInfo</link>;
            <link linkend="GInterfaceInfo">GInterfaceInfo</link>;
            <link linkend="GTypeValueTable">GTypeValueTable</link>;
#define     <link linkend="G-TYPE-FROM-INSTANCE:CAPS">G_TYPE_FROM_INSTANCE</link>            (instance)
#define     <link linkend="G-TYPE-FROM-CLASS:CAPS">G_TYPE_FROM_CLASS</link>               (g_class)
#define     <link linkend="G-TYPE-FROM-INTERFACE:CAPS">G_TYPE_FROM_INTERFACE</link>           (g_iface)
#define     <link linkend="G-TYPE-INSTANCE-GET-CLASS:CAPS">G_TYPE_INSTANCE_GET_CLASS</link>       (instance, g_type, c_type)
#define     <link linkend="G-TYPE-INSTANCE-GET-INTERFACE:CAPS">G_TYPE_INSTANCE_GET_INTERFACE</link>   (instance, g_type, c_type)
#define     <link linkend="G-TYPE-INSTANCE-GET-PRIVATE:CAPS">G_TYPE_INSTANCE_GET_PRIVATE</link>     (instance, g_type, c_type)
#define     <link linkend="G-TYPE-CHECK-INSTANCE:CAPS">G_TYPE_CHECK_INSTANCE</link>           (instance)
#define     <link linkend="G-TYPE-CHECK-INSTANCE-CAST:CAPS">G_TYPE_CHECK_INSTANCE_CAST</link>      (instance, g_type, c_type)
#define     <link linkend="G-TYPE-CHECK-INSTANCE-TYPE:CAPS">G_TYPE_CHECK_INSTANCE_TYPE</link>      (instance, g_type)
#define     <link linkend="G-TYPE-CHECK-CLASS-CAST:CAPS">G_TYPE_CHECK_CLASS_CAST</link>         (g_class, g_type, c_type)
#define     <link linkend="G-TYPE-CHECK-CLASS-TYPE:CAPS">G_TYPE_CHECK_CLASS_TYPE</link>         (g_class, g_type)
#define     <link linkend="G-TYPE-CHECK-VALUE:CAPS">G_TYPE_CHECK_VALUE</link>              (value)
#define     <link linkend="G-TYPE-CHECK-VALUE-TYPE:CAPS">G_TYPE_CHECK_VALUE_TYPE</link>         (value, g_type)
#define     <link linkend="G-TYPE-FLAG-RESERVED-ID-BIT:CAPS">G_TYPE_FLAG_RESERVED_ID_BIT</link>
<link linkend="void">void</link>        <link linkend="g-type-init">g_type_init</link>                     (void);
enum        <link linkend="GTypeDebugFlags">GTypeDebugFlags</link>;
<link linkend="void">void</link>        <link linkend="g-type-init-with-debug-flags">g_type_init_with_debug_flags</link>    (<link linkend="GTypeDebugFlags">GTypeDebugFlags</link> debug_flags);
const <link linkend="gchar">gchar</link>* <link linkend="g-type-name">g_type_name</link>                    (<link linkend="GType">GType</link> type);
<link linkend="GQuark">GQuark</link>      <link linkend="g-type-qname">g_type_qname</link>                    (<link linkend="GType">GType</link> type);
<link linkend="GType">GType</link>       <link linkend="g-type-from-name">g_type_from_name</link>                (const <link linkend="gchar">gchar</link> *name);
<link linkend="GType">GType</link>       <link linkend="g-type-parent">g_type_parent</link>                   (<link linkend="GType">GType</link> type);
<link linkend="guint">guint</link>       <link linkend="g-type-depth">g_type_depth</link>                    (<link linkend="GType">GType</link> type);
<link linkend="GType">GType</link>       <link linkend="g-type-next-base">g_type_next_base</link>                (<link linkend="GType">GType</link> leaf_type,
                                             <link linkend="GType">GType</link> root_type);
<link linkend="gboolean">gboolean</link>    <link linkend="g-type-is-a">g_type_is_a</link>                     (<link linkend="GType">GType</link> type,
                                             <link linkend="GType">GType</link> is_a_type);
<link linkend="gpointer">gpointer</link>    <link linkend="g-type-class-ref">g_type_class_ref</link>                (<link linkend="GType">GType</link> type);
<link linkend="gpointer">gpointer</link>    <link linkend="g-type-class-peek">g_type_class_peek</link>               (<link linkend="GType">GType</link> type);
<link linkend="gpointer">gpointer</link>    <link linkend="g-type-class-peek-static">g_type_class_peek_static</link>        (<link linkend="GType">GType</link> type);
<link linkend="void">void</link>        <link linkend="g-type-class-unref">g_type_class_unref</link>              (<link linkend="gpointer">gpointer</link> g_class);
<link linkend="gpointer">gpointer</link>    <link linkend="g-type-class-peek-parent">g_type_class_peek_parent</link>        (<link linkend="gpointer">gpointer</link> g_class);
<link linkend="void">void</link>        <link linkend="g-type-class-add-private">g_type_class_add_private</link>        (<link linkend="gpointer">gpointer</link> g_class,
                                             <link linkend="gsize">gsize</link> private_size);
<link linkend="gpointer">gpointer</link>    <link linkend="g-type-interface-peek">g_type_interface_peek</link>           (<link linkend="gpointer">gpointer</link> instance_class,
                                             <link linkend="GType">GType</link> iface_type);
<link linkend="gpointer">gpointer</link>    <link linkend="g-type-interface-peek-parent">g_type_interface_peek_parent</link>    (<link linkend="gpointer">gpointer</link> g_iface);
<link linkend="gpointer">gpointer</link>    <link linkend="g-type-default-interface-ref">g_type_default_interface_ref</link>    (<link linkend="GType">GType</link> g_type);
<link linkend="gpointer">gpointer</link>    <link linkend="g-type-default-interface-peek">g_type_default_interface_peek</link>   (<link linkend="GType">GType</link> g_type);
<link linkend="void">void</link>        <link linkend="g-type-default-interface-unref">g_type_default_interface_unref</link>  (<link linkend="gpointer">gpointer</link> g_iface);
<link linkend="GType">GType</link>*      <link linkend="g-type-children">g_type_children</link>                 (<link linkend="GType">GType</link> type,
                                             <link linkend="guint">guint</link> *n_children);
<link linkend="GType">GType</link>*      <link linkend="g-type-interfaces">g_type_interfaces</link>               (<link linkend="GType">GType</link> type,
                                             <link linkend="guint">guint</link> *n_interfaces);
<link linkend="GType">GType</link>*      <link linkend="g-type-interface-prerequisites">g_type_interface_prerequisites</link>  (<link linkend="GType">GType</link> interface_type,
                                             <link linkend="guint">guint</link> *n_prerequisites);
<link linkend="void">void</link>        <link linkend="g-type-set-qdata">g_type_set_qdata</link>                (<link linkend="GType">GType</link> type,
                                             <link linkend="GQuark">GQuark</link> quark,
                                             <link linkend="gpointer">gpointer</link> data);
<link linkend="gpointer">gpointer</link>    <link linkend="g-type-get-qdata">g_type_get_qdata</link>                (<link linkend="GType">GType</link> type,
                                             <link linkend="GQuark">GQuark</link> quark);
<link linkend="void">void</link>        <link linkend="g-type-query">g_type_query</link>                    (<link linkend="GType">GType</link> type,
                                             <link linkend="GTypeQuery">GTypeQuery</link> *query);
            <link linkend="GTypeQuery">GTypeQuery</link>;
<link linkend="void">void</link>        (<link linkend="GBaseInitFunc">*GBaseInitFunc</link>)                (<link linkend="gpointer">gpointer</link> g_class);
<link linkend="void">void</link>        (<link linkend="GBaseFinalizeFunc">*GBaseFinalizeFunc</link>)            (<link linkend="gpointer">gpointer</link> g_class);
<link linkend="void">void</link>        (<link linkend="GClassInitFunc">*GClassInitFunc</link>)               (<link linkend="gpointer">gpointer</link> g_class,
                                             <link linkend="gpointer">gpointer</link> class_data);
<link linkend="void">void</link>        (<link linkend="GClassFinalizeFunc">*GClassFinalizeFunc</link>)           (<link linkend="gpointer">gpointer</link> g_class,
                                             <link linkend="gpointer">gpointer</link> class_data);
<link linkend="void">void</link>        (<link linkend="GInstanceInitFunc">*GInstanceInitFunc</link>)            (<link linkend="GTypeInstance">GTypeInstance</link> *instance,
                                             <link linkend="gpointer">gpointer</link> g_class);
<link linkend="void">void</link>        (<link linkend="GInterfaceInitFunc">*GInterfaceInitFunc</link>)           (<link linkend="gpointer">gpointer</link> g_iface,
                                             <link linkend="gpointer">gpointer</link> iface_data);
<link linkend="void">void</link>        (<link linkend="GInterfaceFinalizeFunc">*GInterfaceFinalizeFunc</link>)       (<link linkend="gpointer">gpointer</link> g_iface,
                                             <link linkend="gpointer">gpointer</link> iface_data);
<link linkend="gboolean">gboolean</link>    (<link linkend="GTypeClassCacheFunc">*GTypeClassCacheFunc</link>)          (<link linkend="gpointer">gpointer</link> cache_data,
                                             <link linkend="GTypeClass">GTypeClass</link> *g_class);
enum        <link linkend="GTypeFlags">GTypeFlags</link>;
enum        <link linkend="GTypeFundamentalFlags">GTypeFundamentalFlags</link>;
<link linkend="GType">GType</link>       <link linkend="g-type-register-static">g_type_register_static</link>          (<link linkend="GType">GType</link> parent_type,
                                             const <link linkend="gchar">gchar</link> *type_name,
                                             const <link linkend="GTypeInfo">GTypeInfo</link> *info,
                                             <link linkend="GTypeFlags">GTypeFlags</link> flags);
<link linkend="GType">GType</link>       <link linkend="g-type-register-dynamic">g_type_register_dynamic</link>         (<link linkend="GType">GType</link> parent_type,
                                             const <link linkend="gchar">gchar</link> *type_name,
                                             <link linkend="GTypePlugin">GTypePlugin</link> *plugin,
                                             <link linkend="GTypeFlags">GTypeFlags</link> flags);
<link linkend="GType">GType</link>       <link linkend="g-type-register-fundamental">g_type_register_fundamental</link>     (<link linkend="GType">GType</link> type_id,
                                             const <link linkend="gchar">gchar</link> *type_name,
                                             const <link linkend="GTypeInfo">GTypeInfo</link> *info,
                                             const <link linkend="GTypeFundamentalInfo">GTypeFundamentalInfo</link> *finfo,
                                             <link linkend="GTypeFlags">GTypeFlags</link> flags);
<link linkend="void">void</link>        <link linkend="g-type-add-interface-static">g_type_add_interface_static</link>     (<link linkend="GType">GType</link> instance_type,
                                             <link linkend="GType">GType</link> interface_type,
                                             const <link linkend="GInterfaceInfo">GInterfaceInfo</link> *info);
<link linkend="void">void</link>        <link linkend="g-type-add-interface-dynamic">g_type_add_interface_dynamic</link>    (<link linkend="GType">GType</link> instance_type,
                                             <link linkend="GType">GType</link> interface_type,
                                             <link linkend="GTypePlugin">GTypePlugin</link> *plugin);
<link linkend="void">void</link>        <link linkend="g-type-interface-add-prerequisite">g_type_interface_add_prerequisite</link>
                                            (<link linkend="GType">GType</link> interface_type,
                                             <link linkend="GType">GType</link> prerequisite_type);
<link linkend="GTypePlugin">GTypePlugin</link>* <link linkend="g-type-get-plugin">g_type_get_plugin</link>              (<link linkend="GType">GType</link> type);
<link linkend="GTypePlugin">GTypePlugin</link>* <link linkend="g-type-interface-get-plugin">g_type_interface_get_plugin</link>    (<link linkend="GType">GType</link> instance_type,
                                             <link linkend="GType">GType</link> interface_type);
<link linkend="GType">GType</link>       <link linkend="g-type-fundamental-next">g_type_fundamental_next</link>         (void);
<link linkend="GType">GType</link>       <link linkend="g-type-fundamental">g_type_fundamental</link>              (<link linkend="GType">GType</link> type_id);
<link linkend="GTypeInstance">GTypeInstance</link>* <link linkend="g-type-create-instance">g_type_create_instance</link>       (<link linkend="GType">GType</link> type);
<link linkend="void">void</link>        <link linkend="g-type-free-instance">g_type_free_instance</link>            (<link linkend="GTypeInstance">GTypeInstance</link> *instance);
<link linkend="void">void</link>        <link linkend="g-type-add-class-cache-func">g_type_add_class_cache_func</link>     (<link linkend="gpointer">gpointer</link> cache_data,
                                             <link linkend="GTypeClassCacheFunc">GTypeClassCacheFunc</link> cache_func);
<link linkend="void">void</link>        <link linkend="g-type-remove-class-cache-func">g_type_remove_class_cache_func</link>  (<link linkend="gpointer">gpointer</link> cache_data,
                                             <link linkend="GTypeClassCacheFunc">GTypeClassCacheFunc</link> cache_func);
<link linkend="void">void</link>        <link linkend="g-type-class-unref-uncached">g_type_class_unref_uncached</link>     (<link linkend="gpointer">gpointer</link> g_class);
<link linkend="void">void</link>        <link linkend="g-type-add-interface-check">g_type_add_interface_check</link>      (<link linkend="gpointer">gpointer</link> check_data,
                                             <link linkend="GTypeInterfaceCheckFunc">GTypeInterfaceCheckFunc</link> check_func);
<link linkend="void">void</link>        <link linkend="g-type-remove-interface-check">g_type_remove_interface_check</link>   (<link linkend="gpointer">gpointer</link> check_data,
                                             <link linkend="GTypeInterfaceCheckFunc">GTypeInterfaceCheckFunc</link> check_func);
<link linkend="void">void</link>        (<link linkend="GTypeInterfaceCheckFunc">*GTypeInterfaceCheckFunc</link>)      (<link linkend="gpointer">gpointer</link> check_data,
                                             <link linkend="gpointer">gpointer</link> g_iface);
<link linkend="GTypeValueTable">GTypeValueTable</link>* <link linkend="g-type-value-table-peek">g_type_value_table_peek</link>    (<link linkend="GType">GType</link> type);
#define     <link linkend="G-DEFINE-TYPE:CAPS">G_DEFINE_TYPE</link>                   (TN, t_n, T_P)
#define     <link linkend="G-DEFINE-TYPE-WITH-CODE:CAPS">G_DEFINE_TYPE_WITH_CODE</link>         (TN, t_n, T_P, _C_)
#define     <link linkend="G-DEFINE-ABSTRACT-TYPE:CAPS">G_DEFINE_ABSTRACT_TYPE</link>          (TN, t_n, T_P)
#define     <link linkend="G-DEFINE-ABSTRACT-TYPE-WITH-CODE:CAPS">G_DEFINE_ABSTRACT_TYPE_WITH_CODE</link>(TN, t_n, T_P, _C_)
#define     <link linkend="G-IMPLEMENT-INTERFACE:CAPS">G_IMPLEMENT_INTERFACE</link>           (TYPE_IFACE, iface_init)
#define     <link linkend="G-DEFINE-TYPE-EXTENDED:CAPS">G_DEFINE_TYPE_EXTENDED</link>          (TypeName, type_name, TYPE_PARENT, flags, CODE)


#define     <link linkend="G-TYPE-INVALID:CAPS">G_TYPE_INVALID</link>
#define     <link linkend="G-TYPE-NONE:CAPS">G_TYPE_NONE</link>
#define     <link linkend="G-TYPE-INTERFACE:CAPS">G_TYPE_INTERFACE</link>
#define     <link linkend="G-TYPE-CHAR:CAPS">G_TYPE_CHAR</link>
#define     <link linkend="G-TYPE-UCHAR:CAPS">G_TYPE_UCHAR</link>
#define     <link linkend="G-TYPE-BOOLEAN:CAPS">G_TYPE_BOOLEAN</link>
#define     <link linkend="G-TYPE-INT:CAPS">G_TYPE_INT</link>
#define     <link linkend="G-TYPE-UINT:CAPS">G_TYPE_UINT</link>
#define     <link linkend="G-TYPE-LONG:CAPS">G_TYPE_LONG</link>
#define     <link linkend="G-TYPE-ULONG:CAPS">G_TYPE_ULONG</link>
#define     <link linkend="G-TYPE-INT64:CAPS">G_TYPE_INT64</link>
#define     <link linkend="G-TYPE-UINT64:CAPS">G_TYPE_UINT64</link>
#define     <link linkend="G-TYPE-ENUM:CAPS">G_TYPE_ENUM</link>
#define     <link linkend="G-TYPE-FLAGS:CAPS">G_TYPE_FLAGS</link>
#define     <link linkend="G-TYPE-FLOAT:CAPS">G_TYPE_FLOAT</link>
#define     <link linkend="G-TYPE-DOUBLE:CAPS">G_TYPE_DOUBLE</link>
#define     <link linkend="G-TYPE-STRING:CAPS">G_TYPE_STRING</link>
#define     <link linkend="G-TYPE-POINTER:CAPS">G_TYPE_POINTER</link>
#define     <link linkend="G-TYPE-BOXED:CAPS">G_TYPE_BOXED</link>
#define     <link linkend="G-TYPE-PARAM:CAPS">G_TYPE_PARAM</link>
#define     <link linkend="G-TYPE-OBJECT:CAPS">G_TYPE_OBJECT</link>

#define     <link linkend="G-TYPE-RESERVED-GLIB-FIRST:CAPS">G_TYPE_RESERVED_GLIB_FIRST</link>
#define     <link linkend="G-TYPE-RESERVED-GLIB-LAST:CAPS">G_TYPE_RESERVED_GLIB_LAST</link>
#define     <link linkend="G-TYPE-RESERVED-BSE-FIRST:CAPS">G_TYPE_RESERVED_BSE_FIRST</link>
#define     <link linkend="G-TYPE-RESERVED-BSE-LAST:CAPS">G_TYPE_RESERVED_BSE_LAST</link>
#define     <link linkend="G-TYPE-RESERVED-USER-FIRST:CAPS">G_TYPE_RESERVED_USER_FIRST</link>

</synopsis>
</refsynopsisdiv>









<refsect1 id="desc">
<title id="desc.title">Description</title>
<para>
The GType API is the foundation of the GObject system.  It provides the
facilities for registering and managing all fundamental data types,
user-defined object and interface types.  Before using any GType
or GObject functions, <link linkend="g-type-init"><function>g_type_init()</function></link> must be called to initialize the
type system.
</para>
<para>
For type creation and registration purposes, all types fall into one of
two categories: static or dynamic.  Static types are never loaded or
unloaded at run-time as dynamic types may be.  Static types are created
with <link linkend="g-type-register-static"><function>g_type_register_static()</function></link> that gets type specific information passed
in via a <link linkend="GTypeInfo"><type>GTypeInfo</type></link> structure.
Dynamic types are created with <link linkend="g-type-register-dynamic"><function>g_type_register_dynamic()</function></link> which takes a
<link linkend="GTypePlugin"><type>GTypePlugin</type></link> structure instead. The remaining type information (the
<link linkend="GTypeInfo"><type>GTypeInfo</type></link> structure) is retrieved during runtime through <link linkend="GTypePlugin"><type>GTypePlugin</type></link>
and the g_type_plugin_*() API.
These registration functions are usually called only once from a 
function whose only purpose is to return the type identifier for a 
specific class.  Once the type (or class or interface) is registered,
it may be instantiated, inherited, or implemented depending on exactly
what sort of type it is.
There is also a third registration function for registering fundamental
types called <link linkend="g-type-register-fundamental"><function>g_type_register_fundamental()</function></link> which requires both a <link linkend="GTypeInfo"><type>GTypeInfo</type></link>
structure and a <link linkend="GTypeFundamentalInfo"><type>GTypeFundamentalInfo</type></link> structure but it is seldom used
since most fundamental types are predefined rather than user-defined.
</para>
<para>
A final word about type names.
Such an identifier needs to be at least three characters long. There is no
upper length limit. The first character needs to be a letter (a-z or A-Z)
or an underscore '_'. Subsequent characters can be letters, numbers or
any of '-_+'.
</para>
</refsect1>

<refsect1 id="details">
<title id="details.title">Details</title>
<refsect2>
<title><anchor id="GType" role="typedef"/>GType</title>
<indexterm><primary>GType</primary></indexterm><para>
A numerical value which represents the unique identifier of a registered
type.
</para></refsect2>
<refsect2>
<title><anchor id="G-TYPE-FUNDAMENTAL:CAPS" role="macro"/>G_TYPE_FUNDAMENTAL()</title>
<indexterm><primary>G_TYPE_FUNDAMENTAL</primary></indexterm><programlisting>#define G_TYPE_FUNDAMENTAL(type)	(g_type_fundamental (type))
</programlisting>
<para>
Returns the fundamental type which is the ancestor of <parameter>type</parameter>.
Fundamental types are types that serve as fundaments for the derived types, 
thus they are the roots of distinct inheritance hierarchies.
</para><variablelist role="params">
<varlistentry><term><parameter>type</parameter>&nbsp;:</term>
<listitem><simpara>A <link linkend="GType"><type>GType</type></link> value.


</simpara></listitem></varlistentry>
</variablelist></refsect2>
<refsect2>
<title><anchor id="G-TYPE-FUNDAMENTAL-MAX:CAPS" role="macro"/>G_TYPE_FUNDAMENTAL_MAX</title>
<indexterm><primary>G_TYPE_FUNDAMENTAL_MAX</primary></indexterm><programlisting>#define	G_TYPE_FUNDAMENTAL_MAX		(255 &lt;&lt; G_TYPE_FUNDAMENTAL_SHIFT)
</programlisting>
<para>
An integer constant that represents the number of identifiers reserved
for types that are assigned at compile-time.
</para></refsect2>
<refsect2>
<title><anchor id="G-TYPE-MAKE-FUNDAMENTAL:CAPS" role="macro"/>G_TYPE_MAKE_FUNDAMENTAL()</title>
<indexterm><primary>G_TYPE_MAKE_FUNDAMENTAL</primary></indexterm><programlisting>#define	G_TYPE_MAKE_FUNDAMENTAL(x)	((GType) ((x) &lt;&lt; G_TYPE_FUNDAMENTAL_SHIFT))
</programlisting>
<para>
Returns the type ID for the fundamental type number <parameter>x</parameter>.
Use <link linkend="g-type-fundamental-next"><function>g_type_fundamental_next()</function></link> instead of this macro to create new fundamental 
types.
</para><variablelist role="params">
<varlistentry><term><parameter>x</parameter>&nbsp;:</term>
<listitem><simpara>the fundamental type number.


</simpara></listitem></varlistentry>
</variablelist></refsect2>
<refsect2>
<title><anchor id="G-TYPE-IS-ABSTRACT:CAPS" role="macro"/>G_TYPE_IS_ABSTRACT()</title>
<indexterm><primary>G_TYPE_IS_ABSTRACT</primary></indexterm><programlisting>#define G_TYPE_IS_ABSTRACT(type)                (g_type_test_flags ((type), G_TYPE_FLAG_ABSTRACT))
</programlisting>
<para>
Returns <literal>TRUE</literal> if <parameter>type</parameter> is an abstract type.  An abstract type can not be
instantiated and is normally used as an abstract base class for
derived classes.
</para><variablelist role="params">
<varlistentry><term><parameter>type</parameter>&nbsp;:</term>
<listitem><simpara>A <link linkend="GType"><type>GType</type></link> value.


</simpara></listitem></varlistentry>
</variablelist></refsect2>
<refsect2>
<title><anchor id="G-TYPE-IS-DERIVED:CAPS" role="macro"/>G_TYPE_IS_DERIVED()</title>
<indexterm><primary>G_TYPE_IS_DERIVED</primary></indexterm><programlisting>#define G_TYPE_IS_DERIVED(type)                 ((type) &gt; G_TYPE_FUNDAMENTAL_MAX)
</programlisting>
<para>
Returns <literal>TRUE</literal> if <parameter>type</parameter> is derived (or in object-oriented terminology:
inherited) from another type (this holds true for all non-fundamental
types).
</para><variablelist role="params">
<varlistentry><term><parameter>type</parameter>&nbsp;:</term>
<listitem><simpara>A <link linkend="GType"><type>GType</type></link> value.


</simpara></listitem></varlistentry>
</variablelist></refsect2>
<refsect2>
<title><anchor id="G-TYPE-IS-FUNDAMENTAL:CAPS" role="macro"/>G_TYPE_IS_FUNDAMENTAL()</title>
<indexterm><primary>G_TYPE_IS_FUNDAMENTAL</primary></indexterm><programlisting>#define G_TYPE_IS_FUNDAMENTAL(type)             ((type) &lt;= G_TYPE_FUNDAMENTAL_MAX)
</programlisting>
<para>
Returns <literal>TRUE</literal> if <parameter>type</parameter> is a fundamental type.
</para><variablelist role="params">
<varlistentry><term><parameter>type</parameter>&nbsp;:</term>
<listitem><simpara>A <link linkend="GType"><type>GType</type></link> value.


</simpara></listitem></varlistentry>
</variablelist></refsect2>
<refsect2>
<title><anchor id="G-TYPE-IS-VALUE-TYPE:CAPS" role="macro"/>G_TYPE_IS_VALUE_TYPE()</title>
<indexterm><primary>G_TYPE_IS_VALUE_TYPE</primary></indexterm><programlisting>#define G_TYPE_IS_VALUE_TYPE(type)              (g_type_check_is_value_type (type))
</programlisting>
<para>
Returns <literal>TRUE</literal> if <parameter>type</parameter> is a value type which can be used for
<link linkend="g-value-init"><function>g_value_init()</function></link>. 
</para><variablelist role="params">
<varlistentry><term><parameter>type</parameter>&nbsp;:</term>
<listitem><simpara>A <link linkend="GType"><type>GType</type></link> value.


</simpara></listitem></varlistentry>
</variablelist></refsect2>
<refsect2>
<title><anchor id="G-TYPE-HAS-VALUE-TABLE:CAPS" role="macro"/>G_TYPE_HAS_VALUE_TABLE()</title>
<indexterm><primary>G_TYPE_HAS_VALUE_TABLE</primary></indexterm><programlisting>#define G_TYPE_HAS_VALUE_TABLE(type)            (g_type_value_table_peek (type) != NULL)
</programlisting>
<para>
Returns <literal>TRUE</literal> if <parameter>type</parameter> has a <link linkend="GTypeValueTable"><type>GTypeValueTable</type></link>.
</para><variablelist role="params">
<varlistentry><term><parameter>type</parameter>&nbsp;:</term>
<listitem><simpara>A <link linkend="GType"><type>GType</type></link> value.


</simpara></listitem></varlistentry>
</variablelist></refsect2>
<refsect2>
<title><anchor id="G-TYPE-IS-CLASSED:CAPS" role="macro"/>G_TYPE_IS_CLASSED()</title>
<indexterm><primary>G_TYPE_IS_CLASSED</primary></indexterm><programlisting>#define G_TYPE_IS_CLASSED(type)                 (g_type_test_flags ((type), G_TYPE_FLAG_CLASSED))
</programlisting>
<para>
Returns <literal>TRUE</literal> if <parameter>type</parameter> is a classed type.
</para><variablelist role="params">
<varlistentry><term><parameter>type</parameter>&nbsp;:</term>
<listitem><simpara>A <link linkend="GType"><type>GType</type></link> value.


</simpara></listitem></varlistentry>
</variablelist></refsect2>
<refsect2>
<title><anchor id="G-TYPE-IS-INSTANTIATABLE:CAPS" role="macro"/>G_TYPE_IS_INSTANTIATABLE()</title>
<indexterm><primary>G_TYPE_IS_INSTANTIATABLE</primary></indexterm><programlisting>#define G_TYPE_IS_INSTANTIATABLE(type)          (g_type_test_flags ((type), G_TYPE_FLAG_INSTANTIATABLE))
</programlisting>
<para>
Returns <literal>TRUE</literal> if <parameter>type</parameter> can be instantiated.  Instantiation is the
process of creating an instance (object) of this type.
</para><variablelist role="params">
<varlistentry><term><parameter>type</parameter>&nbsp;:</term>
<listitem><simpara>A <link linkend="GType"><type>GType</type></link> value.


</simpara></listitem></varlistentry>
</variablelist></refsect2>
<refsect2>
<title><anchor id="G-TYPE-IS-DERIVABLE:CAPS" role="macro"/>G_TYPE_IS_DERIVABLE()</title>
<indexterm><primary>G_TYPE_IS_DERIVABLE</primary></indexterm><programlisting>#define G_TYPE_IS_DERIVABLE(type)               (g_type_test_flags ((type), G_TYPE_FLAG_DERIVABLE))
</programlisting>
<para>
Returns <literal>TRUE</literal> if <parameter>type</parameter> is a derivable type.  A derivable type can
be used as the base class of a flat (single-level) class hierarchy.
</para><variablelist role="params">
<varlistentry><term><parameter>type</parameter>&nbsp;:</term>
<listitem><simpara>A <link linkend="GType"><type>GType</type></link> value.


</simpara></listitem></varlistentry>
</variablelist></refsect2>
<refsect2>
<title><anchor id="G-TYPE-IS-DEEP-DERIVABLE:CAPS" role="macro"/>G_TYPE_IS_DEEP_DERIVABLE()</title>
<indexterm><primary>G_TYPE_IS_DEEP_DERIVABLE</primary></indexterm><programlisting>#define G_TYPE_IS_DEEP_DERIVABLE(type)          (g_type_test_flags ((type), G_TYPE_FLAG_DEEP_DERIVABLE))
</programlisting>
<para>
Returns <literal>TRUE</literal> if <parameter>type</parameter> is a deep derivable type.  A deep derivable type
can be used as the base class of a deep (multi-level) class hierarchy.
</para><variablelist role="params">
<varlistentry><term><parameter>type</parameter>&nbsp;:</term>
<listitem><simpara>A <link linkend="GType"><type>GType</type></link> value.


</simpara></listitem></varlistentry>
</variablelist></refsect2>
<refsect2>
<title><anchor id="G-TYPE-IS-INTERFACE:CAPS" role="macro"/>G_TYPE_IS_INTERFACE()</title>
<indexterm><primary>G_TYPE_IS_INTERFACE</primary></indexterm><programlisting>#define G_TYPE_IS_INTERFACE(type)               (G_TYPE_FUNDAMENTAL (type) == G_TYPE_INTERFACE)
</programlisting>
<para>
Returns <literal>TRUE</literal> if <parameter>type</parameter> is an interface type.
Interface types are types that provide pure APIs, the implementation
of which is provided by another type (which is then said to conform
to the interface).  GLib interfaces are somewhat analogous to Java
interfaces and C++ classes containing only pure virtual functions, 
with the difference that GType interfaces are not derivable (but see
<link linkend="g-type-interface-add-prerequisite"><function>g_type_interface_add_prerequisite()</function></link> for an alternative).
</para><variablelist role="params">
<varlistentry><term><parameter>type</parameter>&nbsp;:</term>
<listitem><simpara>A <link linkend="GType"><type>GType</type></link> value.


</simpara></listitem></varlistentry>
</variablelist></refsect2>
<refsect2>
<title><anchor id="GTypeInterface" role="struct"/>GTypeInterface</title>
<indexterm><primary>GTypeInterface</primary></indexterm><programlisting>typedef struct {
} GTypeInterface;
</programlisting>
<para>
An opaque structure used as the base of all interface types.
</para></refsect2>
<refsect2>
<title><anchor id="GTypeInstance" role="struct"/>GTypeInstance</title>
<indexterm><primary>GTypeInstance</primary></indexterm><programlisting>typedef struct {
} GTypeInstance;
</programlisting>
<para>
An opaque structure used as the base of all type instances.
</para></refsect2>
<refsect2>
<title><anchor id="GTypeClass" role="struct"/>GTypeClass</title>
<indexterm><primary>GTypeClass</primary></indexterm><programlisting>typedef struct {
} GTypeClass;
</programlisting>
<para>
An opaque structure used as the base of all classes.
</para></refsect2>
<refsect2>
<title><anchor id="GTypeInfo" role="struct"/>GTypeInfo</title>
<indexterm><primary>GTypeInfo</primary></indexterm><programlisting>typedef struct {
  /* interface types, classed types, instantiated types */
  guint16                class_size;
  
  GBaseInitFunc          base_init;
  GBaseFinalizeFunc      base_finalize;
  
  /* interface types, classed types, instantiated types */
  GClassInitFunc         class_init;
  GClassFinalizeFunc     class_finalize;
  gconstpointer          class_data;
  
  /* instantiated types */
  guint16                instance_size;
  guint16                n_preallocs;
  GInstanceInitFunc      instance_init;
  
  /* value handling */
  const GTypeValueTable	*value_table;
} GTypeInfo;
</programlisting>
<para>
This structure is used to provide the type system with the information
required to initialize and destruct (finalize) a type's class and
instances thereof.
The initialized structure is passed to the <link linkend="g-type-register-static"><function>g_type_register_static()</function></link> function
(or is copied into the provided <link linkend="GTypeInfo"><type>GTypeInfo</type></link> structure in the
<link linkend="g-type-plugin-complete-type-info"><function>g_type_plugin_complete_type_info()</function></link>). The type system will perform a deep
copy of this structure, so it's memory does not need to be persistent
across invocation of <link linkend="g-type-register-static"><function>g_type_register_static()</function></link>.
</para><variablelist role="struct">
<varlistentry>
<term><link linkend="guint16">guint16</link>&nbsp;<structfield>class_size</structfield>;</term>
<listitem><simpara>	 Size of the class structure (required for interface, classed and instantiatable types).
</simpara></listitem>
</varlistentry>
<varlistentry>
<term><link linkend="GBaseInitFunc">GBaseInitFunc</link>&nbsp;<structfield>base_init</structfield>;</term>
<listitem><simpara>	 Location of the base initialization function (optional).
</simpara></listitem>
</varlistentry>
<varlistentry>
<term><link linkend="GBaseFinalizeFunc">GBaseFinalizeFunc</link>&nbsp;<structfield>base_finalize</structfield>;</term>
<listitem><simpara> Location of the base finalization function (optional).
</simpara></listitem>
</varlistentry>
<varlistentry>
<term><link linkend="GClassInitFunc">GClassInitFunc</link>&nbsp;<structfield>class_init</structfield>;</term>
<listitem><simpara>	 Location of the class initialization function for
  classed and types. Location of the default vtable inititalization
  function for interface types. (optional) This function is used both
  to fill in virtual functions in the class or default vtable, and
  to do type-specific setup such as registering signals and object
  properties.
</simpara></listitem>
</varlistentry>
<varlistentry>
<term><link linkend="GClassFinalizeFunc">GClassFinalizeFunc</link>&nbsp;<structfield>class_finalize</structfield>;</term>
<listitem><simpara>Location of the class finalization function for
  classed and types. Location fo the default vtable finalization
  function for interface types. (optional)
</simpara></listitem>
</varlistentry>
<varlistentry>
<term><link linkend="gconstpointer">gconstpointer</link>&nbsp;<structfield>class_data</structfield>;</term>
<listitem><simpara>	 User-supplied data passed to the class init/finalize functions.
</simpara></listitem>
</varlistentry>
<varlistentry>
<term><link linkend="guint16">guint16</link>&nbsp;<structfield>instance_size</structfield>;</term>
<listitem><simpara> Size of the instance (object) structure (required for instantiatable types only).
</simpara></listitem>
</varlistentry>
<varlistentry>
<term><link linkend="guint16">guint16</link>&nbsp;<structfield>n_preallocs</structfield>;</term>
<listitem><simpara>	 Prior to GLib 2.10, it specified the number of pre-allocated (cached) instances to reserve memory for (0 indicates no caching). Since GLib 2.10, it is ignored, since instances are allocated with the <link linkend="glib-Memory-Slices">slice allocator</link> now.
</simpara></listitem>
</varlistentry>
<varlistentry>
<term><link linkend="GInstanceInitFunc">GInstanceInitFunc</link>&nbsp;<structfield>instance_init</structfield>;</term>
<listitem><simpara> Location of the instance initialization function (optional, for instantiatable types only).
</simpara></listitem>
</varlistentry>
<varlistentry>
<term>const&nbsp;<link linkend="GTypeValueTable">GTypeValueTable</link>&nbsp;*<structfield>value_table</structfield>;</term>
<listitem><simpara>	 A <link linkend="GTypeValueTable"><type>GTypeValueTable</type></link> function table for generic handling of GValues of this type (usually only
		 useful for fundamental types).

</simpara></listitem>
</varlistentry>
</variablelist></refsect2>
<refsect2>
<title><anchor id="GTypeFundamentalInfo" role="struct"/>GTypeFundamentalInfo</title>
<indexterm><primary>GTypeFundamentalInfo</primary></indexterm><programlisting>typedef struct {
  GTypeFundamentalFlags  type_flags;
} GTypeFundamentalInfo;
</programlisting>
<para>
A structure that provides information to the type system which is
used specifically for managing fundamental types.  
</para><variablelist role="struct">
<varlistentry>
<term><link linkend="GTypeFundamentalFlags">GTypeFundamentalFlags</link>&nbsp;<structfield>type_flags</structfield>;</term>
<listitem><simpara><link linkend="GTypeFundamentalFlags"><type>GTypeFundamentalFlags</type></link> describing the characteristics of the fundamental type

</simpara></listitem>
</varlistentry>
</variablelist></refsect2>
<refsect2>
<title><anchor id="GInterfaceInfo" role="struct"/>GInterfaceInfo</title>
<indexterm><primary>GInterfaceInfo</primary></indexterm><programlisting>typedef struct {
  GInterfaceInitFunc     interface_init;
  GInterfaceFinalizeFunc interface_finalize;
  gpointer               interface_data;
} GInterfaceInfo;
</programlisting>
<para>
A structure that provides information to the type system which is
used specifically for managing interface types.
</para><variablelist role="struct">
<varlistentry>
<term><link linkend="GInterfaceInitFunc">GInterfaceInitFunc</link>&nbsp;<structfield>interface_init</structfield>;</term>
<listitem><simpara>	Location of the function that initializes the interface.
</simpara></listitem>
</varlistentry>
<varlistentry>
<term><link linkend="GInterfaceFinalizeFunc">GInterfaceFinalizeFunc</link>&nbsp;<structfield>interface_finalize</structfield>;</term>
<listitem><simpara>	Location of the function that finalizes the interface.
</simpara></listitem>
</varlistentry>
<varlistentry>
<term><link linkend="gpointer">gpointer</link>&nbsp;<structfield>interface_data</structfield>;</term>
<listitem><simpara>	Location of user data passed to the <parameter>interface_init</parameter> and
	 		<parameter>interface_finalize</parameter> functions (optional).

</simpara></listitem>
</varlistentry>
</variablelist></refsect2>
<refsect2>
<title><anchor id="GTypeValueTable" role="struct"/>GTypeValueTable</title>
<indexterm><primary>GTypeValueTable</primary></indexterm><programlisting>typedef struct {
  void     (*value_init)         (GValue       *value);
  void     (*value_free)         (GValue       *value);
  void     (*value_copy)         (const GValue *src_value,
				  GValue       *dest_value);
  /* varargs functionality (optional) */
  gpointer (*value_peek_pointer) (const GValue *value);
  gchar	    *collect_format;
  gchar*   (*collect_value)      (GValue       *value,
				  guint         n_collect_values,
				  GTypeCValue  *collect_values,
				  guint		collect_flags);
  gchar	    *lcopy_format;
  gchar*   (*lcopy_value)        (const GValue *value,
				  guint         n_collect_values,
				  GTypeCValue  *collect_values,
				  guint		collect_flags);
} GTypeValueTable;
</programlisting>
<para>
The <link linkend="GTypeValueTable"><type>GTypeValueTable</type></link> provides the functions required by the <link linkend="GValue"><type>GValue</type></link> implementation,
to serve as a container for values of a type.
</para><variablelist role="struct">
<varlistentry>
<term><structfield>value_init</structfield>&nbsp;()</term>
<listitem><simpara>		Default initialize <parameter>values</parameter> contents by poking values
			directly into the value-&gt;data array. The data array of
			the <link linkend="GValue"><type>GValue</type></link> passed into this function was zero-filled
			with <function><link linkend="memset"><function>memset()</function></link></function>, so no care has to
                        be taken to free any
			old contents. E.g. for the implementation of a string
			value that may never be <literal>NULL</literal>, the implementation might
			look like:
<programlisting>
{
  value-&gt;data[0].v_pointer = g_strdup ("");
}
</programlisting>
</simpara></listitem>
</varlistentry>
<varlistentry>
<term><structfield>value_free</structfield>&nbsp;()</term>
<listitem><simpara>		Free any old contents that might be left in the
			data array of the passed in <parameter>value</parameter>. No resources may
			remain allocated through the <link linkend="GValue"><type>GValue</type></link> contents after
			this function returns. E.g. for our above string type:
<programlisting>
{
  /* only free strings without a specific flag for static storage */
  if (!(value-&gt;data[1].v_uint &amp; G_VALUE_NOCOPY_CONTENTS))
    g_free (value-&gt;data[0].v_pointer);
}
</programlisting>
</simpara></listitem>
</varlistentry>
<varlistentry>
<term><structfield>value_copy</structfield>&nbsp;()</term>
<listitem><simpara>		<parameter>dest_value</parameter> is a <link linkend="GValue"><type>GValue</type></link> with zero-filled data section
			and <parameter>src_value</parameter> is a properly setup <link linkend="GValue"><type>GValue</type></link> of same or
			derived type.
			The purpose of this function is to copy the contents of
			<parameter>src_value</parameter> into <parameter>dest_value</parameter> in a way, that even after
			<parameter>src_value</parameter> has been freed, the contents of <parameter>dest_value</parameter>
			remain valid. String type example:
<programlisting>
{
  dest_value-&gt;data[0].v_pointer = g_strdup (src_value-&gt;data[0].v_pointer);
}
</programlisting>
</simpara></listitem>
</varlistentry>
<varlistentry>
<term><structfield>value_peek_pointer</structfield>&nbsp;()</term>
<listitem><simpara>	If the value contents fit into a pointer, such as objects
			or strings, return this pointer, so the caller can peek at
			the current contents. To extend on our above string example:
<programlisting>
{
  return value-&gt;data[0].v_pointer;
}
</programlisting>
</simpara></listitem>
</varlistentry>
<varlistentry>
<term><link linkend="gchar">gchar</link>&nbsp;*<structfield>collect_format</structfield>;</term>
<listitem><simpara>	A string format describing how to collect the contents of
			this value, bit-by-bit. Each character in the format represents
			an argument to be collected, the characters themselves indicate
			the type of the argument. Currently supported arguments are:
<variablelist>
  <varlistentry><term></term><listitem><para>
        'i' - Integers. passed as collect_values[].v_int.
  </para></listitem></varlistentry>
  <varlistentry><term></term><listitem><para>
        'l' - Longs. passed as collect_values[].v_long.
  </para></listitem></varlistentry>
  <varlistentry><term></term><listitem><para>
        'd' - Doubles. passed as collect_values[].v_double.
  </para></listitem></varlistentry>
  <varlistentry><term></term><listitem><para>
        'p' - Pointers. passed as collect_values[].v_pointer.
  </para></listitem></varlistentry>
</variablelist>
			It should be noted, that for variable argument list construction,
			ANSI C promotes every type smaller than an integer to an int, and
			floats to doubles. So for collection of short int or char, 'i'
			needs to be used, and for collection of floats 'd'.
</simpara></listitem>
</varlistentry>
<varlistentry>
<term><structfield>collect_value</structfield>&nbsp;()</term>
<listitem><simpara>	The <link linkend="collect-value"><function>collect_value()</function></link> function is responsible for converting the
			values collected from a variable argument list into contents
			suitable for storage in a GValue. This function should setup
			<parameter>value</parameter> similar to <link linkend="value-init"><function>value_init()</function></link>, e.g. for a string value that
			does not allow <literal>NULL</literal> pointers, it needs to either spew an error,
			or do an implicit conversion by storing an empty string.
			The <parameter>value</parameter> passed in to this function has a zero-filled data
			array, so just like for <link linkend="value-init"><function>value_init()</function></link> it is guaranteed to not
			contain any old contents that might need freeing.
			<parameter>n_collect_values</parameter> is exactly the string length of <parameter>collect_format</parameter>,
			and <parameter>collect_values</parameter> is an array of unions <link linkend="GTypeCValue"><type>GTypeCValue</type></link> with
			length <parameter>n_collect_values</parameter>, containing the collected values
			according to <parameter>collect_format</parameter>.
			<parameter>collect_flags</parameter> is an argument provided as a hint by the caller,
			which may contain the flag <link linkend="G-VALUE-NOCOPY-CONTENTS:CAPS"><type>G_VALUE_NOCOPY_CONTENTS</type></link> indicating,
			that the collected value contents may be considered "static"
			for the duration of the <parameter>value</parameter> lifetime.
			Thus an extra copy of the contents stored in <parameter>collect_values</parameter> is
			not required for assignment to <parameter>value</parameter>.
			For our above string example, we continue with:
<programlisting>
{
  if (!collect_values[0].v_pointer)
    value->data[0].v_pointer = g_strdup ("");
  else if (collect_flags &amp; G_VALUE_NOCOPY_CONTENTS)
    {
      value-&gt;data[0].v_pointer = collect_values[0].v_pointer;
      /* keep a flag for the <link linkend="value-free"><function>value_free()</function></link> implementation to not free this string */
      value-&gt;data[1].v_uint = G_VALUE_NOCOPY_CONTENTS;
    }
  else
    value-&gt;data[0].v_pointer = g_strdup (collect_values[0].v_pointer);

  return NULL;
}
</programlisting>
			It should be noted, that it is generally a bad idea to follow the
			<link linkend="G-VALUE-NOCOPY-CONTENTS:CAPS"><type>G_VALUE_NOCOPY_CONTENTS</type></link> hint for reference counted types. Due to
			reentrancy requirements and reference count assertions performed
			by the <link linkend="GSignal"><type>GSignal</type></link> code, reference counts should always be incremented
			for reference counted contents stored in the value-&gt;data array.
			To deviate from our string example for a moment, and taking a look
			at an exemplary implementation for <link linkend="collect-value"><function>collect_value()</function></link> of <link linkend="GObject"><type>GObject</type></link>:
<programlisting>
{
  if (collect_values[0].v_pointer)
    {
      GObject *object = G_OBJECT (collect_values[0].v_pointer);

      /* never honour G_VALUE_NOCOPY_CONTENTS for ref-counted types */
      value-&gt;data[0].v_pointer = g_object_ref (object);
      return NULL;
    }
  else
    return g_strdup_printf ("Object passed as invalid NULL pointer");
}
</programlisting>
			The reference count for valid objects is always incremented,
			regardless of <parameter>collect_flags</parameter>. For invalid objects, the example
			returns a newly allocated string without altering <parameter>value</parameter>.
			Upon success, <link linkend="collect-value"><function>collect_value()</function></link> needs to return <literal>NULL</literal>, if however
			a malicious condition occurred, <link linkend="collect-value"><function>collect_value()</function></link> may spew an
			error by returning a newly allocated non-<literal>NULL</literal> string, giving
			a suitable description of the error condition.
			The calling code makes no assumptions about the <parameter>value</parameter>
			contents being valid upon error returns, <parameter>value</parameter>
			is simply thrown away without further freeing. As such, it is
			a good idea to not allocate <link linkend="GValue"><type>GValue</type></link> contents, prior to returning
			an error, however, <link linkend="collect-values"><function>collect_values()</function></link> is not obliged to return
			a correctly setup <parameter>value</parameter> for error returns, simply because
			any non-<literal>NULL</literal> return is considered a fatal condition so further
			program behaviour is undefined.
</simpara></listitem>
</varlistentry>
<varlistentry>
<term><link linkend="gchar">gchar</link>&nbsp;*<structfield>lcopy_format</structfield>;</term>
<listitem><simpara>		Format description of the arguments to collect for <parameter>lcopy_value</parameter>,
			analogous to <parameter>collect_format</parameter>. Usually, <parameter>lcopy_format</parameter> string consists
			only of 'p's to provide <link linkend="lcopy-value"><function>lcopy_value()</function></link> with pointers to storage locations.
</simpara></listitem>
</varlistentry>
<varlistentry>
<term><structfield>lcopy_value</structfield>&nbsp;()</term>
<listitem><simpara>		This function is responsible for storing the <parameter>value</parameter> contents into
			arguments passed through a variable argument list which got
			collected into <parameter>collect_values</parameter> according to <parameter>lcopy_format</parameter>.
			<parameter>n_collect_values</parameter> equals the string length of <parameter>lcopy_format</parameter>,
			and <parameter>collect_flags</parameter> may contain <link linkend="G-VALUE-NOCOPY-CONTENTS:CAPS"><type>G_VALUE_NOCOPY_CONTENTS</type></link>.
			In contrast to <link linkend="collect-value"><function>collect_value()</function></link>, <link linkend="lcopy-value"><function>lcopy_value()</function></link> is obliged to
			always properly support <link linkend="G-VALUE-NOCOPY-CONTENTS:CAPS"><type>G_VALUE_NOCOPY_CONTENTS</type></link>.
			Similar to <link linkend="collect-value"><function>collect_value()</function></link> the function may prematurely abort
			by returning a newly allocated string describing an error condition.
			To complete the string example:
<programlisting>
{
  gchar **string_p = collect_values[0].v_pointer;

  if (!string_p)
    return g_strdup_printf ("string location passed as NULL");

  if (collect_flags &amp; G_VALUE_NOCOPY_CONTENTS)
    *string_p = value-&gt;data[0].v_pointer;
  else
    *string_p = g_strdup (value-&gt;data[0].v_pointer);

}
</programlisting>
			And an exemplary version of <link linkend="lcopy-value"><function>lcopy_value()</function></link> for
			reference-counted types:
<programlisting>
{
  GObject **object_p = collect_values[0].v_pointer;

  if (!object_p)
    return g_strdup_printf ("object location passed as NULL");
  if (!value-&gt;data[0].v_pointer)
    *object_p = NULL;
  else if (collect_flags &amp; G_VALUE_NOCOPY_CONTENTS) /* always honour */
    *object_p = value-&gt;data[0].v_pointer;
  else
    *object_p = g_object_ref (value-&gt;data[0].v_pointer);
  return NULL;
}
</programlisting>

</simpara></listitem>
</varlistentry>
</variablelist></refsect2>
<refsect2>
<title><anchor id="G-TYPE-FROM-INSTANCE:CAPS" role="macro"/>G_TYPE_FROM_INSTANCE()</title>
<indexterm><primary>G_TYPE_FROM_INSTANCE</primary></indexterm><programlisting>#define G_TYPE_FROM_INSTANCE(instance)                          (G_TYPE_FROM_CLASS (((GTypeInstance*) (instance))-&gt;g_class))
</programlisting>
<para>
Returns the type identifier from a given <parameter>instance</parameter> structure. 
<para>
</para>
This macro should only be used in type implementations.
</para><variablelist role="params">
<varlistentry><term><parameter>instance</parameter>&nbsp;:</term>
<listitem><simpara>Location of a valid <link linkend="GTypeInstance"><type>GTypeInstance</type></link> structure.


</simpara></listitem></varlistentry>
</variablelist></refsect2>
<refsect2>
<title><anchor id="G-TYPE-FROM-CLASS:CAPS" role="macro"/>G_TYPE_FROM_CLASS()</title>
<indexterm><primary>G_TYPE_FROM_CLASS</primary></indexterm><programlisting>#define G_TYPE_FROM_CLASS(g_class)                              (((GTypeClass*) (g_class))-&gt;g_type)
</programlisting>
<para>
Returns the type identifier from a given <parameter>class</parameter> structure.
<para>
</para>
This macro should only be used in type implementations.
</para><variablelist role="params">
<varlistentry><term><parameter>g_class</parameter>&nbsp;:</term>
<listitem><simpara>Location of a valid <link linkend="GTypeClass"><type>GTypeClass</type></link> structure.


</simpara></listitem></varlistentry>
</variablelist></refsect2>
<refsect2>
<title><anchor id="G-TYPE-FROM-INTERFACE:CAPS" role="macro"/>G_TYPE_FROM_INTERFACE()</title>
<indexterm><primary>G_TYPE_FROM_INTERFACE</primary></indexterm><programlisting>#define G_TYPE_FROM_INTERFACE(g_iface)                          (((GTypeInterface*) (g_iface))-&gt;g_type)
</programlisting>
<para>
Returns the type identifier from a given <parameter>interface</parameter> structure.
<para>
</para>
This macro should only be used in type implementations.
</para><variablelist role="params">
<varlistentry><term><parameter>g_iface</parameter>&nbsp;:</term>
<listitem><simpara>Location of a valid <link linkend="GTypeInterface"><type>GTypeInterface</type></link> structure.


</simpara></listitem></varlistentry>
</variablelist></refsect2>
<refsect2>
<title><anchor id="G-TYPE-INSTANCE-GET-CLASS:CAPS" role="macro"/>G_TYPE_INSTANCE_GET_CLASS()</title>
<indexterm><primary>G_TYPE_INSTANCE_GET_CLASS</primary></indexterm><programlisting>#define G_TYPE_INSTANCE_GET_CLASS(instance, g_type, c_type)     (_G_TYPE_IGC ((instance), (g_type), c_type))
</programlisting>
<para>
Returns the class structure of a given <parameter>instance</parameter>, casted
to a specified ancestor type <parameter>g_type</parameter> of the instance.
</para>
<warning><para>Note
that while calling a <link linkend="GInstanceInitFunc"><function>GInstanceInitFunc()</function></link>, the class pointer gets
modified, so it might not always return the expected pointer.
</para></warning>
<para>
This macro should only be used in type implementations.
</para><variablelist role="params">
<varlistentry><term><parameter>instance</parameter>&nbsp;:</term>
<listitem><simpara>	Location of the <link linkend="GTypeInstance"><type>GTypeInstance</type></link> structure.
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>g_type</parameter>&nbsp;:</term>
<listitem><simpara>	The anchestor type of the class to be returned.
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>c_type</parameter>&nbsp;:</term>
<listitem><simpara>	The corresponding C type of <parameter>g_type</parameter>.


</simpara></listitem></varlistentry>
</variablelist></refsect2>
<refsect2>
<title><anchor id="G-TYPE-INSTANCE-GET-INTERFACE:CAPS" role="macro"/>G_TYPE_INSTANCE_GET_INTERFACE()</title>
<indexterm><primary>G_TYPE_INSTANCE_GET_INTERFACE</primary></indexterm><programlisting>#define G_TYPE_INSTANCE_GET_INTERFACE(instance, g_type, c_type) (_G_TYPE_IGI ((instance), (g_type), c_type))
</programlisting>
<para>
Returns the interface structure for interface <parameter>g_type</parameter> of a given <parameter>instance</parameter>.
<para>
</para>
This macro should only be used in type implementations.
</para><variablelist role="params">
<varlistentry><term><parameter>instance</parameter>&nbsp;:</term>
<listitem><simpara>Location of the <link linkend="GTypeInstance"><type>GTypeInstance</type></link> structure.
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>g_type</parameter>&nbsp;:</term>
<listitem><simpara>The interface type to be returned.
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>c_type</parameter>&nbsp;:</term>
<listitem><simpara>The corresponding C type of <parameter>g_type</parameter>.


</simpara></listitem></varlistentry>
</variablelist></refsect2>
<refsect2>
<title><anchor id="G-TYPE-INSTANCE-GET-PRIVATE:CAPS" role="macro"/>G_TYPE_INSTANCE_GET_PRIVATE()</title>
<indexterm><primary>G_TYPE_INSTANCE_GET_PRIVATE</primary></indexterm><programlisting>#define G_TYPE_INSTANCE_GET_PRIVATE(instance, g_type, c_type)   ((c_type*) g_type_instance_get_private ((GTypeInstance*) (instance), (g_type)))
</programlisting>
<para>
Gets the private structure for a particular type.
The private structure must have been registered in the
class_init function with <link linkend="g-type-class-add-private"><function>g_type_class_add_private()</function></link>.
</para>
<para>
This macro should only be used in type implementations.
</para><variablelist role="params">
<varlistentry><term><parameter>instance</parameter>&nbsp;:</term>
<listitem><simpara>the instance of a type deriving from <parameter>private_type</parameter>.
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>g_type</parameter>&nbsp;:</term>
<listitem><simpara>the type identifying which private data to retrieve.
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>c_type</parameter>&nbsp;:</term>
<listitem><simpara>The C type for the private structure.


</simpara></listitem></varlistentry>
</variablelist></refsect2>
<refsect2>
<title><anchor id="G-TYPE-CHECK-INSTANCE:CAPS" role="macro"/>G_TYPE_CHECK_INSTANCE()</title>
<indexterm><primary>G_TYPE_CHECK_INSTANCE</primary></indexterm><programlisting>#define G_TYPE_CHECK_INSTANCE(instance)				(_G_TYPE_CHI ((GTypeInstance*) (instance)))
</programlisting>
<para>
Returns <literal>TRUE</literal> if <parameter>instance</parameter> is a valid <link linkend="GTypeInstance"><type>GTypeInstance</type></link> structure,
otherwise emits a warning and returns <literal>FALSE</literal>.
<para>
</para>
This macro should only be used in type implementations.
</para><variablelist role="params">
<varlistentry><term><parameter>instance</parameter>&nbsp;:</term>
<listitem><simpara>Location of a <link linkend="GTypeInstance"><type>GTypeInstance</type></link> structure.


</simpara></listitem></varlistentry>
</variablelist></refsect2>
<refsect2>
<title><anchor id="G-TYPE-CHECK-INSTANCE-CAST:CAPS" role="macro"/>G_TYPE_CHECK_INSTANCE_CAST()</title>
<indexterm><primary>G_TYPE_CHECK_INSTANCE_CAST</primary></indexterm><programlisting>#define G_TYPE_CHECK_INSTANCE_CAST(instance, g_type, c_type)    (_G_TYPE_CIC ((instance), (g_type), c_type))
</programlisting>
<para>
Checks that <parameter>instance</parameter> is an instance of the type identified by <parameter>g_type</parameter>
and emits a warning if this is not the case. Returns <parameter>instance</parameter> casted 
to a pointer to <parameter>c_type</parameter>.
</para>
<para>
This macro should only be used in type implementations.
</para><variablelist role="params">
<varlistentry><term><parameter>instance</parameter>&nbsp;:</term>
<listitem><simpara>Location of a <link linkend="GTypeInstance"><type>GTypeInstance</type></link> structure.
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>g_type</parameter>&nbsp;:</term>
<listitem><simpara>The type to be returned.
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>c_type</parameter>&nbsp;:</term>
<listitem><simpara>The corresponding C type of <parameter>g_type</parameter>.


</simpara></listitem></varlistentry>
</variablelist></refsect2>
<refsect2>
<title><anchor id="G-TYPE-CHECK-INSTANCE-TYPE:CAPS" role="macro"/>G_TYPE_CHECK_INSTANCE_TYPE()</title>
<indexterm><primary>G_TYPE_CHECK_INSTANCE_TYPE</primary></indexterm><programlisting>#define G_TYPE_CHECK_INSTANCE_TYPE(instance, g_type)            (_G_TYPE_CIT ((instance), (g_type)))
</programlisting>
<para>
Returns <literal>TRUE</literal> if <parameter>instance</parameter> is an instance of the type identified by <parameter>g_type</parameter>.
Otherwise emits a warning and returns <literal>FALSE</literal>.
</para>
<para>
This macro should only be used in type implementations.
</para><variablelist role="params">
<varlistentry><term><parameter>instance</parameter>&nbsp;:</term>
<listitem><simpara>Location of a <link linkend="GTypeInstance"><type>GTypeInstance</type></link> structure.
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>g_type</parameter>&nbsp;:</term>
<listitem><simpara>The type to be checked


</simpara></listitem></varlistentry>
</variablelist></refsect2>
<refsect2>
<title><anchor id="G-TYPE-CHECK-CLASS-CAST:CAPS" role="macro"/>G_TYPE_CHECK_CLASS_CAST()</title>
<indexterm><primary>G_TYPE_CHECK_CLASS_CAST</primary></indexterm><programlisting>#define G_TYPE_CHECK_CLASS_CAST(g_class, g_type, c_type)        (_G_TYPE_CCC ((g_class), (g_type), c_type))
</programlisting>
<para>
Checks that <parameter>g_class</parameter> is a class structure of the type identified by <parameter>g_type</parameter>
and emits a warning if this is not the case. Returns <parameter>g_class</parameter> casted 
to a pointer to <parameter>c_type</parameter>.
</para>
<para>
This macro should only be used in type implementations.
</para><variablelist role="params">
<varlistentry><term><parameter>g_class</parameter>&nbsp;:</term>
<listitem><simpara>Location of a <link linkend="GTypeClass"><type>GTypeClass</type></link> structure.
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>g_type</parameter>&nbsp;:</term>
<listitem><simpara>The type to be returned.
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>c_type</parameter>&nbsp;:</term>
<listitem><simpara>The corresponding C type of class structure of <parameter>g_type</parameter>.


</simpara></listitem></varlistentry>
</variablelist></refsect2>
<refsect2>
<title><anchor id="G-TYPE-CHECK-CLASS-TYPE:CAPS" role="macro"/>G_TYPE_CHECK_CLASS_TYPE()</title>
<indexterm><primary>G_TYPE_CHECK_CLASS_TYPE</primary></indexterm><programlisting>#define G_TYPE_CHECK_CLASS_TYPE(g_class, g_type)                (_G_TYPE_CCT ((g_class), (g_type)))
</programlisting>
<para>
Returns <literal>TRUE</literal> if <parameter>g_class</parameter> is a class structure of the type identified by 
<parameter>g_type</parameter>. Otherwise emits a warning and returns <literal>FALSE</literal>.
</para>
<para>
This macro should only be used in type implementations.
</para><variablelist role="params">
<varlistentry><term><parameter>g_class</parameter>&nbsp;:</term>
<listitem><simpara>Location of a <link linkend="GTypeClass"><type>GTypeClass</type></link> structure.
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>g_type</parameter>&nbsp;:</term>
<listitem><simpara>The type to be checked.


</simpara></listitem></varlistentry>
</variablelist></refsect2>
<refsect2>
<title><anchor id="G-TYPE-CHECK-VALUE:CAPS" role="macro"/>G_TYPE_CHECK_VALUE()</title>
<indexterm><primary>G_TYPE_CHECK_VALUE</primary></indexterm><programlisting>#define G_TYPE_CHECK_VALUE(value)				(_G_TYPE_CHV ((value)))
</programlisting>
<para>
Returns <literal>TRUE</literal> if <parameter>value</parameter> has been initialized to hold values
of a value type.
</para>
<para>
This macro should only be used in type implementations.
</para><variablelist role="params">
<varlistentry><term><parameter>value</parameter>&nbsp;:</term>
<listitem><simpara>a <link linkend="GValue"><type>GValue</type></link>


</simpara></listitem></varlistentry>
</variablelist></refsect2>
<refsect2>
<title><anchor id="G-TYPE-CHECK-VALUE-TYPE:CAPS" role="macro"/>G_TYPE_CHECK_VALUE_TYPE()</title>
<indexterm><primary>G_TYPE_CHECK_VALUE_TYPE</primary></indexterm><programlisting>#define G_TYPE_CHECK_VALUE_TYPE(value, g_type)			(_G_TYPE_CVH ((value), (g_type)))
</programlisting>
<para>
Returns <literal>TRUE</literal> if <parameter>value</parameter> has been initialized to hold values
of type <parameter>g_type</parameter>. 
</para>
<para>
This macro should only be used in type implementations.
</para><variablelist role="params">
<varlistentry><term><parameter>value</parameter>&nbsp;:</term>
<listitem><simpara>a <link linkend="GValue"><type>GValue</type></link>
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>g_type</parameter>&nbsp;:</term>
<listitem><simpara>The type to be checked.


</simpara></listitem></varlistentry>
</variablelist></refsect2>
<refsect2>
<title><anchor id="G-TYPE-FLAG-RESERVED-ID-BIT:CAPS" role="macro"/>G_TYPE_FLAG_RESERVED_ID_BIT</title>
<indexterm><primary>G_TYPE_FLAG_RESERVED_ID_BIT</primary></indexterm><programlisting>#define	G_TYPE_FLAG_RESERVED_ID_BIT	((GType) (1 &lt;&lt; 0))
</programlisting>
<para>
A bit in the type number that's supposed to be left untouched.
</para></refsect2>
<refsect2>
<title><anchor id="g-type-init" role="function"/>g_type_init ()</title>
<indexterm><primary>g_type_init</primary></indexterm><programlisting><link linkend="void">void</link>        g_type_init                     (void);</programlisting>
<para>
Prior to any use of the type system, <link linkend="g-type-init"><function>g_type_init()</function></link> has to be called to initialize
the type system and assorted other code portions (such as the various fundamental
type implementations or the signal system).
</para></refsect2>
<refsect2>
<title><anchor id="GTypeDebugFlags" role="enum"/>enum GTypeDebugFlags</title>
<indexterm><primary>GTypeDebugFlags</primary></indexterm><programlisting>typedef enum	/*&lt; skip &gt;*/
{
  G_TYPE_DEBUG_NONE	= 0,
  G_TYPE_DEBUG_OBJECTS	= 1 &lt;&lt; 0,
  G_TYPE_DEBUG_SIGNALS	= 1 &lt;&lt; 1,
  G_TYPE_DEBUG_MASK	= 0x03
} GTypeDebugFlags;
</programlisting>
<para>
The <type>GTypeDebugFlags</type> enumeration values can be passed to
<link linkend="g-type-init-with-debug-flags"><function>g_type_init_with_debug_flags()</function></link> to trigger debugging messages during runtime.
Note that the messages can also be triggered by setting the
<envar>GOBJECT_DEBUG</envar> environment variable to a ':'-separated list of 
"objects" and "signals".

</para><variablelist role="enum">
<varlistentry>
<term><literal>G_TYPE_DEBUG_NONE</literal></term>
<listitem><simpara>Print no messages.
</simpara></listitem>
</varlistentry>
<varlistentry>
<term><literal>G_TYPE_DEBUG_OBJECTS</literal></term>
<listitem><simpara>Print messages about object bookkeeping.
</simpara></listitem>
</varlistentry>
<varlistentry>
<term><literal>G_TYPE_DEBUG_SIGNALS</literal></term>
<listitem><simpara>Print messages about signal emissions.
</simpara></listitem>
</varlistentry>
<varlistentry>
<term><literal>G_TYPE_DEBUG_MASK</literal></term>
<listitem><simpara>Mask covering all debug flags.

</simpara></listitem>
</varlistentry>
</variablelist></refsect2>
<refsect2>
<title><anchor id="g-type-init-with-debug-flags" role="function"/>g_type_init_with_debug_flags ()</title>
<indexterm><primary>g_type_init_with_debug_flags</primary></indexterm><programlisting><link linkend="void">void</link>        g_type_init_with_debug_flags    (<link linkend="GTypeDebugFlags">GTypeDebugFlags</link> debug_flags);</programlisting>
<para>
Similar to <link linkend="g-type-init"><function>g_type_init()</function></link>, but additionally sets debug flags.
</para><variablelist role="params">
<varlistentry><term><parameter>debug_flags</parameter>&nbsp;:</term>
<listitem><simpara>Bitwise combination of <link linkend="GTypeDebugFlags"><type>GTypeDebugFlags</type></link> values for debugging purposes.


</simpara></listitem></varlistentry>
</variablelist></refsect2>
<refsect2>
<title><anchor id="g-type-name" role="function"/>g_type_name ()</title>
<indexterm><primary>g_type_name</primary></indexterm><programlisting>const <link linkend="gchar">gchar</link>* g_type_name                    (<link linkend="GType">GType</link> type);</programlisting>
<para>
Returns the unique name that is assigned to a type ID (this is the preferred method
to find out whether a specific type has been registered for the passed in ID yet).
</para><variablelist role="params">
<varlistentry><term><parameter>type</parameter>&nbsp;:</term>
<listitem><simpara>		Type to return name for.
</simpara></listitem></varlistentry>
<varlistentry><term><emphasis>Returns</emphasis>&nbsp;:</term><listitem><simpara>	Static type name or <literal>NULL</literal>.


</simpara></listitem></varlistentry>
</variablelist></refsect2>
<refsect2>
<title><anchor id="g-type-qname" role="function"/>g_type_qname ()</title>
<indexterm><primary>g_type_qname</primary></indexterm><programlisting><link linkend="GQuark">GQuark</link>      g_type_qname                    (<link linkend="GType">GType</link> type);</programlisting>
<para>
Return the corresponding quark of the type IDs name.
</para><variablelist role="params">
<varlistentry><term><parameter>type</parameter>&nbsp;:</term>
<listitem><simpara>   Type to return quark of type name for.
</simpara></listitem></varlistentry>
<varlistentry><term><emphasis>Returns</emphasis>&nbsp;:</term><listitem><simpara>The type names quark or 0.


</simpara></listitem></varlistentry>
</variablelist></refsect2>
<refsect2>
<title><anchor id="g-type-from-name" role="function"/>g_type_from_name ()</title>
<indexterm><primary>g_type_from_name</primary></indexterm><programlisting><link linkend="GType">GType</link>       g_type_from_name                (const <link linkend="gchar">gchar</link> *name);</programlisting>
<para>
Lookup the type ID from a given type name, returns 0 if no type has been registered under this name
(this is the preferred method to find out by name whether a specific type has been registered yet).
</para><variablelist role="params">
<varlistentry><term><parameter>name</parameter>&nbsp;:</term>
<listitem><simpara>   Type name to lookup.
</simpara></listitem></varlistentry>
<varlistentry><term><emphasis>Returns</emphasis>&nbsp;:</term><listitem><simpara>Corresponding type ID or 0.


</simpara></listitem></varlistentry>
</variablelist></refsect2>
<refsect2>
<title><anchor id="g-type-parent" role="function"/>g_type_parent ()</title>
<indexterm><primary>g_type_parent</primary></indexterm><programlisting><link linkend="GType">GType</link>       g_type_parent                   (<link linkend="GType">GType</link> type);</programlisting>
<para>
Return the direct parent type of the passed in type.
If the passed in type has no parent, i.e. is a fundamental type, 0 is returned.
</para><variablelist role="params">
<varlistentry><term><parameter>type</parameter>&nbsp;:</term>
<listitem><simpara>   The derived type.
</simpara></listitem></varlistentry>
<varlistentry><term><emphasis>Returns</emphasis>&nbsp;:</term><listitem><simpara>The parent type.


</simpara></listitem></varlistentry>
</variablelist></refsect2>
<refsect2>
<title><anchor id="g-type-depth" role="function"/>g_type_depth ()</title>
<indexterm><primary>g_type_depth</primary></indexterm><programlisting><link linkend="guint">guint</link>       g_type_depth                    (<link linkend="GType">GType</link> type);</programlisting>
<para>
Returns the length of the ancestry of the passed in type. This includes the
type itself, so that e.g. a fundamental type has depth 1.
</para><variablelist role="params">
<varlistentry><term><parameter>type</parameter>&nbsp;:</term>
<listitem><simpara>   A <link linkend="GType"><type>GType</type></link> value.
</simpara></listitem></varlistentry>
<varlistentry><term><emphasis>Returns</emphasis>&nbsp;:</term><listitem><simpara>The depth of <parameter>type</parameter>.


</simpara></listitem></varlistentry>
</variablelist></refsect2>
<refsect2>
<title><anchor id="g-type-next-base" role="function"/>g_type_next_base ()</title>
<indexterm><primary>g_type_next_base</primary></indexterm><programlisting><link linkend="GType">GType</link>       g_type_next_base                (<link linkend="GType">GType</link> leaf_type,
                                             <link linkend="GType">GType</link> root_type);</programlisting>
<para>
Given a <parameter>leaf_type</parameter> and a <parameter>root_type</parameter> which is contained in its anchestry, return
the type that <parameter>root_type</parameter> is the immediate parent of.
In other words, this function determines the type that is derived directly from
<parameter>root_type</parameter> which is also a base class of <parameter>leaf_type</parameter>.  Given a root type and a
leaf type, this function can be used to determine the types and order in which
the leaf type is descended from the root type.
</para><variablelist role="params">
<varlistentry><term><parameter>leaf_type</parameter>&nbsp;:</term>
<listitem><simpara>	Descendant of <parameter>root_type</parameter> and the type to be returned.
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>root_type</parameter>&nbsp;:</term>
<listitem><simpara>	Immediate parent of the returned type.
</simpara></listitem></varlistentry>
<varlistentry><term><emphasis>Returns</emphasis>&nbsp;:</term><listitem><simpara>	Immediate child of <parameter>root_type</parameter> and anchestor of <parameter>leaf_type</parameter>.


</simpara></listitem></varlistentry>
</variablelist></refsect2>
<refsect2>
<title><anchor id="g-type-is-a" role="function"/>g_type_is_a ()</title>
<indexterm><primary>g_type_is_a</primary></indexterm><programlisting><link linkend="gboolean">gboolean</link>    g_type_is_a                     (<link linkend="GType">GType</link> type,
                                             <link linkend="GType">GType</link> is_a_type);</programlisting>
<para>
If <parameter>is_a_type</parameter> is a derivable type, check whether <parameter>type</parameter> is a descendant of <parameter>is_a_type</parameter>.
If <parameter>is_a_type</parameter> is an interface, check whether <parameter>type</parameter> conforms to it.
</para><variablelist role="params">
<varlistentry><term><parameter>type</parameter>&nbsp;:</term>
<listitem><simpara>     Type to check anchestry for.
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>is_a_type</parameter>&nbsp;:</term>
<listitem><simpara>Possible anchestor of <parameter>type</parameter> or interface <parameter>type</parameter> could conform to.
</simpara></listitem></varlistentry>
<varlistentry><term><emphasis>Returns</emphasis>&nbsp;:</term><listitem><simpara>  <literal>TRUE</literal> if <parameter>type</parameter> is_a <parameter>is_a_type</parameter> holds true.


</simpara></listitem></varlistentry>
</variablelist></refsect2>
<refsect2>
<title><anchor id="g-type-class-ref" role="function"/>g_type_class_ref ()</title>
<indexterm><primary>g_type_class_ref</primary></indexterm><programlisting><link linkend="gpointer">gpointer</link>    g_type_class_ref                (<link linkend="GType">GType</link> type);</programlisting>
<para>
Increments the reference count of the class structure belonging to
<parameter>type</parameter>. This function will demand-create the class if it doesn't
exist already.
</para><variablelist role="params">
<varlistentry><term><parameter>type</parameter>&nbsp;:</term>
<listitem><simpara>	  Type ID of a classed type.
</simpara></listitem></varlistentry>
<varlistentry><term><emphasis>Returns</emphasis>&nbsp;:</term><listitem><simpara>The <link linkend="GTypeClass"><type>GTypeClass</type></link> structure for the given type ID.


</simpara></listitem></varlistentry>
</variablelist></refsect2>
<refsect2>
<title><anchor id="g-type-class-peek" role="function"/>g_type_class_peek ()</title>
<indexterm><primary>g_type_class_peek</primary></indexterm><programlisting><link linkend="gpointer">gpointer</link>    g_type_class_peek               (<link linkend="GType">GType</link> type);</programlisting>
<para>
This function is essentially the same as <link linkend="g-type-class-ref"><function>g_type_class_ref()</function></link>, except that
the classes reference count isn't incremented. Therefore, this function
may return <literal>NULL</literal> if the class of the type passed in does not currently
exist (hasn't been referenced before).
</para><variablelist role="params">
<varlistentry><term><parameter>type</parameter>&nbsp;:</term>
<listitem><simpara>		Type ID of a classed type.
</simpara></listitem></varlistentry>
<varlistentry><term><emphasis>Returns</emphasis>&nbsp;:</term><listitem><simpara>	The <link linkend="GTypeClass"><type>GTypeClass</type></link> structure for the given type ID or <literal>NULL</literal>
		if the class does not currently exist.


</simpara></listitem></varlistentry>
</variablelist></refsect2>
<refsect2>
<title><anchor id="g-type-class-peek-static" role="function" condition="since:2.4"/>g_type_class_peek_static ()</title>
<indexterm role="2.4"><primary>g_type_class_peek_static</primary></indexterm><programlisting><link linkend="gpointer">gpointer</link>    g_type_class_peek_static        (<link linkend="GType">GType</link> type);</programlisting>
<para>
A more efficient version of <link linkend="g-type-class-peek"><function>g_type_class_peek()</function></link> which works only for
static types.
</para><variablelist role="params">
<varlistentry><term><parameter>type</parameter>&nbsp;:</term>
<listitem><simpara>Type ID of a classed type.
</simpara></listitem></varlistentry>
<varlistentry><term><emphasis>Returns</emphasis>&nbsp;:</term><listitem><simpara>The <link linkend="GTypeClass"><type>GTypeClass</type></link> structure for the given type ID or <literal>NULL</literal>
   if the class does not currently exist or is dynamically loaded.
</simpara></listitem></varlistentry>
</variablelist><para>Since 2.4


</para></refsect2>
<refsect2>
<title><anchor id="g-type-class-unref" role="function"/>g_type_class_unref ()</title>
<indexterm><primary>g_type_class_unref</primary></indexterm><programlisting><link linkend="void">void</link>        g_type_class_unref              (<link linkend="gpointer">gpointer</link> g_class);</programlisting>
<para>
Decrements the reference count of the class structure being passed in.
Once the last reference count of a class has been released, classes
may be finalized by the type system, so further dereferencing of a
class pointer after <link linkend="g-type-class-unref"><function>g_type_class_unref()</function></link> are invalid.
</para><variablelist role="params">
<varlistentry><term><parameter>g_class</parameter>&nbsp;:</term>
<listitem><simpara>	The <link linkend="GTypeClass"><type>GTypeClass</type></link> structure to unreference.


</simpara></listitem></varlistentry>
</variablelist></refsect2>
<refsect2>
<title><anchor id="g-type-class-peek-parent" role="function"/>g_type_class_peek_parent ()</title>
<indexterm><primary>g_type_class_peek_parent</primary></indexterm><programlisting><link linkend="gpointer">gpointer</link>    g_type_class_peek_parent        (<link linkend="gpointer">gpointer</link> g_class);</programlisting>
<para>
This is a convenience function, often needed in class initializers.
It essentially takes the immediate parent type of the class passed in,
and returns the class structure thereof. Since derived classes hold
a reference count on their parent classes as long as they are instantiated,
the returned class will always exist. This function is essentially
equivalent to:

<programlisting>
g_type_class_peek (g_type_parent (G_TYPE_FROM_CLASS (g_class)));
</programlisting>

</para><variablelist role="params">
<varlistentry><term><parameter>g_class</parameter>&nbsp;:</term>
<listitem><simpara>The <link linkend="GTypeClass"><type>GTypeClass</type></link> structure to retrieve the parent class for.
</simpara></listitem></varlistentry>
<varlistentry><term><emphasis>Returns</emphasis>&nbsp;:</term><listitem><simpara>The parent class of <parameter>g_class</parameter>.


</simpara></listitem></varlistentry>
</variablelist></refsect2>
<refsect2>
<title><anchor id="g-type-class-add-private" role="function"/>g_type_class_add_private ()</title>
<indexterm><primary>g_type_class_add_private</primary></indexterm><programlisting><link linkend="void">void</link>        g_type_class_add_private        (<link linkend="gpointer">gpointer</link> g_class,
                                             <link linkend="gsize">gsize</link> private_size);</programlisting>
<para>
Registers a private structure for a instantiatable type;
when an object is allocated, the private structures for
the type and and all of its parent types are allocated
sequentially in the same memory block as the public
structures. This function should be called in the
type's <link linkend="class-init"><function>class_init()</function></link> function. The private structure can
be retrieved using the <link linkend="G-TYPE-INSTANCE-GET-PRIVATE:CAPS"><function>G_TYPE_INSTANCE_GET_PRIVATE()</function></link> macro.
The following example shows attaching a private structure
<structname>MyObjectPrivate</structname> to an object
<structname>MyObject</structname> defined in the standard GObject
fashion.
</para>
<programlisting>
typedef struct _MyObjectPrivate MyObjectPrivate;

struct _MyObjectPrivate {
  int some_field;
};

&num;define MY_OBJECT_GET_PRIVATE(o)  \
   (G_TYPE_INSTANCE_GET_PRIVATE ((o), MY_TYPE_OBJECT, MyObjectPrivate))

static void
my_object_class_init (MyObjectClass *klass)
{
  g_type_class_add_private (klass, sizeof (MyObjectPrivate));
}

static int
my_object_get_some_field (MyObject *my_object)
{
  MyObjectPrivate *priv = MY_OBJECT_GET_PRIVATE (my_object);

  return priv->some_field;
}
</programlisting><variablelist role="params">
<varlistentry><term><parameter>g_class</parameter>&nbsp;:</term>
<listitem><simpara>class structure for an instantiatable type
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>private_size</parameter>&nbsp;:</term>
<listitem><simpara>size of private structure.


</simpara></listitem></varlistentry>
</variablelist></refsect2>
<refsect2>
<title><anchor id="g-type-interface-peek" role="function"/>g_type_interface_peek ()</title>
<indexterm><primary>g_type_interface_peek</primary></indexterm><programlisting><link linkend="gpointer">gpointer</link>    g_type_interface_peek           (<link linkend="gpointer">gpointer</link> instance_class,
                                             <link linkend="GType">GType</link> iface_type);</programlisting>
<para>
Returns the <link linkend="GTypeInterface"><type>GTypeInterface</type></link> structure of an interface to which the passed in 
class conforms.
</para><variablelist role="params">
<varlistentry><term><parameter>instance_class</parameter>&nbsp;:</term>
<listitem><simpara>A <link linkend="GTypeClass"><type>GTypeClass</type></link> structure.
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>iface_type</parameter>&nbsp;:</term>
<listitem><simpara>    An interface ID which this class conforms to.
</simpara></listitem></varlistentry>
<varlistentry><term><emphasis>Returns</emphasis>&nbsp;:</term><listitem><simpara>       The <link linkend="GTypeInterface"><type>GTypeInterface</type></link> structure of <parameter>iface_type</parameter>, or <literal>NULL</literal> if the
                 class is not instantiated.


</simpara></listitem></varlistentry>
</variablelist></refsect2>
<refsect2>
<title><anchor id="g-type-interface-peek-parent" role="function"/>g_type_interface_peek_parent ()</title>
<indexterm><primary>g_type_interface_peek_parent</primary></indexterm><programlisting><link linkend="gpointer">gpointer</link>    g_type_interface_peek_parent    (<link linkend="gpointer">gpointer</link> g_iface);</programlisting>
<para>
Returns the corresponding <link linkend="GTypeInterface"><type>GTypeInterface</type></link> structure of the parent type
of the instance type to which <parameter>g_iface</parameter> belongs. This is useful when 
deriving the implementation of an interface from the parent type and 
then possibly overriding some methods. 
</para><variablelist role="params">
<varlistentry><term><parameter>g_iface</parameter>&nbsp;:</term>
<listitem><simpara>A <link linkend="GTypeInterface"><type>GTypeInterface</type></link> structure.
</simpara></listitem></varlistentry>
<varlistentry><term><emphasis>Returns</emphasis>&nbsp;:</term><listitem><simpara>The corresponding <link linkend="GTypeInterface"><type>GTypeInterface</type></link> structure of the parent type
   of the instance type to which <parameter>g_iface</parameter> belongs, or <literal>NULL</literal> if the parent type
   doesn't conform to the interface.


</simpara></listitem></varlistentry>
</variablelist></refsect2>
<refsect2>
<title><anchor id="g-type-default-interface-ref" role="function" condition="since:2.4"/>g_type_default_interface_ref ()</title>
<indexterm role="2.4"><primary>g_type_default_interface_ref</primary></indexterm><programlisting><link linkend="gpointer">gpointer</link>    g_type_default_interface_ref    (<link linkend="GType">GType</link> g_type);</programlisting>
<para>
Increments the reference count for the interface type <parameter>g_type</parameter>,
and returns the default interface vtable for the type.
</para>
<para>  
If the type is not currently in use, then the default vtable
for the type will be created and initalized by calling
the base interface init and default vtable init functions for
the type (the @<structfield>base_init</structfield>
and <structfield>class_init</structfield> members of <link linkend="GTypeInfo"><type>GTypeInfo</type></link>).
Calling <link linkend="g-type-default-interface-ref"><function>g_type_default_interface_ref()</function></link> is useful when you
want to make sure that signals and properties for an interface
have been installed.
</para><variablelist role="params">
<varlistentry><term><parameter>g_type</parameter>&nbsp;:</term>
<listitem><simpara>an interface type
</simpara></listitem></varlistentry>
<varlistentry><term><emphasis>Returns</emphasis>&nbsp;:</term><listitem><simpara>the default vtable for the interface; call 
 <link linkend="g-type-default-interface-unref"><function>g_type_default_interface_unref()</function></link> when you are done using
 the interface.
</simpara></listitem></varlistentry>
</variablelist><para>Since 2.4


</para></refsect2>
<refsect2>
<title><anchor id="g-type-default-interface-peek" role="function" condition="since:2.4"/>g_type_default_interface_peek ()</title>
<indexterm role="2.4"><primary>g_type_default_interface_peek</primary></indexterm><programlisting><link linkend="gpointer">gpointer</link>    g_type_default_interface_peek   (<link linkend="GType">GType</link> g_type);</programlisting>
<para>
If the interface type <parameter>g_type</parameter> is currently in use, returns
its default interface vtable.    
</para><variablelist role="params">
<varlistentry><term><parameter>g_type</parameter>&nbsp;:</term>
<listitem><simpara>an interface type
</simpara></listitem></varlistentry>
<varlistentry><term><emphasis>Returns</emphasis>&nbsp;:</term><listitem><simpara>the default vtable for the interface; or <literal>NULL</literal>
 if the type is not currently in use.
</simpara></listitem></varlistentry>
</variablelist><para>Since 2.4


</para></refsect2>
<refsect2>
<title><anchor id="g-type-default-interface-unref" role="function" condition="since:2.4"/>g_type_default_interface_unref ()</title>
<indexterm role="2.4"><primary>g_type_default_interface_unref</primary></indexterm><programlisting><link linkend="void">void</link>        g_type_default_interface_unref  (<link linkend="gpointer">gpointer</link> g_iface);</programlisting>
<para>
Decrements the reference count for the type corresponding to the
interface default vtable <parameter>g_iface</parameter>. If the type is dynamic, then
when no one is using the interface and all references have
been released, the finalize function for the interface's default
vtable (the <structfield>class_finalize</structfield> member of
<link linkend="GTypeInfo"><type>GTypeInfo</type></link>) will be called.
</para><variablelist role="params">
<varlistentry><term><parameter>g_iface</parameter>&nbsp;:</term>
<listitem><simpara>the default vtable structure for a interface, as
  returned by <link linkend="g-type-default-interface-ref"><function>g_type_default_interface_ref()</function></link>
</simpara></listitem></varlistentry>
</variablelist><para>Since 2.4


</para></refsect2>
<refsect2>
<title><anchor id="g-type-children" role="function"/>g_type_children ()</title>
<indexterm><primary>g_type_children</primary></indexterm><programlisting><link linkend="GType">GType</link>*      g_type_children                 (<link linkend="GType">GType</link> type,
                                             <link linkend="guint">guint</link> *n_children);</programlisting>
<para>
Return a newly allocated and 0-terminated array of type IDs, listing the
child types of <parameter>type</parameter>. The return value has to be <link linkend="g-free"><function>g_free()</function></link>ed after use.
</para><variablelist role="params">
<varlistentry><term><parameter>type</parameter>&nbsp;:</term>
<listitem><simpara>      The parent type.
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>n_children</parameter>&nbsp;:</term>
<listitem><simpara>Optional <link linkend="guint"><type>guint</type></link> pointer to contain the number of child types.
</simpara></listitem></varlistentry>
<varlistentry><term><emphasis>Returns</emphasis>&nbsp;:</term><listitem><simpara>   Newly allocated and 0-terminated array of child types.


</simpara></listitem></varlistentry>
</variablelist></refsect2>
<refsect2>
<title><anchor id="g-type-interfaces" role="function"/>g_type_interfaces ()</title>
<indexterm><primary>g_type_interfaces</primary></indexterm><programlisting><link linkend="GType">GType</link>*      g_type_interfaces               (<link linkend="GType">GType</link> type,
                                             <link linkend="guint">guint</link> *n_interfaces);</programlisting>
<para>
Return a newly allocated and 0-terminated array of type IDs, listing the
interface types that <parameter>type</parameter> conforms to. The return value has to be
<link linkend="g-free"><function>g_free()</function></link>ed after use.
</para><variablelist role="params">
<varlistentry><term><parameter>type</parameter>&nbsp;:</term>
<listitem><simpara>        The type to list interface types for.
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>n_interfaces</parameter>&nbsp;:</term>
<listitem><simpara>Optional <link linkend="guint"><type>guint</type></link> pointer to contain the number of interface types.
</simpara></listitem></varlistentry>
<varlistentry><term><emphasis>Returns</emphasis>&nbsp;:</term><listitem><simpara>     Newly allocated and 0-terminated array of interface types.


</simpara></listitem></varlistentry>
</variablelist></refsect2>
<refsect2>
<title><anchor id="g-type-interface-prerequisites" role="function" condition="since:2.2"/>g_type_interface_prerequisites ()</title>
<indexterm role="2.2"><primary>g_type_interface_prerequisites</primary></indexterm><programlisting><link linkend="GType">GType</link>*      g_type_interface_prerequisites  (<link linkend="GType">GType</link> interface_type,
                                             <link linkend="guint">guint</link> *n_prerequisites);</programlisting>
<para>
Returns the prerequisites of an interfaces type.
</para><variablelist role="params">
<varlistentry><term><parameter>interface_type</parameter>&nbsp;:</term>
<listitem><simpara>an interface type
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>n_prerequisites</parameter>&nbsp;:</term>
<listitem><simpara>location to return the number of prerequisites, or <literal>NULL</literal>
</simpara></listitem></varlistentry>
<varlistentry><term><emphasis>Returns</emphasis>&nbsp;:</term><listitem><simpara>a newly-allocated zero-terminated array of <link linkend="GType"><type>GType</type></link> containing 
   the prerequisites of <parameter>interface_type</parameter>
</simpara></listitem></varlistentry>
</variablelist><para>Since 2.2


</para></refsect2>
<refsect2>
<title><anchor id="g-type-set-qdata" role="function"/>g_type_set_qdata ()</title>
<indexterm><primary>g_type_set_qdata</primary></indexterm><programlisting><link linkend="void">void</link>        g_type_set_qdata                (<link linkend="GType">GType</link> type,
                                             <link linkend="GQuark">GQuark</link> quark,
                                             <link linkend="gpointer">gpointer</link> data);</programlisting>
<para>
Attaches arbitrary data to a type.
</para><variablelist role="params">
<varlistentry><term><parameter>type</parameter>&nbsp;:</term>
<listitem><simpara>a <link linkend="GType"><type>GType</type></link>
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>quark</parameter>&nbsp;:</term>
<listitem><simpara>a <link linkend="GQuark"><type>GQuark</type></link> id to identify the data
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>data</parameter>&nbsp;:</term>
<listitem><simpara>the data


</simpara></listitem></varlistentry>
</variablelist></refsect2>
<refsect2>
<title><anchor id="g-type-get-qdata" role="function"/>g_type_get_qdata ()</title>
<indexterm><primary>g_type_get_qdata</primary></indexterm><programlisting><link linkend="gpointer">gpointer</link>    g_type_get_qdata                (<link linkend="GType">GType</link> type,
                                             <link linkend="GQuark">GQuark</link> quark);</programlisting>
<para>
Obtains data which has previously been attached to <parameter>type</parameter>
with <link linkend="g-type-set-qdata"><function>g_type_set_qdata()</function></link>.
</para><variablelist role="params">
<varlistentry><term><parameter>type</parameter>&nbsp;:</term>
<listitem><simpara>a <link linkend="GType"><type>GType</type></link>
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>quark</parameter>&nbsp;:</term>
<listitem><simpara>a <link linkend="GQuark"><type>GQuark</type></link> id to identify the data
</simpara></listitem></varlistentry>
<varlistentry><term><emphasis>Returns</emphasis>&nbsp;:</term><listitem><simpara>the data, or <literal>NULL</literal> if no data was found


</simpara></listitem></varlistentry>
</variablelist></refsect2>
<refsect2>
<title><anchor id="g-type-query" role="function"/>g_type_query ()</title>
<indexterm><primary>g_type_query</primary></indexterm><programlisting><link linkend="void">void</link>        g_type_query                    (<link linkend="GType">GType</link> type,
                                             <link linkend="GTypeQuery">GTypeQuery</link> *query);</programlisting>
<para>
Queries the type system for information about a specific type. 
This function will fill in a user-provided structure to hold type-specific 
information. If an invalid <link linkend="GType"><type>GType</type></link> is passed in, the <parameter>type</parameter> member of the 
<link linkend="GTypeQuery"><type>GTypeQuery</type></link> is 0. All members filled into the <link linkend="GTypeQuery"><type>GTypeQuery</type></link> structure should
be considered constant and have to be left untouched.
</para><variablelist role="params">
<varlistentry><term><parameter>type</parameter>&nbsp;:</term>
<listitem><simpara>the <link linkend="GType"><type>GType</type></link> value of a static, classed type.
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>query</parameter>&nbsp;:</term>
<listitem><simpara>A user provided structure that is filled in with constant values 
        upon success.


</simpara></listitem></varlistentry>
</variablelist></refsect2>
<refsect2>
<title><anchor id="GTypeQuery" role="struct"/>GTypeQuery</title>
<indexterm><primary>GTypeQuery</primary></indexterm><programlisting>typedef struct {
  GType		type;
  const gchar  *type_name;
  guint		class_size;
  guint		instance_size;
} GTypeQuery;
</programlisting>
<para>
A structure holding information for a specific type. It is
filled in by the <link linkend="g-type-query"><function>g_type_query()</function></link> function.
</para><variablelist role="struct">
<varlistentry>
<term><link linkend="GType">GType</link>&nbsp;<structfield>type</structfield>;</term>
<listitem><simpara>the <link linkend="GType"><type>GType</type></link> value of the type.
</simpara></listitem>
</varlistentry>
<varlistentry>
<term>const&nbsp;<link linkend="gchar">gchar</link>&nbsp;*<structfield>type_name</structfield>;</term>
<listitem><simpara>the name of the type.
</simpara></listitem>
</varlistentry>
<varlistentry>
<term><link linkend="guint">guint</link>&nbsp;<structfield>class_size</structfield>;</term>
<listitem><simpara>the size of the class structure.
</simpara></listitem>
</varlistentry>
<varlistentry>
<term><link linkend="guint">guint</link>&nbsp;<structfield>instance_size</structfield>;</term>
<listitem><simpara>the size of the instance structure.

</simpara></listitem>
</varlistentry>
</variablelist></refsect2>
<refsect2>
<title><anchor id="GBaseInitFunc" role="function"/>GBaseInitFunc ()</title>
<indexterm><primary>GBaseInitFunc</primary></indexterm><programlisting><link linkend="void">void</link>        (*GBaseInitFunc)                (<link linkend="gpointer">gpointer</link> g_class);</programlisting>
<para>
A callback function used by the type system to do base initialization
of the class structures of derived types. It is called as part of the
initialization process of all derived classes and should reallocate
or reset all dynamic class members copied over from the parent class.
Therefore class members, e.g. strings, that are not sufficiently
handled by a plain memory copy of the parent class into the derived class
have to be altered. See <link linkend="GClassInitFunc"><function>GClassInitFunc()</function></link> for a discussion of the class
intialization process.
</para><variablelist role="params">
<varlistentry><term><parameter>g_class</parameter>&nbsp;:</term>
<listitem><simpara>The <link linkend="GTypeClass"><type>GTypeClass</type></link> structure to initialize.


</simpara></listitem></varlistentry>
</variablelist></refsect2>
<refsect2>
<title><anchor id="GBaseFinalizeFunc" role="function"/>GBaseFinalizeFunc ()</title>
<indexterm><primary>GBaseFinalizeFunc</primary></indexterm><programlisting><link linkend="void">void</link>        (*GBaseFinalizeFunc)            (<link linkend="gpointer">gpointer</link> g_class);</programlisting>
<para>
A callback function used by the type system to finalize those portions
of a derived types class structure that were setup from the corresponding
<link linkend="GBaseInitFunc"><function>GBaseInitFunc()</function></link> function. Class finalization basically works the inverse
way in which class intialization is performed.
See <link linkend="GClassInitFunc"><function>GClassInitFunc()</function></link> for a discussion of the class intialization process.
</para><variablelist role="params">
<varlistentry><term><parameter>g_class</parameter>&nbsp;:</term>
<listitem><simpara>The <link linkend="GTypeClass"><type>GTypeClass</type></link> structure to finalize.


</simpara></listitem></varlistentry>
</variablelist></refsect2>
<refsect2>
<title><anchor id="GClassInitFunc" role="function"/>GClassInitFunc ()</title>
<indexterm><primary>GClassInitFunc</primary></indexterm><programlisting><link linkend="void">void</link>        (*GClassInitFunc)               (<link linkend="gpointer">gpointer</link> g_class,
                                             <link linkend="gpointer">gpointer</link> class_data);</programlisting>
<para>
A callback function used by the type system to initialize the class
of a specific type. This function should initialize all static class
members.
The initialization process of a class involves:
<variablelist>
  <varlistentry><term></term><listitem><para>
	1 - Copying common members from the parent class over to the
	derived class structure.
  </para></listitem></varlistentry>
  <varlistentry><term></term><listitem><para>
	2 -  Zero initialization of the remaining members not copied
	over from the parent class.
  </para></listitem></varlistentry>
  <varlistentry><term></term><listitem><para>
	3 - Invocation of the <link linkend="GBaseInitFunc"><function>GBaseInitFunc()</function></link> initializers of all parent
	types and the class' type.
  </para></listitem></varlistentry>
  <varlistentry><term></term><listitem><para>
	4 - Invocation of the class' <link linkend="GClassInitFunc"><function>GClassInitFunc()</function></link> initializer.
  </para></listitem></varlistentry>
</variablelist>
Since derived classes are partially initialized through a memory copy
of the parent class, the general rule is that <link linkend="GBaseInitFunc"><function>GBaseInitFunc()</function></link> and
<link linkend="GBaseFinalizeFunc"><function>GBaseFinalizeFunc()</function></link> should take care of necessary reinitialization
and release of those class members that were introduced by the type
that specified these <link linkend="GBaseInitFunc"><function>GBaseInitFunc()</function></link>/<link linkend="GBaseFinalizeFunc"><function>GBaseFinalizeFunc()</function></link>.
<link linkend="GClassInitFunc"><function>GClassInitFunc()</function></link> should only care about initializing static
class members, while dynamic class members (such as allocated strings
or reference counted resources) are better handled by a <link linkend="GBaseInitFunc"><function>GBaseInitFunc()</function></link>
for this type, so proper initialization of the dynamic class members
is performed for class initialization of derived types as well.
An example may help to correspond the intend of the different class
initializers:

<programlisting>
typedef struct {
  GObjectClass parent_class;
  gint         static_integer;
  gchar       *dynamic_string;
} TypeAClass;
static void
type_a_base_class_init (TypeAClass *class)
{
  class->dynamic_string = g_strdup ("some string");
}
static void
type_a_base_class_finalize (TypeAClass *class)
{
  g_free (class->dynamic_string);
}
static void
type_a_class_init (TypeAClass *class)
{
  class->static_integer = 42;
}

typedef struct {
  TypeAClass   parent_class;
  gfloat       static_float;
  GString     *dynamic_gstring;
} TypeBClass;
static void
type_b_base_class_init (TypeBClass *class)
{
  class->dynamic_gstring = g_string_new ("some other string");
}
static void
type_b_base_class_finalize (TypeBClass *class)
{
  g_string_free (class->dynamic_gstring);
}
static void
type_b_class_init (TypeBClass *class)
{
  class->static_float = 3.14159265358979323846;
}
</programlisting>
Initialization of TypeBClass will first cause initialization of
TypeAClass (derived classes reference their parent classes, see
<link linkend="g-type-class-ref"><function>g_type_class_ref()</function></link> on this).
Initialization of TypeAClass roughly involves zero-initializing its fields,
then calling its <link linkend="GBaseInitFunc"><function>GBaseInitFunc()</function></link> <link linkend="type-a-base-class-init"><function>type_a_base_class_init()</function></link> that allocates
its dynamic members (dynamic_string) and finally calling its <link linkend="GClassInitFunc"><function>GClassInitFunc()</function></link>
<link linkend="type-a-class-init"><function>type_a_class_init()</function></link> to initialize its static members (static_integer).
The first step in the initialization process of TypeBClass is then
a plain memory copy of the contents of TypeAClass into TypeBClass and 
zero-initialization of the remaining fields in TypeBClass.
The dynamic members of TypeAClass within TypeBClass now need
reinitialization which is performed by calling <link linkend="type-a-base-class-init"><function>type_a_base_class_init()</function></link>
with an argument of TypeBClass.
After that, the <link linkend="GBaseInitFunc"><function>GBaseInitFunc()</function></link> of TypeBClass, <link linkend="type-b-base-class-init"><function>type_b_base_class_init()</function></link>
is called to allocate the dynamic members of TypeBClass (dynamic_gstring),
and finally the <link linkend="GClassInitFunc"><function>GClassInitFunc()</function></link> of TypeBClass, <link linkend="type-b-class-init"><function>type_b_class_init()</function></link>,
is called to complete the initialization process with the static members
(static_float).
Corresponding finalization counter parts to the <link linkend="GBaseInitFunc"><function>GBaseInitFunc()</function></link> functions
have to be provided to release allocated resources at class finalization
time.
</para><variablelist role="params">
<varlistentry><term><parameter>g_class</parameter>&nbsp;:</term>
<listitem><simpara>	The <link linkend="GTypeClass"><type>GTypeClass</type></link> structure to initialize.
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>class_data</parameter>&nbsp;:</term>
<listitem><simpara>	The <parameter>class_data</parameter> member supplied via the <link linkend="GTypeInfo"><type>GTypeInfo</type></link> structure.


</simpara></listitem></varlistentry>
</variablelist></refsect2>
<refsect2>
<title><anchor id="GClassFinalizeFunc" role="function"/>GClassFinalizeFunc ()</title>
<indexterm><primary>GClassFinalizeFunc</primary></indexterm><programlisting><link linkend="void">void</link>        (*GClassFinalizeFunc)           (<link linkend="gpointer">gpointer</link> g_class,
                                             <link linkend="gpointer">gpointer</link> class_data);</programlisting>
<para>
A callback function used by the type system to finalize a class.
This function is rarely needed, as dynamically allocated class resources
should be handled by <link linkend="GBaseInitFunc"><function>GBaseInitFunc()</function></link> and <link linkend="GBaseFinalizeFunc"><function>GBaseFinalizeFunc()</function></link>.
Also, specification of a <link linkend="GClassFinalizeFunc"><function>GClassFinalizeFunc()</function></link> in the <link linkend="GTypeInfo"><type>GTypeInfo</type></link>
structure of a static type is invalid, because classes of static types
will never be finalized (they are artificially kept alive when their
reference count drops to zero).
</para><variablelist role="params">
<varlistentry><term><parameter>g_class</parameter>&nbsp;:</term>
<listitem><simpara>	The <link linkend="GTypeClass"><type>GTypeClass</type></link> structure to finalize.
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>class_data</parameter>&nbsp;:</term>
<listitem><simpara>	The <parameter>class_data</parameter> member supplied via the <link linkend="GTypeInfo"><type>GTypeInfo</type></link> structure.


</simpara></listitem></varlistentry>
</variablelist></refsect2>
<refsect2>
<title><anchor id="GInstanceInitFunc" role="function"/>GInstanceInitFunc ()</title>
<indexterm><primary>GInstanceInitFunc</primary></indexterm><programlisting><link linkend="void">void</link>        (*GInstanceInitFunc)            (<link linkend="GTypeInstance">GTypeInstance</link> *instance,
                                             <link linkend="gpointer">gpointer</link> g_class);</programlisting>
<para>
A callback function used by the type system to initialize a new
instance of a type. This function initializes all instance members and
allocates any resources required by it.
Initialization of a derived instance involves calling all its parent
types instance initializers, therefore the class member of the instance
is altered during its initialization to always point to the class that
belongs to the type the current initializer was introduced for.
</para><variablelist role="params">
<varlistentry><term><parameter>instance</parameter>&nbsp;:</term>
<listitem><simpara>	The instance to initialize.
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>g_class</parameter>&nbsp;:</term>
<listitem><simpara>	The class of the type the instance is created for.


</simpara></listitem></varlistentry>
</variablelist></refsect2>
<refsect2>
<title><anchor id="GInterfaceInitFunc" role="function"/>GInterfaceInitFunc ()</title>
<indexterm><primary>GInterfaceInitFunc</primary></indexterm><programlisting><link linkend="void">void</link>        (*GInterfaceInitFunc)           (<link linkend="gpointer">gpointer</link> g_iface,
                                             <link linkend="gpointer">gpointer</link> iface_data);</programlisting>
<para>
A callback function used by the type system to initialize a new
interface.  This function should initialize all internal data and
allocate any resources required by the interface.
</para><variablelist role="params">
<varlistentry><term><parameter>g_iface</parameter>&nbsp;:</term>
<listitem><simpara>	The interface structure to initialize.
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>iface_data</parameter>&nbsp;:</term>
<listitem><simpara>	The <parameter>class_data</parameter> supplied via the <link linkend="GTypeInfo"><type>GTypeInfo</type></link> structure.


</simpara></listitem></varlistentry>
</variablelist></refsect2>
<refsect2>
<title><anchor id="GInterfaceFinalizeFunc" role="function"/>GInterfaceFinalizeFunc ()</title>
<indexterm><primary>GInterfaceFinalizeFunc</primary></indexterm><programlisting><link linkend="void">void</link>        (*GInterfaceFinalizeFunc)       (<link linkend="gpointer">gpointer</link> g_iface,
                                             <link linkend="gpointer">gpointer</link> iface_data);</programlisting>
<para>
A callback function used by the type system to finalize an interface.
This function should destroy any internal data and release any resources
allocated by the corresponding <link linkend="GInterfaceInitFunc"><function>GInterfaceInitFunc()</function></link> function.
</para><variablelist role="params">
<varlistentry><term><parameter>g_iface</parameter>&nbsp;:</term>
<listitem><simpara>	The interface structure to finalize.
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>iface_data</parameter>&nbsp;:</term>
<listitem><simpara>	The <parameter>class_data</parameter> supplied via the <link linkend="GTypeInfo"><type>GTypeInfo</type></link> structure.


</simpara></listitem></varlistentry>
</variablelist></refsect2>
<refsect2>
<title><anchor id="GTypeClassCacheFunc" role="function"/>GTypeClassCacheFunc ()</title>
<indexterm><primary>GTypeClassCacheFunc</primary></indexterm><programlisting><link linkend="gboolean">gboolean</link>    (*GTypeClassCacheFunc)          (<link linkend="gpointer">gpointer</link> cache_data,
                                             <link linkend="GTypeClass">GTypeClass</link> *g_class);</programlisting>
<para>
A callback function which is called when the reference count of a class 
drops to zero. It may use <link linkend="g-type-class-ref"><function>g_type_class_ref()</function></link> to prevent the class from
being freed. You should not call <link linkend="g-type-class-unref"><function>g_type_class_unref()</function></link> from a 
<link linkend="GTypeClassCacheFunc"><type>GTypeClassCacheFunc</type></link> function to prevent infinite recursion, use 
<link linkend="g-type-class-unref-uncached"><function>g_type_class_unref_uncached()</function></link> instead.
</para>
<para>
The functions have to check the class id passed in to figure 
whether they actually want to cache the class of this type, since all
classes are routed through the same <link linkend="GTypeClassCacheFunc"><type>GTypeClassCacheFunc</type></link> chain.
</para><variablelist role="params">
<varlistentry><term><parameter>cache_data</parameter>&nbsp;:</term>
<listitem><simpara>data that was given to the <link linkend="g-type-add-class-cache-func"><function>g_type_add_class_cache_func()</function></link> call
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>g_class</parameter>&nbsp;:</term>
<listitem><simpara>The <link linkend="GTypeClass"><type>GTypeClass</type></link> structure which is unreferenced
</simpara></listitem></varlistentry>
<varlistentry><term><emphasis>Returns</emphasis>&nbsp;:</term><listitem><simpara><literal>TRUE</literal> to stop further <link linkend="GTypeClassCacheFunc"><type>GTypeClassCacheFunc</type></link><!-- -->s from being 
called, <literal>FALSE</literal> to continue.


</simpara></listitem></varlistentry>
</variablelist></refsect2>
<refsect2>
<title><anchor id="GTypeFlags" role="enum"/>enum GTypeFlags</title>
<indexterm><primary>GTypeFlags</primary></indexterm><programlisting>typedef enum    /*&lt; skip &gt;*/
{
  G_TYPE_FLAG_ABSTRACT		= (1 &lt;&lt; 4),
  G_TYPE_FLAG_VALUE_ABSTRACT	= (1 &lt;&lt; 5)
} GTypeFlags;
</programlisting>
<para>
Bit masks used to check or determine characteristics of a type.
</para><variablelist role="enum">
<varlistentry>
<term><literal>G_TYPE_FLAG_ABSTRACT</literal></term>
<listitem><simpara>	Indicates an abstract type. No instances can be
			created for an abstract type.
</simpara></listitem>
</varlistentry>
<varlistentry>
<term><literal>G_TYPE_FLAG_VALUE_ABSTRACT</literal></term>
<listitem><simpara>Indicates an abstract value type, i.e. a type
                        that introduces a value table, but can't be used for
                        <link linkend="g-value-init"><function>g_value_init()</function></link>.

</simpara></listitem>
</varlistentry>
</variablelist></refsect2>
<refsect2>
<title><anchor id="GTypeFundamentalFlags" role="enum"/>enum GTypeFundamentalFlags</title>
<indexterm><primary>GTypeFundamentalFlags</primary></indexterm><programlisting>typedef enum    /*&lt; skip &gt;*/
{
  G_TYPE_FLAG_CLASSED           = (1 &lt;&lt; 0),
  G_TYPE_FLAG_INSTANTIATABLE    = (1 &lt;&lt; 1),
  G_TYPE_FLAG_DERIVABLE         = (1 &lt;&lt; 2),
  G_TYPE_FLAG_DEEP_DERIVABLE    = (1 &lt;&lt; 3)
} GTypeFundamentalFlags;
</programlisting>
<para>
Bit masks used to check or determine specific characteristics of a
fundamental type.
</para><variablelist role="enum">
<varlistentry>
<term><literal>G_TYPE_FLAG_CLASSED</literal></term>
<listitem><simpara>		Indicates a classed type.
</simpara></listitem>
</varlistentry>
<varlistentry>
<term><literal>G_TYPE_FLAG_INSTANTIATABLE</literal></term>
<listitem><simpara>	Indicates an instantiable type (implies classed).
</simpara></listitem>
</varlistentry>
<varlistentry>
<term><literal>G_TYPE_FLAG_DERIVABLE</literal></term>
<listitem><simpara>	Indicates a flat derivable type.
</simpara></listitem>
</varlistentry>
<varlistentry>
<term><literal>G_TYPE_FLAG_DEEP_DERIVABLE</literal></term>
<listitem><simpara>	Indicates a deep derivable type (implies derivable).

</simpara></listitem>
</varlistentry>
</variablelist></refsect2>
<refsect2>
<title><anchor id="g-type-register-static" role="function"/>g_type_register_static ()</title>
<indexterm><primary>g_type_register_static</primary></indexterm><programlisting><link linkend="GType">GType</link>       g_type_register_static          (<link linkend="GType">GType</link> parent_type,
                                             const <link linkend="gchar">gchar</link> *type_name,
                                             const <link linkend="GTypeInfo">GTypeInfo</link> *info,
                                             <link linkend="GTypeFlags">GTypeFlags</link> flags);</programlisting>
<para>
Registers <parameter>type_name</parameter> as the name of a new static type derived from
<parameter>parent_type</parameter>.  The type system uses the information contained in the
<link linkend="GTypeInfo"><type>GTypeInfo</type></link> structure pointed to by <parameter>info</parameter> to manage the type and its
instances (if not abstract).  The value of <parameter>flags</parameter> determines the nature
(e.g. abstract or not) of the type.
</para><variablelist role="params">
<varlistentry><term><parameter>parent_type</parameter>&nbsp;:</term>
<listitem><simpara>	Type which this type will be derived from.
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>type_name</parameter>&nbsp;:</term>
<listitem><simpara>	0-terminated string used as the name of the new type.
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>info</parameter>&nbsp;:</term>
<listitem><simpara>		The <link linkend="GTypeInfo"><type>GTypeInfo</type></link> structure for this type.
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>flags</parameter>&nbsp;:</term>
<listitem><simpara>		Bitwise combination of <link linkend="GTypeFlags"><type>GTypeFlags</type></link> values.
</simpara></listitem></varlistentry>
<varlistentry><term><emphasis>Returns</emphasis>&nbsp;:</term><listitem><simpara>	The new type identifier.


</simpara></listitem></varlistentry>
</variablelist></refsect2>
<refsect2>
<title><anchor id="g-type-register-dynamic" role="function"/>g_type_register_dynamic ()</title>
<indexterm><primary>g_type_register_dynamic</primary></indexterm><programlisting><link linkend="GType">GType</link>       g_type_register_dynamic         (<link linkend="GType">GType</link> parent_type,
                                             const <link linkend="gchar">gchar</link> *type_name,
                                             <link linkend="GTypePlugin">GTypePlugin</link> *plugin,
                                             <link linkend="GTypeFlags">GTypeFlags</link> flags);</programlisting>
<para>
Registers <parameter>type_name</parameter> as the name of a new dynamic type derived from
<parameter>parent_type</parameter>.  The type system uses the information contained in the
<link linkend="GTypePlugin"><type>GTypePlugin</type></link> structure pointed to by <parameter>plugin</parameter> to manage the type and its
instances (if not abstract).  The value of <parameter>flags</parameter> determines the nature
(e.g. abstract or not) of the type.
</para><variablelist role="params">
<varlistentry><term><parameter>parent_type</parameter>&nbsp;:</term>
<listitem><simpara>	Type which this type will be derived from.
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>type_name</parameter>&nbsp;:</term>
<listitem><simpara>	0-terminated string used as the name of the new type.
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>plugin</parameter>&nbsp;:</term>
<listitem><simpara>	The <link linkend="GTypePlugin"><type>GTypePlugin</type></link> structure to retrieve the <link linkend="GTypeInfo"><type>GTypeInfo</type></link> from.
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>flags</parameter>&nbsp;:</term>
<listitem><simpara>		Bitwise combination of <link linkend="GTypeFlags"><type>GTypeFlags</type></link> values.
</simpara></listitem></varlistentry>
<varlistentry><term><emphasis>Returns</emphasis>&nbsp;:</term><listitem><simpara>	The new type identifier or <link linkend="G-TYPE-INVALID:CAPS"><type>G_TYPE_INVALID</type></link> if registration failed.


</simpara></listitem></varlistentry>
</variablelist></refsect2>
<refsect2>
<title><anchor id="g-type-register-fundamental" role="function"/>g_type_register_fundamental ()</title>
<indexterm><primary>g_type_register_fundamental</primary></indexterm><programlisting><link linkend="GType">GType</link>       g_type_register_fundamental     (<link linkend="GType">GType</link> type_id,
                                             const <link linkend="gchar">gchar</link> *type_name,
                                             const <link linkend="GTypeInfo">GTypeInfo</link> *info,
                                             const <link linkend="GTypeFundamentalInfo">GTypeFundamentalInfo</link> *finfo,
                                             <link linkend="GTypeFlags">GTypeFlags</link> flags);</programlisting>
<para>
Registers <parameter>type_id</parameter> as the predefined identifier and <parameter>type_name</parameter> as the
name of a fundamental type.  The type system uses the information
contained in the <link linkend="GTypeInfo"><type>GTypeInfo</type></link> structure pointed to by <parameter>info</parameter> and the 
<link linkend="GTypeFundamentalInfo"><type>GTypeFundamentalInfo</type></link> structure pointed to by <parameter>finfo</parameter> to manage the
type and its instances.  The value of <parameter>flags</parameter> determines additional
characteristics of the fundamental type.
</para><variablelist role="params">
<varlistentry><term><parameter>type_id</parameter>&nbsp;:</term>
<listitem><simpara>	A predefined <link linkend="GTypeFundamentals"><type>GTypeFundamentals</type></link> value.
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>type_name</parameter>&nbsp;:</term>
<listitem><simpara>	0-terminated string used as the name of the new type.
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>info</parameter>&nbsp;:</term>
<listitem><simpara>		The <link linkend="GTypeInfo"><type>GTypeInfo</type></link> structure for this type.
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>finfo</parameter>&nbsp;:</term>
<listitem><simpara>		The <link linkend="GTypeFundamentalInfo"><type>GTypeFundamentalInfo</type></link> structure for this type.
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>flags</parameter>&nbsp;:</term>
<listitem><simpara>		Bitwise combination of <link linkend="GTypeFlags"><type>GTypeFlags</type></link> values.
</simpara></listitem></varlistentry>
<varlistentry><term><emphasis>Returns</emphasis>&nbsp;:</term><listitem><simpara>	The predefined type identifier.


</simpara></listitem></varlistentry>
</variablelist></refsect2>
<refsect2>
<title><anchor id="g-type-add-interface-static" role="function"/>g_type_add_interface_static ()</title>
<indexterm><primary>g_type_add_interface_static</primary></indexterm><programlisting><link linkend="void">void</link>        g_type_add_interface_static     (<link linkend="GType">GType</link> instance_type,
                                             <link linkend="GType">GType</link> interface_type,
                                             const <link linkend="GInterfaceInfo">GInterfaceInfo</link> *info);</programlisting>
<para>
Adds the static <parameter>interface_type</parameter> to <parameter>instantiable_type</parameter>.  The information
contained in the <link linkend="GTypeInterfaceInfo"><type>GTypeInterfaceInfo</type></link> structure pointed to by <parameter>info</parameter>
is used to manage the relationship.
</para><variablelist role="params">
<varlistentry><term><parameter>instance_type</parameter>&nbsp;:</term>
<listitem><simpara>	 <link linkend="GType"><type>GType</type></link> value of an instantiable type.
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>interface_type</parameter>&nbsp;:</term>
<listitem><simpara><link linkend="GType"><type>GType</type></link> value of an interface type.
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>info</parameter>&nbsp;:</term>
<listitem><simpara>		 The <link linkend="GInterfaceInfo"><type>GInterfaceInfo</type></link> structure for this
		 (<parameter>instance_type</parameter>, <parameter>interface_type</parameter>) combination.


</simpara></listitem></varlistentry>
</variablelist></refsect2>
<refsect2>
<title><anchor id="g-type-add-interface-dynamic" role="function"/>g_type_add_interface_dynamic ()</title>
<indexterm><primary>g_type_add_interface_dynamic</primary></indexterm><programlisting><link linkend="void">void</link>        g_type_add_interface_dynamic    (<link linkend="GType">GType</link> instance_type,
                                             <link linkend="GType">GType</link> interface_type,
                                             <link linkend="GTypePlugin">GTypePlugin</link> *plugin);</programlisting>
<para>
Adds the dynamic <parameter>interface_type</parameter> to <parameter>instantiable_type</parameter>. The information
contained in the <link linkend="GTypePlugin"><type>GTypePlugin</type></link> structure pointed to by <parameter>plugin</parameter>
is used to manage the relationship.
</para><variablelist role="params">
<varlistentry><term><parameter>instance_type</parameter>&nbsp;:</term>
<listitem><simpara>the <link linkend="GType"><type>GType</type></link> value of an instantiable type.
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>interface_type</parameter>&nbsp;:</term>
<listitem><simpara>the <link linkend="GType"><type>GType</type></link> value of an interface type.
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>plugin</parameter>&nbsp;:</term>
<listitem><simpara>the <link linkend="GTypePlugin"><type>GTypePlugin</type></link> structure to retrieve the <link linkend="GInterfaceInfo"><type>GInterfaceInfo</type></link> from.


</simpara></listitem></varlistentry>
</variablelist></refsect2>
<refsect2>
<title><anchor id="g-type-interface-add-prerequisite" role="function"/>g_type_interface_add_prerequisite ()</title>
<indexterm><primary>g_type_interface_add_prerequisite</primary></indexterm><programlisting><link linkend="void">void</link>        g_type_interface_add_prerequisite
                                            (<link linkend="GType">GType</link> interface_type,
                                             <link linkend="GType">GType</link> prerequisite_type);</programlisting>
<para>
Adds <parameter>prerequisite_type</parameter> to the list of prerequisites of <parameter>interface_type</parameter>.
This means that any type implementing <parameter>interface_type</parameter> must also implement
<parameter>prerequisite_type</parameter>. Prerequisites can be thought of as an alternative to
interface derivation (which GType doesn't support). An interface can have
at most one instantiatable prerequisite type.
</para><variablelist role="params">
<varlistentry><term><parameter>interface_type</parameter>&nbsp;:</term>
<listitem><simpara><link linkend="GType"><type>GType</type></link> value of an interface type.
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>prerequisite_type</parameter>&nbsp;:</term>
<listitem><simpara><link linkend="GType"><type>GType</type></link> value of an interface or instantiatable type.


</simpara></listitem></varlistentry>
</variablelist></refsect2>
<refsect2>
<title><anchor id="g-type-get-plugin" role="function"/>g_type_get_plugin ()</title>
<indexterm><primary>g_type_get_plugin</primary></indexterm><programlisting><link linkend="GTypePlugin">GTypePlugin</link>* g_type_get_plugin              (<link linkend="GType">GType</link> type);</programlisting>
<para>
Returns the <link linkend="GTypePlugin"><type>GTypePlugin</type></link> structure for <parameter>type</parameter> or
<literal>NULL</literal> if <parameter>type</parameter> does not have a <link linkend="GTypePlugin"><type>GTypePlugin</type></link> structure.
</para><variablelist role="params">
<varlistentry><term><parameter>type</parameter>&nbsp;:</term>
<listitem><simpara>		The <link linkend="GType"><type>GType</type></link> to retrieve the plugin for.
</simpara></listitem></varlistentry>
<varlistentry><term><emphasis>Returns</emphasis>&nbsp;:</term><listitem><simpara>	The corresponding plugin if <parameter>type</parameter> is a dynamic type,
		<literal>NULL</literal> otherwise.


</simpara></listitem></varlistentry>
</variablelist></refsect2>
<refsect2>
<title><anchor id="g-type-interface-get-plugin" role="function"/>g_type_interface_get_plugin ()</title>
<indexterm><primary>g_type_interface_get_plugin</primary></indexterm><programlisting><link linkend="GTypePlugin">GTypePlugin</link>* g_type_interface_get_plugin    (<link linkend="GType">GType</link> instance_type,
                                             <link linkend="GType">GType</link> interface_type);</programlisting>
<para>
Returns the <link linkend="GTypePlugin"><type>GTypePlugin</type></link> structure for the dynamic interface 
<parameter>interface_type</parameter> which has been added to <parameter>instance_type</parameter>, or 
<literal>NULL</literal> if <parameter>interface_type</parameter> has not been added to <parameter>instance_type</parameter> or does 
not have a <link linkend="GTypePlugin"><type>GTypePlugin</type></link> structure. See <link linkend="g-type-add-interface-dynamic"><function>g_type_add_interface_dynamic()</function></link>.
</para><variablelist role="params">
<varlistentry><term><parameter>instance_type</parameter>&nbsp;:</term>
<listitem><simpara>the <link linkend="GType"><type>GType</type></link> value of an instantiatable type.
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>interface_type</parameter>&nbsp;:</term>
<listitem><simpara>the <link linkend="GType"><type>GType</type></link> value of an interface type.
</simpara></listitem></varlistentry>
<varlistentry><term><emphasis>Returns</emphasis>&nbsp;:</term><listitem><simpara>the <link linkend="GTypePlugin"><type>GTypePlugin</type></link> for the dynamic interface <parameter>interface_type</parameter>
   of <parameter>instance_type</parameter>.


</simpara></listitem></varlistentry>
</variablelist></refsect2>
<refsect2>
<title><anchor id="g-type-fundamental-next" role="function"/>g_type_fundamental_next ()</title>
<indexterm><primary>g_type_fundamental_next</primary></indexterm><programlisting><link linkend="GType">GType</link>       g_type_fundamental_next         (void);</programlisting>
<para>
Returns the next free fundamental type id which can be used to
register a new fundamental type with <link linkend="g-type-register-fundamental"><function>g_type_register_fundamental()</function></link>.
The returned type ID represents the highest currently registered
fundamental type identifier.

</para><variablelist role="params">
<varlistentry><term><emphasis>Returns</emphasis>&nbsp;:</term><listitem><simpara>The nextmost fundamental type ID to be registered,
          or 0 if the type system ran out of fundamental type IDs.


</simpara></listitem></varlistentry>
</variablelist></refsect2>
<refsect2>
<title><anchor id="g-type-fundamental" role="function"/>g_type_fundamental ()</title>
<indexterm><primary>g_type_fundamental</primary></indexterm><programlisting><link linkend="GType">GType</link>       g_type_fundamental              (<link linkend="GType">GType</link> type_id);</programlisting>
<para>
Internal function, used to extract the fundamental type ID portion.
use <link linkend="G-TYPE-FUNDAMENTAL:CAPS"><function>G_TYPE_FUNDAMENTAL()</function></link> instead.
</para><variablelist role="params">
<varlistentry><term><parameter>type_id</parameter>&nbsp;:</term>
<listitem><simpara>valid type ID
</simpara></listitem></varlistentry>
<varlistentry><term><emphasis>Returns</emphasis>&nbsp;:</term><listitem><simpara>fundamental type ID


</simpara></listitem></varlistentry>
</variablelist></refsect2>
<refsect2>
<title><anchor id="g-type-create-instance" role="function"/>g_type_create_instance ()</title>
<indexterm><primary>g_type_create_instance</primary></indexterm><programlisting><link linkend="GTypeInstance">GTypeInstance</link>* g_type_create_instance       (<link linkend="GType">GType</link> type);</programlisting>
<para>
Creates and initializes an instance of <parameter>type</parameter> if <parameter>type</parameter> is valid and can
be instantiated. The type system only performs basic allocation and
structure setups for instances, actual instance creation should happen
through functions supplied by the type's fundamental type implementation.
So use of <link linkend="g-type-create-instance"><function>g_type_create_instance()</function></link> is reserved for implementators of
fundamental types only. E.g. instances of the <link linkend="GObject"><type>GObject</type></link> hierarchy
should be created via <link linkend="g-object-new"><function>g_object_new()</function></link> and <emphasis>never</emphasis>
directly through <link linkend="g-type-create-instance"><function>g_type_create_instance()</function></link> which doesn't handle
things like singleton objects or object construction.
Note: Do <emphasis>not</emphasis> use this function, unless you're
implementing a fundamental type. Also language bindings should <emphasis>not</emphasis>
use this function but <link linkend="g-object-new"><function>g_object_new()</function></link> instead.
</para><variablelist role="params">
<varlistentry><term><parameter>type</parameter>&nbsp;:</term>
<listitem><simpara>	  An instantiatable type to create an instance for.
</simpara></listitem></varlistentry>
<varlistentry><term><emphasis>Returns</emphasis>&nbsp;:</term><listitem><simpara>An allocated and initialized instance, subject to further
	  treatment by the fundamental type implementation.


</simpara></listitem></varlistentry>
</variablelist></refsect2>
<refsect2>
<title><anchor id="g-type-free-instance" role="function"/>g_type_free_instance ()</title>
<indexterm><primary>g_type_free_instance</primary></indexterm><programlisting><link linkend="void">void</link>        g_type_free_instance            (<link linkend="GTypeInstance">GTypeInstance</link> *instance);</programlisting>
<para>
Frees an instance of a type, returning it to the instance pool for the type,
if there is one.
</para>
<para>
Like <link linkend="g-type-create-instance"><function>g_type_create_instance()</function></link>, this function is reserved for implementors of 
fundamental types.
</para><variablelist role="params">
<varlistentry><term><parameter>instance</parameter>&nbsp;:</term>
<listitem><simpara>an instance of a type.


</simpara></listitem></varlistentry>
</variablelist></refsect2>
<refsect2>
<title><anchor id="g-type-add-class-cache-func" role="function"/>g_type_add_class_cache_func ()</title>
<indexterm><primary>g_type_add_class_cache_func</primary></indexterm><programlisting><link linkend="void">void</link>        g_type_add_class_cache_func     (<link linkend="gpointer">gpointer</link> cache_data,
                                             <link linkend="GTypeClassCacheFunc">GTypeClassCacheFunc</link> cache_func);</programlisting>
<para>
Adds a <link linkend="GTypeClassCacheFunc"><type>GTypeClassCacheFunc</type></link> to be called before the reference count of a class 
goes from one to zero. This can be used to prevent premature class destruction.
All installed <link linkend="GTypeClassCacheFunc"><type>GTypeClassCacheFunc</type></link> functions will be chained until one of them 
returns <literal>TRUE</literal>. The functions have to check the class id passed in to figure 
whether they actually want to cache the class of this type, since all classes
are routed through the same <link linkend="GTypeClassCacheFunc"><type>GTypeClassCacheFunc</type></link> chain.
</para><variablelist role="params">
<varlistentry><term><parameter>cache_data</parameter>&nbsp;:</term>
<listitem><simpara>data to be passed to <parameter>cache_func</parameter>
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>cache_func</parameter>&nbsp;:</term>
<listitem><simpara>a <link linkend="GTypeClassCacheFunc"><type>GTypeClassCacheFunc</type></link>


</simpara></listitem></varlistentry>
</variablelist></refsect2>
<refsect2>
<title><anchor id="g-type-remove-class-cache-func" role="function"/>g_type_remove_class_cache_func ()</title>
<indexterm><primary>g_type_remove_class_cache_func</primary></indexterm><programlisting><link linkend="void">void</link>        g_type_remove_class_cache_func  (<link linkend="gpointer">gpointer</link> cache_data,
                                             <link linkend="GTypeClassCacheFunc">GTypeClassCacheFunc</link> cache_func);</programlisting>
<para>
Removes a previously installed <link linkend="GTypeClassCacheFunc"><type>GTypeClassCacheFunc</type></link>. The cache maintained 
by <parameter>cache_func</parameter> has to be empty when calling <link linkend="g-type-remove-class-cache-func"><function>g_type_remove_class_cache_func()</function></link> 
to avoid leaks.
</para><variablelist role="params">
<varlistentry><term><parameter>cache_data</parameter>&nbsp;:</term>
<listitem><simpara>data that was given when adding <parameter>cache_func</parameter>
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>cache_func</parameter>&nbsp;:</term>
<listitem><simpara>a <link linkend="GTypeClassCacheFunc"><type>GTypeClassCacheFunc</type></link>


</simpara></listitem></varlistentry>
</variablelist></refsect2>
<refsect2>
<title><anchor id="g-type-class-unref-uncached" role="function"/>g_type_class_unref_uncached ()</title>
<indexterm><primary>g_type_class_unref_uncached</primary></indexterm><programlisting><link linkend="void">void</link>        g_type_class_unref_uncached     (<link linkend="gpointer">gpointer</link> g_class);</programlisting>
<para>
A variant of <link linkend="g-type-class-unref"><function>g_type_class_unref()</function></link> for use in <link linkend="GTypeClassCacheFunc"><type>GTypeClassCacheFunc</type></link>
implementations. It unreferences a class without consulting the chain
of <link linkend="GTypeClassCacheFunc"><type>GTypeClassCacheFunc</type></link><!-- -->s, avoiding the recursion which would occur
otherwise.
</para><variablelist role="params">
<varlistentry><term><parameter>g_class</parameter>&nbsp;:</term>
<listitem><simpara>The <link linkend="GTypeClass"><type>GTypeClass</type></link> structure to unreference.


</simpara></listitem></varlistentry>
</variablelist></refsect2>
<refsect2>
<title><anchor id="g-type-add-interface-check" role="function" condition="since:2.4"/>g_type_add_interface_check ()</title>
<indexterm role="2.4"><primary>g_type_add_interface_check</primary></indexterm><programlisting><link linkend="void">void</link>        g_type_add_interface_check      (<link linkend="gpointer">gpointer</link> check_data,
                                             <link linkend="GTypeInterfaceCheckFunc">GTypeInterfaceCheckFunc</link> check_func);</programlisting>
<para>
Adds a function to be called after an interface vtable is
initialized for any class. That is, after the <parameter>interface_init</parameter>
member of <link linkend="GInterfaceInfo"><type>GInterfaceInfo</type></link> has been called.
</para>
<para>
This function is useful when you want to check an invariant
that depends on the interfaces of a class. For instance,
the implementation of <link linkend="GObject"><type>GObject</type></link> uses this facility to check
that an object implements all of the properties that are
defined on its interfaces.    
</para><variablelist role="params">
<varlistentry><term><parameter>check_data</parameter>&nbsp;:</term>
<listitem><simpara>data to pass to <parameter>check_func</parameter>
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>check_func</parameter>&nbsp;:</term>
<listitem><simpara>function to be called after each interface
   is initialized.
</simpara></listitem></varlistentry>
</variablelist><para>Since 2.4


</para></refsect2>
<refsect2>
<title><anchor id="g-type-remove-interface-check" role="function" condition="since:2.4"/>g_type_remove_interface_check ()</title>
<indexterm role="2.4"><primary>g_type_remove_interface_check</primary></indexterm><programlisting><link linkend="void">void</link>        g_type_remove_interface_check   (<link linkend="gpointer">gpointer</link> check_data,
                                             <link linkend="GTypeInterfaceCheckFunc">GTypeInterfaceCheckFunc</link> check_func);</programlisting>
<para>
Removes an interface check function added with
<link linkend="g-type-add-interface-check"><function>g_type_add_interface_check()</function></link>.
</para><variablelist role="params">
<varlistentry><term><parameter>check_data</parameter>&nbsp;:</term>
<listitem><simpara>callback data passed to <link linkend="g-type-add-interface-check"><function>g_type_add_interface_check()</function></link>
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>check_func</parameter>&nbsp;:</term>
<listitem><simpara>callback function passed to <link linkend="g-type-add-interface-check"><function>g_type_add_interface_check()</function></link>
</simpara></listitem></varlistentry>
</variablelist><para>Since 2.4


</para></refsect2>
<refsect2>
<title><anchor id="GTypeInterfaceCheckFunc" role="function" condition="since:2.4"/>GTypeInterfaceCheckFunc ()</title>
<indexterm role="2.4"><primary>GTypeInterfaceCheckFunc</primary></indexterm><programlisting><link linkend="void">void</link>        (*GTypeInterfaceCheckFunc)      (<link linkend="gpointer">gpointer</link> check_data,
                                             <link linkend="gpointer">gpointer</link> g_iface);</programlisting>
<para>
A callback called after an interface vtable is initialized.
See <link linkend="g-type-add-interface-check"><function>g_type_add_interface_check()</function></link>.
</para><variablelist role="params">
<varlistentry><term><parameter>check_data</parameter>&nbsp;:</term>
<listitem><simpara>data passed to <link linkend="g-type-add-interface-check"><function>g_type_add_interface_check()</function></link>.
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>g_iface</parameter>&nbsp;:</term>
<listitem><simpara>the interface that has been initialized
</simpara></listitem></varlistentry>
</variablelist><para>Since 2.4


</para></refsect2>
<refsect2>
<title><anchor id="g-type-value-table-peek" role="function"/>g_type_value_table_peek ()</title>
<indexterm><primary>g_type_value_table_peek</primary></indexterm><programlisting><link linkend="GTypeValueTable">GTypeValueTable</link>* g_type_value_table_peek    (<link linkend="GType">GType</link> type);</programlisting>
<para>
Returns the location of the <link linkend="GTypeValueTable"><type>GTypeValueTable</type></link> associated with <parameter>type</parameter>.
<emphasis>Note, this function should only be used from source code
that implements or has internal knowledge of the implementation of
<parameter>type</parameter>.</emphasis>
</para><variablelist role="params">
<varlistentry><term><parameter>type</parameter>&nbsp;:</term>
<listitem><simpara>   A <link linkend="GType"><type>GType</type></link> value.
</simpara></listitem></varlistentry>
<varlistentry><term><emphasis>Returns</emphasis>&nbsp;:</term><listitem><simpara>Location of the <link linkend="GTypeValueTable"><type>GTypeValueTable</type></link> associated with <parameter>type</parameter> or
          <literal>NULL</literal> if there is no <link linkend="GTypeValueTable"><type>GTypeValueTable</type></link> associated with <parameter>type</parameter>.


</simpara></listitem></varlistentry>
</variablelist></refsect2>
<refsect2>
<title><anchor id="G-DEFINE-TYPE:CAPS" role="macro" condition="since:2.4"/>G_DEFINE_TYPE()</title>
<indexterm role="2.4"><primary>G_DEFINE_TYPE</primary></indexterm><programlisting>#define G_DEFINE_TYPE(TN, t_n, T_P)                         G_DEFINE_TYPE_EXTENDED (TN, t_n, T_P, 0, {})
</programlisting>
<para>
A convenience macro for type implementations, which declares a 
class initialization function, an instance initialization function (see <link linkend="GTypeInfo"><type>GTypeInfo</type></link> for information about 
these) and a static variable named <parameter>t_n</parameter><!-- -->_parent_class pointing to the parent class. Furthermore, it defines 
a *<link linkend="get-type"><function>_get_type()</function></link> function. See <link linkend="G-DEFINE-TYPE-EXTENDED:CAPS"><function>G_DEFINE_TYPE_EXTENDED()</function></link> for an example.
</para><variablelist role="params">
<varlistentry><term><parameter>TN</parameter>&nbsp;:</term>
<listitem><simpara>The name of the new type, in Camel case.
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>t_n</parameter>&nbsp;:</term>
<listitem><simpara>The name of the new type, in lowercase, with words 
  separated by '_'.
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>T_P</parameter>&nbsp;:</term>
<listitem><simpara>The <link linkend="GType"><type>GType</type></link> of the parent type.
</simpara></listitem></varlistentry>
</variablelist><para>Since 2.4


</para></refsect2>
<refsect2>
<title><anchor id="G-DEFINE-TYPE-WITH-CODE:CAPS" role="macro" condition="since:2.4"/>G_DEFINE_TYPE_WITH_CODE()</title>
<indexterm role="2.4"><primary>G_DEFINE_TYPE_WITH_CODE</primary></indexterm><programlisting>#define G_DEFINE_TYPE_WITH_CODE(TN, t_n, T_P, _C_)          G_DEFINE_TYPE_EXTENDED (TN, t_n, T_P, 0, _C_)
</programlisting>
<para>
A convenience macro for type implementations.  
Similar to <link linkend="G-DEFINE-TYPE:CAPS"><function>G_DEFINE_TYPE()</function></link>, but allows to insert custom code into the 
*<link linkend="get-type"><function>_get_type()</function></link> function, e.g. interface implementations via <link linkend="G-IMPLEMENT-INTERFACE:CAPS"><function>G_IMPLEMENT_INTERFACE()</function></link>.
See <link linkend="G-DEFINE-TYPE-EXTENDED:CAPS"><function>G_DEFINE_TYPE_EXTENDED()</function></link> for an example.
</para><variablelist role="params">
<varlistentry><term><parameter>TN</parameter>&nbsp;:</term>
<listitem><simpara>The name of the new type, in Camel case.
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>t_n</parameter>&nbsp;:</term>
<listitem><simpara>The name of the new type in lowercase, with words separated by '_'.
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>T_P</parameter>&nbsp;:</term>
<listitem><simpara>The <link linkend="GType"><type>GType</type></link> of the parent type.
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>_C_</parameter>&nbsp;:</term>
<listitem><simpara>Custom code that gets inserted in the *<link linkend="get-type"><function>_get_type()</function></link> function.
</simpara></listitem></varlistentry>
</variablelist><para>Since 2.4


</para></refsect2>
<refsect2>
<title><anchor id="G-DEFINE-ABSTRACT-TYPE:CAPS" role="macro" condition="since:2.4"/>G_DEFINE_ABSTRACT_TYPE()</title>
<indexterm role="2.4"><primary>G_DEFINE_ABSTRACT_TYPE</primary></indexterm><programlisting>#define G_DEFINE_ABSTRACT_TYPE(TN, t_n, T_P)                G_DEFINE_TYPE_EXTENDED (TN, t_n, T_P, G_TYPE_FLAG_ABSTRACT, {})
</programlisting>
<para>
A convenience macro for type implementations. 
Similar to <link linkend="G-DEFINE-TYPE:CAPS"><function>G_DEFINE_TYPE()</function></link>, but defines an abstract type. 
See <link linkend="G-DEFINE-TYPE-EXTENDED:CAPS"><function>G_DEFINE_TYPE_EXTENDED()</function></link> for an example.
</para><variablelist role="params">
<varlistentry><term><parameter>TN</parameter>&nbsp;:</term>
<listitem><simpara>The name of the new type, in Camel case.
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>t_n</parameter>&nbsp;:</term>
<listitem><simpara>The name of the new type, in lowercase, with words 
  separated by '_'.
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>T_P</parameter>&nbsp;:</term>
<listitem><simpara>The <link linkend="GType"><type>GType</type></link> of the parent type.
</simpara></listitem></varlistentry>
</variablelist><para>Since 2.4


</para></refsect2>
<refsect2>
<title><anchor id="G-DEFINE-ABSTRACT-TYPE-WITH-CODE:CAPS" role="macro" condition="since:2.4"/>G_DEFINE_ABSTRACT_TYPE_WITH_CODE()</title>
<indexterm role="2.4"><primary>G_DEFINE_ABSTRACT_TYPE_WITH_CODE</primary></indexterm><programlisting>#define G_DEFINE_ABSTRACT_TYPE_WITH_CODE(TN, t_n, T_P, _C_) G_DEFINE_TYPE_EXTENDED (TN, t_n, T_P, G_TYPE_FLAG_ABSTRACT, _C_)
</programlisting>
<para>
A convenience macro for type implementations.
Similar to <link linkend="G-DEFINE-TYPE-WITH-CODE:CAPS"><function>G_DEFINE_TYPE_WITH_CODE()</function></link>, but defines an abstract type and allows to 
insert custom code into the *<link linkend="get-type"><function>_get_type()</function></link> function, e.g. interface implementations 
via <link linkend="G-IMPLEMENT-INTERFACE:CAPS"><function>G_IMPLEMENT_INTERFACE()</function></link>. See <link linkend="G-DEFINE-TYPE-EXTENDED:CAPS"><function>G_DEFINE_TYPE_EXTENDED()</function></link> for an example.
</para><variablelist role="params">
<varlistentry><term><parameter>TN</parameter>&nbsp;:</term>
<listitem><simpara>The name of the new type, in Camel case.
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>t_n</parameter>&nbsp;:</term>
<listitem><simpara>The name of the new type, in lowercase, with words 
  separated by '_'.
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>T_P</parameter>&nbsp;:</term>
<listitem><simpara>The <link linkend="GType"><type>GType</type></link> of the parent type.
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>_C_</parameter>&nbsp;:</term>
<listitem><simpara>Custom code that gets inserted in the @<link linkend="type-name-get-type"><function>type_name_get_type()</function></link> function.
</simpara></listitem></varlistentry>
</variablelist><para>Since 2.4


</para></refsect2>
<refsect2>
<title><anchor id="G-IMPLEMENT-INTERFACE:CAPS" role="macro" condition="since:2.4"/>G_IMPLEMENT_INTERFACE()</title>
<indexterm role="2.4"><primary>G_IMPLEMENT_INTERFACE</primary></indexterm><programlisting>#define     G_IMPLEMENT_INTERFACE(TYPE_IFACE, iface_init)</programlisting>
<para>
A convenience macro to ease interface addition in the <parameter>_C_</parameter> section
of <link linkend="G-DEFINE-TYPE-WITH-CODE:CAPS"><function>G_DEFINE_TYPE_WITH_CODE()</function></link> or <link linkend="G-DEFINE-ABSTRACT-TYPE-WITH-CODE:CAPS"><function>G_DEFINE_ABSTRACT_TYPE_WITH_CODE()</function></link>. 
See <link linkend="G-DEFINE-TYPE-EXTENDED:CAPS"><function>G_DEFINE_TYPE_EXTENDED()</function></link> for an example.
</para>
<para>
Note that this macro can only be used together with the G_DEFINE_TYPE_*
macros, since it depends on variable names from those macros.
</para><variablelist role="params">
<varlistentry><term><parameter>TYPE_IFACE</parameter>&nbsp;:</term>
<listitem><simpara>The <link linkend="GType"><type>GType</type></link> of the interface to add
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>iface_init</parameter>&nbsp;:</term>
<listitem><simpara>The interface init function
</simpara></listitem></varlistentry>
</variablelist><para>Since 2.4


</para></refsect2>
<refsect2>
<title><anchor id="G-DEFINE-TYPE-EXTENDED:CAPS" role="macro" condition="since:2.4"/>G_DEFINE_TYPE_EXTENDED()</title>
<indexterm role="2.4"><primary>G_DEFINE_TYPE_EXTENDED</primary></indexterm><programlisting>#define     G_DEFINE_TYPE_EXTENDED(TypeName, type_name, TYPE_PARENT, flags, CODE)</programlisting>
<para>
The most general convenience macro for type implementations, on which 
<link linkend="G-DEFINE-TYPE:CAPS"><function>G_DEFINE_TYPE()</function></link>, etc are based. 
</para>
<informalexample><programlisting>
G_DEFINE_TYPE_EXTENDED (GtkGadget, 
                        gtk_gadget, 
                        GTK_TYPE_WIDGET,
                        0, 
                        G_IMPLEMENT_INTERFACE (TYPE_GIZMO, 
                                               gtk_gadget_gizmo_init));
</programlisting>
expands to
<programlisting>
static void     gtk_gadget_init       (GtkGadget      *self);
static void     gtk_gadget_class_init (GtkGadgetClass *klass);
static gpointer gtk_gadget_parent_class = NULL;
static void     gtk_gadget_class_intern_init (gpointer klass)
{
  gtk_gadget_parent_class = g_type_class_peek_parent (klass);
  gtk_gadget_class_init ((GtkGadgetClass*) klass);
}
<!-- -->
GType
gtk_gadget_get_type (void)
{
  static GType g_define_type_id = 0; 
  if (G_UNLIKELY (g_define_type_id == 0)) 
    { 
      static const GTypeInfo g_define_type_info = { 
        sizeof (GtkGadgetClass), 
        (GBaseInitFunc) NULL, 
        (GBaseFinalizeFunc) NULL, 
        (GClassInitFunc) gtk_gadget_class_intern_init, 
        (GClassFinalizeFunc) NULL, 
        NULL,   /* class_data */ 
        sizeof (GtkGadget), 
        0,      /* n_preallocs */ 
        (GInstanceInitFunc) gtk_gadget_init, 
      }; 
      g_define_type_id = g_type_register_static (GTK_TYPE_WIDGET, "GtkGadget", &amp;g_define_type_info, 0); 
      {
        static const GInterfaceInfo g_implement_interface_info = {
          (GInterfaceInitFunc) gtk_gadget_gizmo_init
        };
        g_type_add_interface_static (g_define_type_id, TYPE_GIZMO, &amp;g_implement_interface_info);
      } 
    } 
  return g_define_type_id; 
}
</programlisting>
The only pieces which have to be manually provided are the definitions of the 
instance and class structure and the definitions of the instance and class 
init functions.
</informalexample><variablelist role="params">
<varlistentry><term><parameter>TypeName</parameter>&nbsp;:</term>
<listitem><simpara>The name of the new type, in Camel case.
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>type_name</parameter>&nbsp;:</term>
<listitem><simpara>The name of the new type, in lowercase, with words 
  separated by '_'.
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>TYPE_PARENT</parameter>&nbsp;:</term>
<listitem><simpara>The <link linkend="GType"><type>GType</type></link> of the parent type.
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>flags</parameter>&nbsp;:</term>
<listitem><simpara><link linkend="GTypeFlags"><type>GTypeFlags</type></link> to pass to <link linkend="g-type-register-static"><function>g_type_register_static()</function></link>
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>CODE</parameter>&nbsp;:</term>
<listitem><simpara>Custom code that gets inserted in the *<link linkend="get-type"><function>_get_type()</function></link> function.
</simpara></listitem></varlistentry>
</variablelist><para>Since 2.4


</para></refsect2>
<refsect2>
<title><anchor id="G-TYPE-INVALID:CAPS" role="macro"/>G_TYPE_INVALID</title>
<indexterm><primary>G_TYPE_INVALID</primary></indexterm><programlisting>#define G_TYPE_INVALID			G_TYPE_MAKE_FUNDAMENTAL (0)
</programlisting>
<para>
An invalid <link linkend="GType"><type>GType</type></link>, used as error return value in some functions which return
a <link linkend="GType"><type>GType</type></link>. 
</para></refsect2>
<refsect2>
<title><anchor id="G-TYPE-NONE:CAPS" role="macro"/>G_TYPE_NONE</title>
<indexterm><primary>G_TYPE_NONE</primary></indexterm><programlisting>#define G_TYPE_NONE			G_TYPE_MAKE_FUNDAMENTAL (1)
</programlisting>
<para>
A fundamental type which is used as a replacement for the C
<literal>void</literal> return type.
</para></refsect2>
<refsect2>
<title><anchor id="G-TYPE-INTERFACE:CAPS" role="macro"/>G_TYPE_INTERFACE</title>
<indexterm><primary>G_TYPE_INTERFACE</primary></indexterm><programlisting>#define G_TYPE_INTERFACE		G_TYPE_MAKE_FUNDAMENTAL (2)
</programlisting>
<para>
The fundamental type from which all interfaces are derived.
</para></refsect2>
<refsect2>
<title><anchor id="G-TYPE-CHAR:CAPS" role="macro"/>G_TYPE_CHAR</title>
<indexterm><primary>G_TYPE_CHAR</primary></indexterm><programlisting>#define G_TYPE_CHAR			G_TYPE_MAKE_FUNDAMENTAL (3)
</programlisting>
<para>
The fundamental type corresponding to <link linkend="gchar"><type>gchar</type></link>.
</para></refsect2>
<refsect2>
<title><anchor id="G-TYPE-UCHAR:CAPS" role="macro"/>G_TYPE_UCHAR</title>
<indexterm><primary>G_TYPE_UCHAR</primary></indexterm><programlisting>#define G_TYPE_UCHAR			G_TYPE_MAKE_FUNDAMENTAL (4)
</programlisting>
<para>
The fundamental type corresponding to <link linkend="guchar"><type>guchar</type></link>.
</para></refsect2>
<refsect2>
<title><anchor id="G-TYPE-BOOLEAN:CAPS" role="macro"/>G_TYPE_BOOLEAN</title>
<indexterm><primary>G_TYPE_BOOLEAN</primary></indexterm><programlisting>#define G_TYPE_BOOLEAN			G_TYPE_MAKE_FUNDAMENTAL (5)
</programlisting>
<para>
The fundamental type corresponding to <link linkend="gboolean"><type>gboolean</type></link>.
</para></refsect2>
<refsect2>
<title><anchor id="G-TYPE-INT:CAPS" role="macro"/>G_TYPE_INT</title>
<indexterm><primary>G_TYPE_INT</primary></indexterm><programlisting>#define G_TYPE_INT			G_TYPE_MAKE_FUNDAMENTAL (6)
</programlisting>
<para>
The fundamental type corresponding to <link linkend="gint"><type>gint</type></link>.
</para></refsect2>
<refsect2>
<title><anchor id="G-TYPE-UINT:CAPS" role="macro"/>G_TYPE_UINT</title>
<indexterm><primary>G_TYPE_UINT</primary></indexterm><programlisting>#define G_TYPE_UINT			G_TYPE_MAKE_FUNDAMENTAL (7)
</programlisting>
<para>
The fundamental type corresponding to <link linkend="guint"><type>guint</type></link>.
</para></refsect2>
<refsect2>
<title><anchor id="G-TYPE-LONG:CAPS" role="macro"/>G_TYPE_LONG</title>
<indexterm><primary>G_TYPE_LONG</primary></indexterm><programlisting>#define G_TYPE_LONG			G_TYPE_MAKE_FUNDAMENTAL (8)
</programlisting>
<para>
The fundamental type corresponding to <link linkend="glong"><type>glong</type></link>.
</para></refsect2>
<refsect2>
<title><anchor id="G-TYPE-ULONG:CAPS" role="macro"/>G_TYPE_ULONG</title>
<indexterm><primary>G_TYPE_ULONG</primary></indexterm><programlisting>#define G_TYPE_ULONG			G_TYPE_MAKE_FUNDAMENTAL (9)
</programlisting>
<para>
The fundamental type corresponding to <link linkend="gulong"><type>gulong</type></link>.
</para></refsect2>
<refsect2>
<title><anchor id="G-TYPE-INT64:CAPS" role="macro"/>G_TYPE_INT64</title>
<indexterm><primary>G_TYPE_INT64</primary></indexterm><programlisting>#define G_TYPE_INT64			G_TYPE_MAKE_FUNDAMENTAL (10)
</programlisting>
<para>
The fundamental type corresponding to <link linkend="gint64"><type>gint64</type></link>.
</para></refsect2>
<refsect2>
<title><anchor id="G-TYPE-UINT64:CAPS" role="macro"/>G_TYPE_UINT64</title>
<indexterm><primary>G_TYPE_UINT64</primary></indexterm><programlisting>#define G_TYPE_UINT64			G_TYPE_MAKE_FUNDAMENTAL (11)
</programlisting>
<para>
The fundamental type corresponding to <link linkend="guint64"><type>guint64</type></link>.
</para></refsect2>
<refsect2>
<title><anchor id="G-TYPE-ENUM:CAPS" role="macro"/>G_TYPE_ENUM</title>
<indexterm><primary>G_TYPE_ENUM</primary></indexterm><programlisting>#define G_TYPE_ENUM			G_TYPE_MAKE_FUNDAMENTAL (12)
</programlisting>
<para>
The fundamental type from which all enumeration types are derived.
</para></refsect2>
<refsect2>
<title><anchor id="G-TYPE-FLAGS:CAPS" role="macro"/>G_TYPE_FLAGS</title>
<indexterm><primary>G_TYPE_FLAGS</primary></indexterm><programlisting>#define G_TYPE_FLAGS			G_TYPE_MAKE_FUNDAMENTAL (13)
</programlisting>
<para>
The fundamental type from which all flags types are derived.
</para></refsect2>
<refsect2>
<title><anchor id="G-TYPE-FLOAT:CAPS" role="macro"/>G_TYPE_FLOAT</title>
<indexterm><primary>G_TYPE_FLOAT</primary></indexterm><programlisting>#define G_TYPE_FLOAT			G_TYPE_MAKE_FUNDAMENTAL (14)
</programlisting>
<para>
The fundamental type corresponding to <link linkend="gfloat"><type>gfloat</type></link>.
</para></refsect2>
<refsect2>
<title><anchor id="G-TYPE-DOUBLE:CAPS" role="macro"/>G_TYPE_DOUBLE</title>
<indexterm><primary>G_TYPE_DOUBLE</primary></indexterm><programlisting>#define G_TYPE_DOUBLE			G_TYPE_MAKE_FUNDAMENTAL (15)
</programlisting>
<para>
The fundamental type corresponding to <link linkend="gdouble"><type>gdouble</type></link>.
</para></refsect2>
<refsect2>
<title><anchor id="G-TYPE-STRING:CAPS" role="macro"/>G_TYPE_STRING</title>
<indexterm><primary>G_TYPE_STRING</primary></indexterm><programlisting>#define G_TYPE_STRING			G_TYPE_MAKE_FUNDAMENTAL (16)
</programlisting>
<para>
The fundamental type corresponding to nul-terminated C strings.
</para></refsect2>
<refsect2>
<title><anchor id="G-TYPE-POINTER:CAPS" role="macro"/>G_TYPE_POINTER</title>
<indexterm><primary>G_TYPE_POINTER</primary></indexterm><programlisting>#define G_TYPE_POINTER			G_TYPE_MAKE_FUNDAMENTAL (17)
</programlisting>
<para>
The fundamental type corresponding to <link linkend="gpointer"><type>gpointer</type></link>.
</para></refsect2>
<refsect2>
<title><anchor id="G-TYPE-BOXED:CAPS" role="macro"/>G_TYPE_BOXED</title>
<indexterm><primary>G_TYPE_BOXED</primary></indexterm><programlisting>#define G_TYPE_BOXED			G_TYPE_MAKE_FUNDAMENTAL (18)
</programlisting>
<para>
The fundamental type from which all boxed types are derived.
</para></refsect2>
<refsect2>
<title><anchor id="G-TYPE-PARAM:CAPS" role="macro"/>G_TYPE_PARAM</title>
<indexterm><primary>G_TYPE_PARAM</primary></indexterm><programlisting>#define G_TYPE_PARAM			G_TYPE_MAKE_FUNDAMENTAL (19)
</programlisting>
<para>
The fundamental type from which all <link linkend="GParamSpec"><type>GParamSpec</type></link> types are derived.
</para></refsect2>
<refsect2>
<title><anchor id="G-TYPE-OBJECT:CAPS" role="macro"/>G_TYPE_OBJECT</title>
<indexterm><primary>G_TYPE_OBJECT</primary></indexterm><programlisting>#define G_TYPE_OBJECT			G_TYPE_MAKE_FUNDAMENTAL (20)
</programlisting>
<para>
The fundamental type for <link linkend="GObject"><type>GObject</type></link>.
</para></refsect2>
<refsect2>
<title><anchor id="G-TYPE-RESERVED-GLIB-FIRST:CAPS" role="macro"/>G_TYPE_RESERVED_GLIB_FIRST</title>
<indexterm><primary>G_TYPE_RESERVED_GLIB_FIRST</primary></indexterm><programlisting>#define G_TYPE_RESERVED_GLIB_FIRST	(21)
</programlisting>
<para>
First fundamental type number to create a new fundamental type id with
<link linkend="G-TYPE-MAKE-FUNDAMENTAL:CAPS"><function>G_TYPE_MAKE_FUNDAMENTAL()</function></link> reserved for GLib.
</para></refsect2>
<refsect2>
<title><anchor id="G-TYPE-RESERVED-GLIB-LAST:CAPS" role="macro"/>G_TYPE_RESERVED_GLIB_LAST</title>
<indexterm><primary>G_TYPE_RESERVED_GLIB_LAST</primary></indexterm><programlisting>#define G_TYPE_RESERVED_GLIB_LAST	(31)
</programlisting>
<para>
Last fundamental type number reserved for GLib.
</para></refsect2>
<refsect2>
<title><anchor id="G-TYPE-RESERVED-BSE-FIRST:CAPS" role="macro"/>G_TYPE_RESERVED_BSE_FIRST</title>
<indexterm><primary>G_TYPE_RESERVED_BSE_FIRST</primary></indexterm><programlisting>#define G_TYPE_RESERVED_BSE_FIRST	(32)
</programlisting>
<para>
First fundamental type number to create a new fundamental type id with
<link linkend="G-TYPE-MAKE-FUNDAMENTAL:CAPS"><function>G_TYPE_MAKE_FUNDAMENTAL()</function></link> reserved for BSE.
</para></refsect2>
<refsect2>
<title><anchor id="G-TYPE-RESERVED-BSE-LAST:CAPS" role="macro"/>G_TYPE_RESERVED_BSE_LAST</title>
<indexterm><primary>G_TYPE_RESERVED_BSE_LAST</primary></indexterm><programlisting>#define G_TYPE_RESERVED_BSE_LAST	(48)
</programlisting>
<para>
Last fundamental type number reserved for BSE.
</para></refsect2>
<refsect2>
<title><anchor id="G-TYPE-RESERVED-USER-FIRST:CAPS" role="macro"/>G_TYPE_RESERVED_USER_FIRST</title>
<indexterm><primary>G_TYPE_RESERVED_USER_FIRST</primary></indexterm><programlisting>#define G_TYPE_RESERVED_USER_FIRST	(49)
</programlisting>
<para>
First available fundamental type number to create new fundamental 
type id with <link linkend="G-TYPE-MAKE-FUNDAMENTAL:CAPS"><function>G_TYPE_MAKE_FUNDAMENTAL()</function></link>.
</para>

<!--
Local variables:
mode: sgml
sgml-parent-document: ("../gobject-docs.sgml" "book" "refsect2" "")
End:
--></refsect2>

</refsect1>




</refentry>
