<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<title>Instantiable classed types: objects</title>
<meta name="generator" content="DocBook XSL Stylesheets V1.69.1">
<link rel="start" href="index.html" title="GObject Reference Manual">
<link rel="up" href="ch02.html" title="The Glib Dynamic Type System">
<link rel="prev" href="gtype-non-instantiable.html" title="Non-Instantiable non-classed fundamental types">
<link rel="next" href="gtype-non-instantiable-classed.html" title="Non-instantiable classed types: Interfaces.">
<meta name="generator" content="GTK-Doc V1.4 (XML mode)">
<link rel="stylesheet" href="style.css" type="text/css">
<link rel="preface" href="pr01.html" title="Introduction">
<link rel="part" href="pt01.html" title="Part&#160;I.&#160;Concepts">
<link rel="chapter" href="ch01.html" title="Background">
<link rel="chapter" href="ch02.html" title="The Glib Dynamic Type System">
<link rel="chapter" href="chapter-gobject.html" title="The GObject base class">
<link rel="chapter" href="chapter-signal.html" title="The GObject messaging system">
<link rel="reference" href="rn01.html" title="API Reference">
<link rel="reference" href="rn02.html" title="Tools Reference">
<link rel="part" href="pt02.html" title="Part&#160;IV.&#160;Tutorial">
<link rel="chapter" href="howto-gobject.html" title="How To define and implement a new GObject?">
<link rel="chapter" href="howto-interface.html" title="How To define and implement Interfaces?">
<link rel="chapter" href="howto-signals.html" title="Howto create and use signals">
<link rel="part" href="pt03.html" title="Part&#160;V.&#160;Related Tools">
<link rel="chapter" href="tools-gob.html" title="GObject builder">
<link rel="chapter" href="tools-ginspector.html" title="Graphical inspection of Gobjects">
<link rel="chapter" href="tools-refdb.html" title="Debugging reference count problems">
<link rel="chapter" href="tools-gtkdoc.html" title="Writing API docs">
<link rel="index" href="ix01.html" title="Index">
<link rel="index" href="ix02.html" title="Index of deprecated symbols">
<link rel="index" href="ix03.html" title="Index of new symbols in 2.2">
<link rel="index" href="ix04.html" title="Index of new symbols in 2.4">
<link rel="index" href="ix05.html" title="Index of new symbols in 2.6">
<link rel="index" href="ix06.html" title="Index of new symbols in 2.8">
<link rel="index" href="ix07.html" title="Index of new symbols in 2.10">
</head>
<body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF">
<table class="navigation" id="top" width="100%" summary="Navigation header" cellpadding="2" cellspacing="2"><tr valign="middle">
<td><a accesskey="p" href="gtype-non-instantiable.html"><img src="left.png" width="24" height="24" border="0" alt="Prev"></a></td>
<td><a accesskey="u" href="ch02.html"><img src="up.png" width="24" height="24" border="0" alt="Up"></a></td>
<td><a accesskey="h" href="index.html"><img src="home.png" width="24" height="24" border="0" alt="Home"></a></td>
<th width="100%" align="center">GObject Reference Manual</th>
<td><a accesskey="n" href="gtype-non-instantiable-classed.html"><img src="right.png" width="24" height="24" border="0" alt="Next"></a></td>
</tr></table>
<div class="sect1" lang="en">
<div class="titlepage"><div><div><h2 class="title" style="clear: both">
<a name="gtype-instantiable-classed"></a>Instantiable classed types: objects</h2></div></div></div>
<p>
	  Types which are registered with a class and are declared instantiable are
	  what most closely resembles an <span class="emphasis"><em>object</em></span>. 
          Although <span class="type"><a href="gobject-The-Base-Object-Type.html#GObject">GObject</a></span>s (detailed in <a href="chapter-gobject.html" title="The GObject base class"><i>The GObject base class</i></a>) 
          are the most well known type of instantiable
          classed types, other kinds of similar objects used as the base of an inheritance 
          hierarchy have been externally developped and they are all built on the fundamental
          features described below.
        </p>
<p>
          For example, the code below shows how you could register 
          such a fundamental object type in the type system:
</p>
<pre class="programlisting">
typedef struct {
  GObject parent;
  /* instance members */
  int field_a;
} MamanBar;

typedef struct {
  GObjectClass parent;
  /* class members */
  void (*do_action_public_virtual) (MamanBar *self, guint8 i);

  void (*do_action_public_pure_virtual) (MamanBar *self, guint8 i);
} MamanBarClass;

#define MAMAN_BAR_TYPE (maman_bar_get_type ())

GType 
maman_bar_get_type (void)
{
  static GType type = 0;
  if (type == 0) {
    static const GTypeInfo info = {
      sizeof (MamanBarClass),
      NULL,           /* base_init */
      NULL,           /* base_finalize */
      (GClassInitFunc) foo_class_init,
      NULL,           /* class_finalize */
      NULL,           /* class_data */
      sizeof (MamanBar),
      0,              /* n_preallocs */
      (GInstanceInitFunc) NULL /* instance_init */
    };
    type = g_type_register_static (G_TYPE_OBJECT,
                                   "BarType",
                                   &amp;info, 0);
  }
  return type;
}
</pre>
<p>
	  Upon the first call to <code class="function">maman_bar_get_type</code>, the type named
          <span class="emphasis"><em>BarType</em></span> will be registered in the type system as inheriting
          from the type <span class="emphasis"><em>G_TYPE_OBJECT</em></span>.
	</p>
<p>
	  Every object must define two structures: its class structure and its 
	  instance structure. All class structures must contain as first member
	  a <span class="type"><a href="gobject-Type-Information.html#GTypeClass">GTypeClass</a></span> structure. All instance structures must contain as first
	  member a <span class="type"><a href="gobject-Type-Information.html#GTypeInstance">GTypeInstance</a></span> structure. The declaration of these C types,
          coming from <code class="filename">gtype.h</code> is shown below:
</p>
<pre class="programlisting">
struct _GTypeClass
{
  GType g_type;
};
struct _GTypeInstance
{
  GTypeClass *g_class;
};
</pre>
<p>
	  These constraints allow the type system to make sure that every object instance
	  (identified by a pointer to the object's instance structure) contains in its
	  first bytes a pointer to the object's class structure.
	</p>
<p>
	  This relationship is best explained by an example: let's take object B which
	  inherits from object A:
</p>
<pre class="programlisting">
/* A definitions */
typedef struct {
  GTypeInstance parent;
  int field_a;
  int field_b;
} A;
typedef struct {
  GTypeClass parent_class;
  void (*method_a) (void);
  void (*method_b) (void);
} AClass;

/* B definitions. */
typedef struct {
  A parent;
  int field_c;
  int field_d;
} B;
typedef struct {
  AClass parent_class;
  void (*method_c) (void);
  void (*method_d) (void);
} BClass;
</pre>
<p>	  
	  The C standard mandates that the first field of a C structure is stored starting
	  in the first byte of the buffer used to hold the structure's fields in memory.
	  This means that the first field of an instance of an object B is A's first field
	  which in turn is GTypeInstance's first field which in turn is g_class, a pointer
	  to B's class structure.
	</p>
<p>
	  Thanks to these simple conditions, it is possible to detect the type of every
	  object instance by doing: 
</p>
<pre class="programlisting">
B *b;
b-&gt;parent.parent.g_class-&gt;g_type
</pre>
<p>
	  or, more quickly:
</p>
<pre class="programlisting">
B *b;
((GTypeInstance*)b)-&gt;g_class-&gt;g_type
</pre>
<p>
	</p>
<p>
	  Instanciation of these types can be done with 
    <code class="function"><a href="gobject-Type-Information.html#g-type-create-instance">g_type_create_instance</a></code>:
</p>
<pre class="programlisting">
GTypeInstance* g_type_create_instance (GType          type);
void           g_type_free_instance   (GTypeInstance *instance);
</pre>
<p>
	  <code class="function"><a href="gobject-Type-Information.html#g-type-create-instance">g_type_create_instance</a></code> will lookup the type information
	  structure associated to the type requested. Then, the instance size and instanciation
	  policy (if the n_preallocs field is set to a non-zero value, the type system allocates
	  the object's instance structures in chunks rather than mallocing for every instance)
	  declared by the user are used to get a buffer to hold the object's instance
	  structure.
	</p>
<p>
	  If this is the first instance of the object ever created, the type system must create
	  a class structure: it allocates a buffer to hold the object's class structure and
	  initializes it. It first copies the parent's class structure over this structure
	  (if there is no parent, it initializes it to zero). It then invokes the 
	  base_class_initialization functions (<span class="type"><a href="gobject-Type-Information.html#GBaseInitFunc">GBaseInitFunc</a></span>) from topmost 
	  fundamental object to bottom-most most derived object. The object's class_init 
	  (<span class="type"><a href="gobject-Type-Information.html#GClassInitFunc">GClassInitFunc</a></span>) function is invoked afterwards to complete
	  initialization of the class structure.
	  Finally, the object's interfaces are initialized (we will discuss interface initialization
	  in more detail later).
<sup>[<a name="class-init" href="#ftn.class-init">3</a>]</sup>
	</p>
<p>
	  Once the type system has a pointer to an initialized class structure, it sets the object's
	  instance class pointer to the object's class structure and invokes the object's
	  instance_init (<span class="type"><a href="gobject-Type-Information.html#GInstanceInitFunc">GInstanceInitFunc</a></span>)functions, from top-most fundamental 
	  type to bottom-most most derived type.
	</p>
<p>
	  Object instance destruction through <code class="function"><a href="gobject-Type-Information.html#g-type-free-instance">g_type_free_instance</a></code> is very simple:
	  the instance structure is returned to the instance pool if there is one and if this was the
	  last living instance of the object, the class is destroyed.
	</p>
<p>
	  Class destruction
          <sup>[<a name="id2818017" href="#ftn.id2818017">4</a>]</sup>
          (the concept of destruction is sometimes partly refered to as finalization 
          in Gtype) is the symmetric process of the initialization: interfaces are 
          destroyed first. 
          Then, the most derived 
	  class_finalize (<span class="type">ClassFinalizeFunc</span>) function is invoked. The 
	  base_class_finalize (<span class="type"><a href="gobject-Type-Information.html#GBaseFinalizeFunc">GBaseFinalizeFunc</a></span>) functions are 
	  Finally invoked from bottom-most most-derived type to top-most fundamental type and 
	  the class structure is freed.
	</p>
<p>
	As many readers have now understood it, the base initialization/finalization process is
	very similar to the C++ Constructor/Destructor paradigm. The practical details are quite different
        though and it is important not to get confused by the superficial similarities. Typically, what 
        most users have grown to know as a C++ constructor (that is, a list of
        object methods invoked on the object instance once for each type of the inheritance hierachy) does
        not exist in GType and must be built on top of the facilities offered by GType. Similarly,
        GTypes have no instance destruction mechanism. It is
	the user's responsibility to implement correct destruction semantics on top
	of the existing GType code. (this is what GObject does. See 
	<a href="chapter-gobject.html" title="The GObject base class"><i>The GObject base class</i></a>)
      </p>
<p>
       For example, if the object B which derives from A is instantiated, GType will only invoke the 
       instance_init callback of object B while a C++ runtime will invoke the constructor of the object 
       type A first and then of the object type B. Furthermore, the C++ code equivalent to the base_init 
       and class_init callbacks of GType is usually not needed because C++ cannot really create object 
       types at runtime.
      </p>
<p>
	  The instanciation/finalization process can be summarized as follows:
	</p>
<div class="table">
<a name="id2818101"></a><p class="title"><b>Table&#160;1.&#160;GType Instantiation/Finalization</b></p>
<table summary="GType Instantiation/Finalization" border="1">
<colgroup>
<col align="left">
<col align="left">
<col align="left">
</colgroup>
<thead><tr>
<th align="left">Invocation time</th>
<th align="left">Function Invoked</th>
<th align="left">Function's parameters</th>
</tr></thead>
<tbody>
<tr>
<td align="left">First call to <code class="function"><a href="gobject-Type-Information.html#g-type-create-instance">g_type_create_instance</a></code> for target type</td>
<td align="left">type's base_init function</td>
<td align="left">On the inheritance tree of classes from fundamental type to target type. 
		  base_init is invoked once for each class structure.</td>
</tr>
<tr>
<td align="left">First call to <code class="function"><a href="gobject-Type-Information.html#g-type-create-instance">g_type_create_instance</a></code> for target type</td>
<td align="left">target type's class_init function</td>
<td align="left">On target type's class structure</td>
</tr>
<tr>
<td align="left">First call to <code class="function"><a href="gobject-Type-Information.html#g-type-create-instance">g_type_create_instance</a></code> for target type</td>
<td align="left">interface initialization, see 
		  <a href="gtype-non-instantiable-classed.html#gtype-non-instantiable-classed-init" title="Interface Initialization">the section called &#8220;Interface Initialization&#8221;</a>
</td>
<td align="left">&#160;</td>
</tr>
<tr>
<td align="left">Each call to <code class="function"><a href="gobject-Type-Information.html#g-type-create-instance">g_type_create_instance</a></code> for target type</td>
<td align="left">target type's instance_init function</td>
<td align="left">On object's instance</td>
</tr>
<tr>
<td align="left">Last call to <code class="function"><a href="gobject-Type-Information.html#g-type-free-instance">g_type_free_instance</a></code> for target type</td>
<td align="left">interface destruction, see
		  <a href="gtype-non-instantiable-classed.html#gtype-non-instantiable-classed-dest" title="Interface Destruction">the section called &#8220;Interface Destruction&#8221;</a>
</td>
<td align="left">&#160;</td>
</tr>
<tr>
<td align="left">Last call to <code class="function"><a href="gobject-Type-Information.html#g-type-free-instance">g_type_free_instance</a></code> for target type</td>
<td align="left">target type's class_finalize function</td>
<td align="left">On target type's class structure</td>
</tr>
<tr>
<td align="left">Last call to <code class="function"><a href="gobject-Type-Information.html#g-type-free-instance">g_type_free_instance</a></code> for target type</td>
<td align="left">type's base_finalize function</td>
<td align="left">On the inheritance tree of classes from fundamental type to target type. 
		  base_finalize is invoked once for each class structure.</td>
</tr>
</tbody>
</table>
</div>
<p>
	</p>
<div class="footnotes">
<br><hr width="100" align="left">
<div class="footnote"><p><sup>[<a name="ftn.class-init" href="#class-init">3</a>] </sup>
The class initialization process is entirely implemented in 
<code class="function">type_class_init_Wm</code> in <code class="filename">gtype.c</code>.
</p></div>
<div class="footnote"><p><sup>[<a name="ftn.id2818017" href="#id2818017">4</a>] </sup>It is implemented in <code class="function">type_data_finalize_class_U</code> 
                  (in <code class="filename">gtype.c</code>.
            </p></div>
</div>
</div>
</body>
</html>
