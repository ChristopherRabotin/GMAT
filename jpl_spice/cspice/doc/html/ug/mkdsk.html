<HTML>
<HEAD>
<TITLE> MKDSK User's Guide </TITLE>
</HEAD>

<BODY style="color: rgb(0, 0, 0); background-color: rgb(255, 255, 255);">

<A NAME="top"></A>

<TABLE STYLE="text-align: left; margin-left: auto; margin-right: auto; width: 800px;" BORDER="0" CELLPADDING="5" CELLSPACING="2">
<TBODY>
<TR>
  <TD STYLE="background-color: rgb(153, 153, 153); vertical-align: middle; text-align: center;">
  <DIV ALIGN="right">
    <SMALL><SMALL><A HREF="index.html">Index Page</A></SMALL></SMALL>
  </DIV>
  <B>MKDSK User's Guide</B> </TD>
</TR>
<TR>
  <TD STYLE="vertical-align: top;">

<H2> Table of Contents
</H2>

<PRE>

   <A HREF="#MKDSK User's Guide">MKDSK User's Guide</A>
      <A HREF="#Abstract">Abstract</A>
      <A HREF="#Summary">Summary</A>
      <A HREF="#References">References</A>
      <A HREF="#Usage">Usage</A>
      <A HREF="#Running MKDSK">Running MKDSK</A>

   <A HREF="#MKDSK Setup File">MKDSK Setup File</A>
      <A HREF="#Setup File Format">Setup File Format</A>
      <A HREF="#Setup File Assignments">Setup File Assignments</A>
         <A HREF="#Required Assignments">Required Assignments</A>
         <A HREF="#Conditional Assignments">Conditional Assignments</A>
         <A HREF="#Optional Assignments">Optional Assignments</A>
      <A HREF="#Detailed Description of Setup File Keywords">Detailed Description of Setup File Keywords</A>

   <A HREF="#Setup File Examples">Setup File Examples</A>
         <A HREF="#Input Using Latitudinal Coordinates and Plate Type 2">Input Using Latitudinal Coordinates and Plate Type 2</A>
         <A HREF="#Input Using Planetodetic Coordinates and Plate Type 1">Input Using Planetodetic Coordinates and Plate Type 1</A>
         <A HREF="#Input Using Planetocentric Coordinates and Plate Type 5">Input Using Planetocentric Coordinates and Plate Type 5</A>

   <A HREF="#Input Data File">Input Data File</A>
      <A HREF="#Units">Units</A>
      <A HREF="#Reference Frame">Reference Frame</A>
      <A HREF="#Vertex order">Vertex order</A>
         <A HREF="#Vertex IDs">Vertex IDs</A>
      <A HREF="#Plate Data File Type 1 Plate-Vertex Table">Plate Data File Type 1 (Plate-Vertex Table)</A>
         <A HREF="#Sample Plate-Vertex Table Input File">Sample Plate-Vertex Table Input File</A>
      <A HREF="#Plate Data File Type 2 Gaskell Shape Model">Plate Data File Type 2 (Gaskell Shape Model)</A>
         <A HREF="#Sample Gaskell Shape Model Input File">Sample Gaskell Shape Model Input File</A>
      <A HREF="#Plate Data File Type 3 Vertex-Facet Table">Plate Data File Type 3 (Vertex-Facet Table)</A>
         <A HREF="#Sample Vertex-Facet Input File">Sample Vertex-Facet Input File</A>
      <A HREF="#Rosetta/OSIRIS ``ver'' File">Rosetta/OSIRIS ``ver'' File</A>
         <A HREF="#Sample Rosetta/OSIRIS ``ver'' File">Sample Rosetta/OSIRIS ``ver'' File</A>
      <A HREF="#ASCII Height Grid File">ASCII Height Grid File</A>
         <A HREF="#Domain Coordinates">Domain Coordinates</A>
         <A HREF="#Heights">Heights</A>
         <A HREF="#Height Grid File Format">Height Grid File Format</A>
         <A HREF="#Height Grid Data Mapping">Height Grid Data Mapping</A>
         <A HREF="#Polar Caps">Polar Caps</A>
         <A HREF="#Longitude Wrapping">Longitude Wrapping</A>

   <A HREF="#Output DSK File">Output DSK File</A>

   <A HREF="#Appendix A: Spatial Index and Voxels">Appendix A: Spatial Index and Voxels</A>

</PRE>

<HR SIZE=3 NOSHADE>

<BR><BR>
<A NAME="MKDSK User's Guide"></A>
<p align="right"><a href="#top"><small>Top</small></a></p>
<H1> MKDSK User's Guide
</H1><HR SIZE=3 NOSHADE><P><BR><BR><BR>
   Last revised on 2021 DEC 31 by N. J. Bachman.
<P>
 
<BR><BR>
<A NAME="Abstract"></A>
<p align="right"><a href="#top"><small>Top</small></a></p>
<H2> Abstract
</H2><HR ALIGN="LEFT" WIDTH=50% ><P><BR><BR>
   MKDSK is a utility program that creates a SPICE Digital Shape Kernel
   (DSK) file from a text file containing shape data for an extended
   object.
<P>
 
<BR><BR>
<A NAME="Summary"></A>
<p align="right"><a href="#top"><small>Top</small></a></p>
<H2> Summary
</H2><HR ALIGN="LEFT" WIDTH=50% ><P><BR><BR>
   MKDSK converts a text file containing surface shape and size data to a
   binary Digital Shape Kernel (DSK).
<P>
 
   The MKDSK program requires as input a setup file containing input
   parameters and a second file containing the shape data to be processed.
<P>
 
   Data files provided to this program either represent an object's surface
   as a collection of triangular plates, or as a height grid.
<P>
 
   Currently the only supported output DSK data type is type 2: this type
   represents the surface of a specified body as a collection of triangular
   plates.
<P>
 
   The program allows the user to optionally specify some descriptive text
   in a separate file, called the ``comment file,'' to be placed into the
   ``comment area'' of the DSK file. (Doing this is highly recommended.)
<P>
 
   For archival documentation purposes the content of the MKDSK setup file
   is automatically placed at the end of the ``comment area'' of the DSK
   file.
<P>
 
<BR><BR>
<A NAME="References"></A>
<p align="right"><a href="#top"><small>Top</small></a></p>
<H2> References
</H2><HR ALIGN="LEFT" WIDTH=50% ><P><BR><BR>
<UL>
<TT>1.</TT> DSK Required Reading (<a href="../req/dsk.html">dsk.req</a>)
<BR><BR></UL>
<UL>
<TT>2.</TT> NAIF Integer ID Codes (<a href="../req/naif_ids.html">naif_ids.req</a>)
<BR><BR></UL>
<UL>
<TT>3.</TT> Frames Required Reading (<a href="../req/frames.html">frames.req</a>)
<BR><BR></UL>
<UL>
<TT>4.</TT> Kernel Required Reading (<a href="../req/kernel.html">kernel.req</a>)
<BR><BR></UL>
<UL>
<TT>5.</TT> DSKBRIEF User's Guide (<a href="../ug/dskbrief.html">dskbrief.ug</a>)
<BR><BR></UL>
<UL>
<TT>6.</TT> DSKEXP User's Guide (<a href="../ug/dskexp.html">dskexp.ug</a>)
<BR><BR></UL>
<UL>
<TT>7.</TT> COMMNT User's Guide (<a href="../ug/commnt.html">commnt.ug</a>)
<BR><BR></UL>
<UL>
<TT>8.</TT> Convert User's Guide (<a href="../ug/convert.html">convert.ug</a>)
<BR><BR></UL>
<UL>
<TT>9.</TT> SPICE Tutorials. Thes are available on the NAIF web site at
<BR><BR></UL>
<PRE>
            https://naif.jpl.nasa.gov/naif/tutorials.html
</PRE>
<BR><BR>
<A NAME="Usage"></A>
<p align="right"><a href="#top"><small>Top</small></a></p>
<H2> Usage
</H2><HR ALIGN="LEFT" WIDTH=50% ><P><BR><BR>
   The diagram below shows MKDSK's command options. This diagram can be
   displayed by executing the command
<P>
 
<PRE>
   mkdsk -u
</PRE>
<PRE>
   Program usage:
 
            &gt; mkdsk   [-setup &lt;setup file name&gt;]
                      [-input &lt;input shape data file name&gt;]
                      [-output &lt;output DSK file name&gt;]
                      [-h|-help]
                      [-t|-template]
                      [-u|-usage]
                      [-v|-version]
</PRE>
   If a setup file name isn't provided on the command line, MKDSK will
   prompt for it. It will not prompt for the input or output file names;
   these file names must be provided on the command line or in the setup
   file. If the input or output file names are provided on the command
   line, any corresponding file names assigned using setup keywords are
   ignored. The input file must already exist and the output file must be a
   new file.
<P>
 
<BR><BR>
<A NAME="Running MKDSK"></A>
<p align="right"><a href="#top"><small>Top</small></a></p>
<H2> Running MKDSK
</H2><HR ALIGN="LEFT" WIDTH=50% ><P><BR><BR>
   You will need a setup file to run MKDSK. The format for the setup file
   is described below.
<P>
 
   As the program runs, it will print out messages describing its progress.
   If an error is encountered, the program normally will display a
   diagnostic message. The program attempts to delete the output file if it
   encounters an error while creating it.
<P>
 
   Only one DSK file containing one segment may be generated during a
   single MKDSK run.
<P>
 
<BR><BR>
<A NAME="MKDSK Setup File"></A>
<p align="right"><a href="#top"><small>Top</small></a></p>
<H1> MKDSK Setup File
</H1><HR SIZE=3 NOSHADE><P><BR><BR><BR>
<BR><BR>
<A NAME="Setup File Format"></A>
<p align="right"><a href="#top"><small>Top</small></a></p>
<H2> Setup File Format
</H2><HR ALIGN="LEFT" WIDTH=50% ><P><BR><BR>
   Other than the input and output file names, which may be provided on the
   command line, the program requires all inputs such as surface and
   central body name or ID, frame name or ID, types of input and output
   data, spatial coverage bounds, etc. to be provided in a setup file.
<P>
 
   The format of this file must conform to the SPICE text kernel
   specification. This format uses a ``keyword = value'' syntax for
   assignment of parameter values.
<P>
 
   The Kernel Required Reading document, which is included in the SPICE
   Toolkit, provides details of this format specification. The ``Intro to
   Kernels'' tutorial, which is available on the NAIF web site
<P>
 
<PRE>
   http://naif.jpl.nasa.gov/naif/tutorials.html
</PRE>
   may also be helpful.
<P>
 
   Examples of setup files are included in this document. Often the easiest
   way to create a setup file for your own use is to modify an existing
   example.
<P>
 
   For quick reference, a few details concerning the SPICE text kernel
   format are listed below:
<P>
 
   The names of the setup file keywords must be strictly uppercase while
   parameterized keyword values (for example 'DEGREES'), reference frame
   names, and body names may be upper, lower or mixed case. File names
   should be assumed to be case sensitive to maximize portability. Any
   white space preceding or following keyword names, values and the equal
   sign is ignored.
<P>
 
   All character string values and time strings must be enclosed in single
   quotes. They must be provided on a single line or continued with the '+'
   character as the final character of the value. The portion of the string
   value on a single line can be no longer than 80 characters. When
   multiple values are allowed and used, enclose the complete set in the
   "()" characters: KEYWORD = ( 'value1' 'value2' ... ).
<P>
 
<BR><BR>
<A NAME="Setup File Assignments"></A>
<p align="right"><a href="#top"><small>Top</small></a></p>
<H2> Setup File Assignments
</H2><HR ALIGN="LEFT" WIDTH=50% ><P><BR><BR>
   All assignments are either required, conditional or optional as
   described below.
<P>
 
   A setup file may contain blank lines. Non-printing characters including
   TAB should not be used in setup file lines containing keyword
   assignments or in blank lines separating assignment lines within the
   data sections of a setup file. The program may not be able to parse
   correctly any of the setup file lines that contain non-printing
   characters and will signal a setup file parsing error on some computer
   platforms.
<P>
 
<BR><BR>
<A NAME="Required Assignments"></A>
<p align="right"><a href="#top"><small>Top</small></a></p>
<H3> Required Assignments
</H3><P><BR><BR>
   The following assignments must be present in a setup file:
<P>
 
<PRE>
   SURFACE_NAME        = 'Surface name' (name of the specific
                         shape data set for the central body)
                         An ID code may be specified as a
                         single-quoted string.
   CENTER_NAME         = 'Central body name'. An ID code may be
                         specified as a single-quoted string.
   REF_FRAME_NAME      = 'Reference frame name'
   START_TIME          = 'Start time'
   STOP_TIME           = 'Stop time'
   DATA_CLASS          = 1 to indicate a surface that can be
                         represented as a single-valued function
                         of its domain coordinates.
 
                         2 indicates a general surface. Surfaces
                         that have multiple points for a given pair
                         of domain coordinates---for example,
                         multiple radii for a given latitude and
                         longitude---belong to class 2.
 
   INPUT_DATA_UNITS    = ( 'ANGLES    = angular unit'
                           'DISTANCES = distance unit' )
 
   COORDINATE_SYSTEM   = 'LATITUDINAL' or
                         'RECTANGULAR' or
                         'PLANETODETIC'
 
   DATA_TYPE           = 2 (triangular plates)
                         This is the data type of the single
                         segment in the output file created
                         by this program. Currently only type 2
                         is supported.
 
   PLATE_TYPE          = an integer in the range 1:5 specifying
                         the input data file format. This assignment
                         is applicable only to output data type 2.
                         See the chapter ``Input Data File'' for
                         further information.
</PRE>
   The following assignments are required in the setup file if their values
   are not provided on the command line:
<P>
 
<PRE>
   INPUT_SHAPE_FILE    = 'Name of input shape data file'
   OUTPUT_DSK_FILE     = 'Name of output DSK file '
</PRE>
<BR><BR>
<A NAME="Conditional Assignments"></A>
<p align="right"><a href="#top"><small>Top</small></a></p>
<H3> Conditional Assignments
</H3><P><BR><BR>
   One or more of the following assignments may be needed depending on the
   kind of input data being used and other conditions.
<P>
 
<PRE>
 
 
      KERNELS_TO_LOAD     =  ( 'kernel_1' 'kernel_2' ... )
                             Leapseconds kernel (if not specified
                             by the LEAPSECONDS_KERNEL assignment)
                             and names of additional kernels, for
                             example frame kernels to provide
                             body-fixed frame specifications.
 
 
      LEAPSECONDS_KERNEL  =  'file name' A leapseconds kernel
                             must be specified using either
                             this assignment or using a
                             KERNELS_TO_LOAD assignment.
 
      NAIF_BODY_NAME      += 'body name'
      NAIF_BODY_CODE      += integer ID code
                             These assignments are needed if
                             the central body name is not
                             built into SPICE and its body
                             name-ID association is not defined
                             in a kernel listed in a
                             KERNELS_TO_LOAD assignment.
 
      NAIF_SURFACE_NAME   += 'surface name'
      NAIF_SURFACE_CODE   += integer surface ID code
      NAIF_SURFACE_BODY   += integer body ID code
                             These assignments are needed if
                             the surface name-ID association
                             is not defined in a kernel listed
                             in a KERNELS_TO_LOAD assignment.
 
   For latitudinal coordinates:
 
      MINIMUM_LATITUDE    = lower latitude bound in selected
                            angular units
      MAXIMUM_LATITUDE    = upper latitude bound in selected
                            angular units
      MINIMUM_LONGITUDE   = lower longitude bound in selected
                            angular units
      MAXIMUM_LONGITUDE   = upper longitude bound in selected
                            angular units
 
   For rectangular coordinates:
 
      MINIMUM_X           = lower X coordinate bound in selected units
      MAXIMUM_X           = upper X coordinate bound in selected units
      MINIMUM_Y           = lower Y coordinate bound in selected units
      MAXIMUM_Y           = upper Y coordinate bound in selected units
 
   For planetodetic coordinates:
 
      MINIMUM_LATITUDE    = lower latitude bound in selected units
      MAXIMUM_LATITUDE    = upper latitude bound in selected units
      MINIMUM_LONGITUDE   = lower longitude bound in selected units
      MAXIMUM_LONGITUDE   = upper longitude bound in selected units
 
      EQUATORIAL_RADIUS   = equatorial spheroid radius in selected units
      POLAR_RADIUS        = polar spheroid radius in selected units
 
   For data type 2, plate type 5, the following additional assignments
   are required:
 
      WRAP_LONGITUDE              = connect leftmost column to
                                    rightmost column: 'YES' or 'NO'
      MAKE_NORTH_POLAR_CAP        = extend plate set to north pole:
                                    'YES' or 'NO'
      MAKE_SOUTH_POLAR_CAP        = extend plate set to south pole:
                                    'YES' or 'NO'
      INPUT_GRID_ORDER_ROW_MAJOR  = input data set is row-major:
                                    'YES' or 'NO'
      COLUMN_VALUE_ORDER_TOP_DOWN = input data set is top-down:
                                    'YES' or 'NO'
      ROW_VALUE_ORDER_LEFT_RIGHT  = input data set is left-right:
                                    'YES' or 'NO'
 
      NUMBER_OF_ROWS              = number of rows in grid
      NUMBER_OF_COLUMNS           = number of columns in grid
      COLUMN_STEP_SIZE            = column separation: longitude or X
                                    step
      ROW_STEP_SIZE               = row separation: latitude or Y step
      HEIGHT_SCALE                = value by which to multiply the
                                    height data to convert to km
 
   For data type 2, plate type 5,  latitudinal or rectangular
   coordinates, the following additional assignment
   is required:
 
      HEIGHT_REFERENCE            = value to add to input heights;
                                    units are always km
 
   For data type 2, plate type 5, rectangular coordinates, the
   following additional assignments are required:
 
      LEFT_COLUMN_X_COORDINATE    = X-coordinate of leftmost column of
                                    grid
      TOP_ROW_Y_COORDINATE        = Y-coordinate of top row of grid
 
   For data type 2, plate type 5, latitudinal or planetodetic
   coordinates, the following additional assignments
   are required:
 
      LEFT_COLUMN_LONGITUDE       = longitude of leftmost column of
                                    grid
      TOP_ROW_LATITUDE            = latitude of top row of grid
 
</PRE>
<BR><BR>
<A NAME="Optional Assignments"></A>
<p align="right"><a href="#top"><small>Top</small></a></p>
<H3> Optional Assignments
</H3><P><BR><BR>
<PRE>
   COMMENT_FILE          = 'Name of optional comment file'
 
   FINE_VOXEL_SCALE      = Double precision value &gt; 0.0
   COARSE_VOXEL_SCALE    = Integer &gt;= 1
 
   Optional assignment:
   MAKE_VERTEX_PLATE_MAP =  'YES' or 'NO'
                            If this assignment is not provided,
                            MKDSK will not create a vertex-plate
                            mapping.
</PRE>
<BR><BR>
<A NAME="Detailed Description of Setup File Keywords"></A>
<p align="right"><a href="#top"><small>Top</small></a></p>
<H2> Detailed Description of Setup File Keywords
</H2><HR ALIGN="LEFT" WIDTH=50% ><P><BR><BR>
   See the DSK Required Reading [1] for definitions of terms used in the
   discussion below.
<P>
 
<DL><DT>
<B>
 CENTER_NAME
</B><BR><BR>
<DD>
 Name of central body with which the surface is associated. An integer
ID code enclosed in single quotes may be provided instead of a name,
e.g. '499' instead of 'MARS'. This assignment is required.<BR>
</DL>
<DL><DT>
<B>
 COARSE_VOXEL_SCALE
</B><BR><BR>
<DD>
 This assignment is optional and need not be used for most applications.
It is applicable only to type 2 segments. See the section ``Appendix A:
Spatial Index and Voxels'' below for a more detailed discussion. The
coarse voxel scale is an integer representing the ratio of the edge
length of coarse voxels to fine voxels. This number must be greater
than or equal to 1.<BR>
</DL>
<DL><DT>
<B>
 COLUMN_STEP_SIZE
</B><BR><BR>
<DD>
 Applies only to height grid inputs for data type 2 segments. This is
the grid's step size for longitude or for X, depending on the specified
coordinate system. Units are given by the INPUT_DATA_UNITS assignment.<BR>
</DL>
<DL><DT>
<B>
 COLUMN_VALUE_ORDER_TOP_DOWN
</B><BR><BR>
<DD>
 Applies only to height grid inputs for data type 2 segments. Indicates
that columns of the vertex grid are filled in in top-to-bottom order
(in order of decreasing latitude or Y values) as data are read from the
input file. (This does not imply that adjacent elements of a column in
the vertex grid are filled in consecutively: see the description of
INPUT_GRID_ORDER_ROW_MAJOR.) Values are 'YES' or 'NO'.<BR>
</DL>
<DL><DT>
<B>
 COMMENT_FILE
</B><BR><BR>
<DD>
 Comment file name. This keyword is used if you want to include comments
provided in this file in the comment area of the DSK file. Include full
or relative path specification.<BR>
</DL>
<DL><DT>
<B>
 COORDINATE_SYSTEM
</B><BR><BR>
<DD>
 Name of the coordinate system used to represent the bounds of spatial
coverage of the data set. The supported values are 'LATITUDINAL',
'PLANETODETIC', and 'RECTANGULAR'. 'LATITUDINAL' refers to
planetocentric coordinates.<BR>
</DL>
<DL><DT>
<B>
 DATA_CLASS
</B><BR><BR>
<DD>
 Code identifying the category of topography represented by the surface.
Supported codes are: 1 for a surface that can be represented as a
single-valued function of its domain coordinates; an example is a
surface defined by a function that maps each planetodetic longitude and
latitude pair to a unique altitude. 2 for arbitrary topography (e.g.
that of a dumbbell-shaped asteroid). This assignment is required.<BR>
</DL>
<DL><DT>
<B>
 DATA_TYPE
</B><BR><BR>
<DD>
 Code indicating the DSK data type of the DSK segment to be created.
Currently the only supported code is 2 (triangular plates). This
assignment is required.<BR>
</DL>
<DL><DT>
<B>
 EQUATORIAL_RADIUS
</B><BR><BR>
<DD>
 Applies only to planetodetic coordinates. This is the equatorial radius
of the reference ellipsoid. Units are always km.<BR>
</DL>
<DL><DT>
<B>
 FINE_VOXEL_SCALE
</B><BR><BR>
<DD>
 This assignment is optional and need not be used for most applications.
It is applicable only to type 2 segments. See the section ``Appendix A:
Spatial Index and Voxels'' below for a more detailed discussion. The
fine voxel scale is a double precision number. Normally the fine voxel
scale should be set to at least 1.0.<BR>
</DL>
<DL><DT>
<B>
 HEIGHT_REFERENCE
</B><BR><BR>
<DD>
 Applies only to height grid inputs for data type 2 segments using
'LATITUDINAL' or 'RECTANGULAR' coordinates. Input height values are
scaled by the height scale and then added to the height reference value
to produce vertex heights. Units are always km.<BR>
</DL>
<DL><DT>
<B>
 HEIGHT_SCALE
</B><BR><BR>
<DD>
 Applies only to height grid inputs for data type 2 segments. Input
height values are multiplied by the height scale to convert them to km.
This value is unitless.<BR>
</DL>
<DL><DT>
<B>
 INPUT_DATA_UNITS
</B><BR><BR>
<DD>
 Array of two strings specifying the units of the input data. The right
hand side of the assignment has the format ( 'ANGLES = angular unit'
'DISTANCES = distance unit' ). The units accepted by the SPICE routine
CONVRT are accepted in this assignment. This assignment is required.<BR>
</DL>
<DL><DT>
<B>
 INPUT_GRID_ORDER_ROW_MAJOR
</B><BR><BR>
<DD>
 Applies only to height grid inputs for data type 2 segments. Indicates
that rows of the vertex grid are filled sequentially as data are read
from the input file. The alternative is that columns of the vertex grid
are filled in sequentially. Values are 'YES' or 'NO'.<BR>
</DL>
<DL><DT>
<B>
 INPUT_SHAPE_FILE
</B><BR><BR>
<DD>
 Name of input shape data file. This keyword must be used if the input
data file name is not provided on the command line; if the input data
file name is supplied on the command line, this assignment is ignored.
Include full or relative path specification. The file must exist.<BR>
</DL>
<DL><DT>
<B>
 KERNELS_TO_LOAD
</B><BR><BR>
<DD>
 This is the SPICE meta-kernel keyword that identifies kernels to load.
The right hand side is a list of single-quoted kernel names; the list
is enclosed in parentheses. A leapseconds kernel may be specified using
this assignment rather than a LEAPSECONDS_FILE assignment. Other
kernels that might be needed are frame kernels, a kernel defining body
name-ID associations, and a kernel defining surface name-ID
associations.<BR>
</DL>
<DL><DT>
<B>
 LEAPSECONDS_FILE
</B><BR><BR>
<DD>
 leapseconds file name. This is the SPICE LSK file name, including full
or relative path specification. A leapseconds kernel can be specified
using a KERNELS_TO_LOAD assignment instead of this one. Specification
of a leapseconds kernel by one of these means is required. Only one
leapseconds kernel should be specified, but if distinct leapseconds
kernels are specified using both keywords, the one specified by the
LEAPSECONDS_FILE keyword is loaded last and hence overrides the other.<BR>
</DL>
<DL><DT>
<B>
 LEFT_COLUMN_LONGITUDE
</B><BR><BR>
<DD>
 Applies only to height grid inputs for data type 2 segments, when the
coordinate system is 'LATITUDINAL' or 'PLANETODETIC'. This is the
longitude of the grid's leftmost column. Units are given by the
INPUT_DATA_UNITS assignment.<BR>
</DL>
<DL><DT>
<B>
 LEFT_COLUMN_X_COORDINATE
</B><BR><BR>
<DD>
 Applies only to height grid inputs for data type 2 segments, when the
coordinate system is 'RECTANGULAR'. This is the X value of the grid's
leftmost column. Units are given by the INPUT_DATA_UNITS assignment.<BR>
</DL>
<DL><DT>
<B>
 MAKE_NORTH_POLAR_CAP
</B><BR><BR>
<DD>
 Applies only to height grid inputs for data type 2 segments, when the
coordinate system is 'LATITUDINAL' or 'PLANETODETIC'. Indicates that
the vertex grid should be augmented by a vertex at the north pole, and
that plates should be formed using this vertex and the vertices of the
grid's top row. Values are 'YES' or 'NO'.<BR>
</DL>
<DL><DT>
<B>
 MAKE_SOUTH_POLAR_CAP
</B><BR><BR>
<DD>
 Applies only to height grid inputs for data type 2 segments, when the
coordinate system is 'LATITUDINAL' or 'PLANETODETIC'. Indicates that
the vertex grid should be augmented by a vertex at the south pole, and
that plates should be formed using this vertex and the vertices of the
grid's bottom row. Values are 'YES' or 'NO'.<BR>
</DL>
<DL><DT>
<B>
 MAKE_VERTEX_PLATE_MAP
</B><BR><BR>
<DD>
 Indicates that the optional vertex-plate mapping data structure should
be created. Values are 'YES' or 'NO'.<BR>
</DL>
<DL><DT>
<B>
 MAXIMUM_LATITUDE
</B><BR><BR>
<DD>
 Upper latitude bound of spatial coverage in selected angular units.
Units are those specified by the INPUT_DATA_UNITS assignment. This
assignment is required when the coordinate system is LATITUDINAL or
PLANETODETIC.<BR>
</DL>
<DL><DT>
<B>
 MAXIMUM_LONGITUDE
</B><BR><BR>
<DD>
 Upper longitude bound of spatial coverage in selected angular units.
Units are those specified by the INPUT_DATA_UNITS assignment. When the
longitude coverage of the segment is 360 degrees, MAXIMUM_LONGITUDE
should be set to a value equivalent to 360 degrees greater than the
value assigned to MINIMUM_LONGITUDE. For example, if the angular units
are degrees, the longitude bounds could be set to -180.0 and 180.0
respectively, or if the angular units are radians, the bounds could be
set to the numeric values of -pi and pi, respectively. This assignment
is required when the coordinate system is LATITUDINAL or PLANETODETIC.<BR>
</DL>
<DL><DT>
<B>
 MAXIMUM_X
</B><BR><BR>
<DD>
 Applies only to height grid inputs for data type 2 segments, when the
coordinate system is 'RECTANGULAR'. This is the maximum value of the
X-coordinates of the vertices. Units are given by the INPUT_DATA_UNITS
assignment.<BR>
</DL>
<DL><DT>
<B>
 MAXIMUM_Y
</B><BR><BR>
<DD>
 Applies only to height grid inputs for data type 2 segments, when the
coordinate system is 'RECTANGULAR'. This is the maximum value of the
Y-coordinates of the vertices. Units are given by the INPUT_DATA_UNITS
assignment.<BR>
</DL>
<DL><DT>
<B>
 MINIMUM_LATITUDE
</B><BR><BR>
<DD>
 Lower latitude bound of spatial coverage in selected angular units.
Units are those specified by the INPUT_DATA_UNITS assignment. This
assignment is required when the coordinate system is LATITUDINAL or
PLANETODETIC.<BR>
</DL>
<DL><DT>
<B>
 MINIMUM_LONGITUDE
</B><BR><BR>
<DD>
 Lower longitude bound of spatial coverage in selected angular units.
Units are those specified by the INPUT_DATA_UNITS assignment. This
assignment is required when the coordinate system is LATITUDINAL or
PLANETODETIC.<BR>
</DL>
<DL><DT>
<B>
 MINIMUM_X
</B><BR><BR>
<DD>
 Applies only to height grid inputs for data type 2 segments, when the
coordinate system is 'RECTANGULAR'. This is the minimum value of the
X-coordinates of the vertices. Units are given by the INPUT_DATA_UNITS
assignment.<BR>
</DL>
<DL><DT>
<B>
 MINIMUM_Y
</B><BR><BR>
<DD>
 Applies only to height grid inputs for data type 2 segments, when the
coordinate system is 'RECTANGULAR'. This is the minimum value of the
Y-coordinates of the vertices. Units are given by the INPUT_DATA_UNITS
assignment.<BR>
</DL>
<DL><DT>
<B>
 NUMBER_OF_COLUMNS
</B><BR><BR>
<DD>
 Applies only to height grid inputs for data type 2 segments. This is
the number of columns of vertices in the grid.<BR>
</DL>
<DL><DT>
<B>
 NUMBER_OF_ROWS
</B><BR><BR>
<DD>
 Applies only to height grid inputs for data type 2 segments. This is
the number of rows of vertices in the grid.<BR>
</DL>
<DL><DT>
<B>
 OUTPUT_DSK_FILE
</B><BR><BR>
<DD>
 Name of output DSK file. This keyword must be used if the output data
file name is not provided on the command line; if the output data file
name is supplied on the command line, this assignment is ignored.
Include full or relative path specification. The file must not exist
when MKDSK is run.<BR>
</DL>
<DL><DT>
<B>
 PLATE_TYPE
</B><BR><BR>
<DD>
 Code indicating the format of the input data file. This code is
applicable only when the data type is 2; in this case, this assignment
is required. Supported values are: 1 for plate-vertex table; 2 for
Gaskell shape model; 3 for vertex-facet table; 4 for Rosetta/OSIRIS
``ver'' table; 5 for an ASCII height grid. See the chapter below titled
``Input Data File'' for details.<BR>
</DL>
<DL><DT>
<B>
 POLAR_RADIUS
</B><BR><BR>
<DD>
 Applies only to 'PLANETODETIC' coordinates. This is the polar radius of
the reference ellipsoid. Units are always km.<BR>
</DL>
<DL><DT>
<B>
 REF_FRAME_NAME
</B><BR><BR>
<DD>
 Name of the body-fixed reference frame relative to which the surface
data are expressed. This frame need not be centered on the body
specified by the keyword CENTER_NAME, but this frame must be fixed to
that body. The center of this frame is the origin of the coordinate
system in which the shape data are expressed. For example, for a DSK
type 2 segment for Mars that uses the reference frame IAU_MARS, the
vertices of the segment are assumed to emanate from the center of mass
of Mars. This assignment is required.<BR>
</DL>
<DL><DT>
<B>
 ROW_STEP_SIZE
</B><BR><BR>
<DD>
 Applies only to height grid inputs for data type 2 segments. This is
the grid's step size for latitude or for Y, depending on the specified
coordinate system. Units are given by the INPUT_DATA_UNITS assignment.<BR>
</DL>
<DL><DT>
<B>
 ROW_VALUE_ORDER_LEFT_RIGHT
</B><BR><BR>
<DD>
 Applies only to height grid inputs for data type 2 segments. Indicates
that rows of the vertex grid are filled in in left-to-right order as
data are read from the input file. (This does not imply that adjacent
elements of a row in the vertex grid are filled in consecutively: see
the description of INPUT_GRID_ORDER_ROW_MAJOR.) Values are 'YES' or
'NO'.<BR>
</DL>
<DL><DT>
<B>
 START_TIME
</B><BR><BR>
<DD>
 Start time of coverage interval during which this surface
representation is applicable. The value is a quoted string; any string
acceptable to the SPICE routine STR2ET is allowed. This assignment is
required.<BR>
</DL>
<DL><DT>
<B>
 STOP_TIME
</B><BR><BR>
<DD>
 Stop time of coverage interval during which this surface representation
is applicable. The value is a quoted string; any string acceptable to
the SPICE routine STR2ET is allowed. This assignment is required.<BR>
</DL>
<DL><DT>
<B>
 SURFACE_NAME
</B><BR><BR>
<DD>
 Name of the surface represented by the DSK, for example 'MGS MOLA MEGDR
128 PIXELS/DEG'. An integer ID code enclosed in single quotes may be
provided instead of a name, e. g. '1' instead of 'MGS MOLA MEGDR 128
PIXELS/DEG'. Surface name-ID associations must be defined in a text
kernel or in the MKDSK setup file. Multiple surfaces can be associated
with a given central body and used together during a single application
program run. For example, versions of surfaces having different
resolutions could be associated with a given central body. This
assignment is required.<BR>
</DL>
<DL><DT>
<B>
 TOP_ROW_LATITUDE
</B><BR><BR>
<DD>
 Applies only to height grid inputs for data type 2 segments, when the
coordinate system is 'LATITUDINAL' or 'PLANETODETIC'. This is the
latitude of the grid's top row. Units are given by the INPUT_DATA_UNITS
assignment.<BR>
</DL>
<DL><DT>
<B>
 TOP_ROW_Y_COORDINATE
</B><BR><BR>
<DD>
 Applies only to height grid inputs for data type 2 segments, when the
coordinate system is 'RECTANGULAR'. This is the Y value of the grid's
top row. Units are given by the INPUT_DATA_UNITS assignment.<BR>
</DL>
<DL><DT>
<B>
 WRAP_LONGITUDE
</B><BR><BR>
<DD>
 Applies only to height grid inputs for data type 2 segments, when the
coordinate system is 'LATITUDINAL' or 'PLANETODETIC'. Indicates that
plates are to be formed connecting vertices in the rightmost column to
those in the leftmost column. Values are 'YES' or 'NO'.<BR>
</DL>
<BR><BR>
<A NAME="Setup File Examples"></A>
<p align="right"><a href="#top"><small>Top</small></a></p>
<H1> Setup File Examples
</H1><HR SIZE=3 NOSHADE><P><BR><BR><BR>
<BR><BR>
<A NAME="Input Using Latitudinal Coordinates and Plate Type 2"></A>
<p align="right"><a href="#top"><small>Top</small></a></p>
<H3> Input Using Latitudinal Coordinates and Plate Type 2
</H3><P><BR><BR>
   An example command file for a Phobos DSK:
<P>
 
<PRE>
   \begindata
 
   INPUT_SHAPE_FILE    = 'phobos_q512.txt'
   OUTPUT_DSK_FILE     = 'phobos512.bds'
   COMMENT_FILE        = ' '
   KERNELS_TO_LOAD     = ( 'naif0012.tls' )
   SURFACE_NAME        = 'Gaskell Phobos Q=512'
   CENTER_NAME         = 'PHOBOS'
   REF_FRAME_NAME      = 'IAU_PHOBOS'
   START_TIME          = '1950-JAN-1/00:00:00'
   STOP_TIME           = '2050-JAN-1/00:00:00'
   DATA_CLASS          = 1
   INPUT_DATA_UNITS    = ( 'ANGLES    = DEGREES'
                           'DISTANCES = KILOMETERS' )
   COORDINATE_SYSTEM   = 'LATITUDINAL'
   MINIMUM_LATITUDE    =  -90.0
   MAXIMUM_LATITUDE    =   90.0
   MINIMUM_LONGITUDE   = -180.0
   MAXIMUM_LONGITUDE   =  180.0
   DATA_TYPE           = 2
   PLATE_TYPE          = 2
 
   NAIF_SURFACE_NAME   += 'Gaskell Phobos Q=512'
   NAIF_SURFACE_CODE   += 1
   NAIF_SURFACE_BODY   += 401
 
   \begintext
</PRE>
<BR><BR>
<A NAME="Input Using Planetodetic Coordinates and Plate Type 1"></A>
<p align="right"><a href="#top"><small>Top</small></a></p>
<H3> Input Using Planetodetic Coordinates and Plate Type 1
</H3><P><BR><BR>
   This is an example command file for a Mars DSK. The input plate data
   were derived from the MGS MOLA data set named
<P>
 
<PRE>
   megr90n000cb
</PRE>
   This data set has a resolution of 4 pixels/degree. The surface coverage
   is global.
<P>
 
   This example presumes that vertices and plates have already been derived
   from original input data, which constitute a digital elevation model
   (DEM).
<P>
 
<PRE>
   \begindata
 
   INPUT_SHAPE_FILE    = 'megr90n000cb.inp'
   OUTPUT_DSK_FILE     = 'megr90n000cb_1.bds'
   COMMENT_FILE        = ' '
   KERNELS_TO_LOAD     = ( 'naif0012.tls' )
   SURFACE_NAME        = 'megr90n000cb --- plates'
   CENTER_NAME         = 'MARS'
   REF_FRAME_NAME      = 'IAU_MARS'
   START_TIME          = '1950-JAN-1/00:00:00'
   STOP_TIME           = '2050-JAN-1/00:00:00'
   DATA_CLASS          = 1
   INPUT_DATA_UNITS    = ( 'ANGLES    = DEGREES'
                           'DISTANCES = KILOMETERS' )
 
   COORDINATE_SYSTEM   = 'PLANETODETIC'
   EQUATORIAL_RADIUS   = 3396.19
   POLAR_RADIUS        = 3376.20
 
   MINIMUM_LATITUDE    =  -90.0
   MAXIMUM_LATITUDE    =   90.0
   MINIMUM_LONGITUDE   = -180.0
   MAXIMUM_LONGITUDE   =  180.0
   DATA_TYPE           = 2
   PLATE_TYPE          = 1
 
   NAIF_SURFACE_NAME   += 'megr90n000cb --- plates'
   NAIF_SURFACE_CODE   += 1
   NAIF_SURFACE_BODY   += 499
 
   \begintext
</PRE>
<BR><BR>
<A NAME="Input Using Planetocentric Coordinates and Plate Type 5"></A>
<p align="right"><a href="#top"><small>Top</small></a></p>
<H3> Input Using Planetocentric Coordinates and Plate Type 5
</H3><P><BR><BR>
   This example uses the same data as the previous one, but in this case,
   the height values have been transferred to an ASCII file, which serves
   as the input data file.
<P>
 
   We give this surface a distinct name from that of the previous example,
   since the plate set created from the input data will differ.
<P>
 
   The input data file is organized in row-major, top-down, left-to-right
   order.
<P>
 
   The top and bottom input pixel centers are 1/2 pixel away from the
   poles, so we add polar caps. Similarly, the pixel centers of leftmost
   and rightmost columns are one pixel apart, so we invoke longitude
   wrapping. These choices create a plate set with complete coverage.
<P>
 
   The distance units are meters.
<P>
 
<PRE>
   \begindata
 
   INPUT_SHAPE_FILE            = 'megr90n000cb.inp'
   OUTPUT_DSK_FILE             = 'megr90n000cb_2.bds'
   COMMENT_FILE                = ' '
   KERNELS_TO_LOAD             = ( 'naif0012.tls' )
   SURFACE_NAME                = 'megr90n000cb --- grid'
   CENTER_NAME                 = 'MARS'
   REF_FRAME_NAME              = 'IAU_MARS'
   START_TIME                  = '1950-JAN-1/00:00:00'
   STOP_TIME                   = '2050-JAN-1/00:00:00'
   DATA_CLASS                  = 1
   INPUT_DATA_UNITS            = ( 'ANGLES    = DEGREES'
                                   'DISTANCES = METERS' )
 
   COORDINATE_SYSTEM           = 'LATITUDINAL'
 
   NUMBER_OF_ROWS              = 720
   NUMBER_OF_COLUMNS           = 1440
 
   ROW_STEP_SIZE               = 0.25
   COLUMN_STEP_SIZE            = 0.25
 
   LEFT_COLUMN_LONGITUDE       = -180.0
   TOP_ROW_LATITUDE            =   89.875
 
   INPUT_GRID_ORDER_ROW_MAJOR  = 'YES'
   COLUMN_VALUE_ORDER_TOP_DOWN = 'YES'
   ROW_VALUE_ORDER_LEFT_RIGHT  = 'YES'
 
   WRAP_LONGITUDE              = 'YES'
   MAKE_NORTH_POLAR_CAP        = 'YES'
   MAKE_SOUTH_POLAR_CAP        = 'YES'
 
   HEIGHT_SCALE                = 1.D-3
   HEIGHT_REFERENCE            = 3396000
 
   MINIMUM_LATITUDE            =  -90.0
   MAXIMUM_LATITUDE            =   90.0
   MINIMUM_LONGITUDE           = -180.0
   MAXIMUM_LONGITUDE           =  180.0
 
   DATA_TYPE                   = 2
   PLATE_TYPE                  = 5
 
   NAIF_SURFACE_NAME           += 'megr90n000cb --- grid'
   NAIF_SURFACE_CODE           += 2
   NAIF_SURFACE_BODY           += 499
 
   \begintext
</PRE>
<BR><BR>
<A NAME="Input Data File"></A>
<p align="right"><a href="#top"><small>Top</small></a></p>
<H1> Input Data File
</H1><HR SIZE=3 NOSHADE><P><BR><BR><BR>
   All of the input files discussed below are particular to type 2
   (triangular plate model) DSK segments.
<P>
 
   The type 2 segment design has no restrictions on sizes or configuration
   of the triangular plates defined by the vertices, even within a single
   plate model file. Indeed it is quite normal that the plate sizes and
   local plate density vary across the model in order to achieve desired
   shape fidelity without using an excessive number of plates.
<P>
 
   It is recommended that the input data not define any degenerate plates
   (plates having zero-length edges). Such plates may cause run-time
   failures of computations that require each plate to have a computable
   outward normal vector.
<P>
 
   MKDSK reads an ASCII text file containing body shape data. This text
   file must conform to one of the following formats:
<P>
 
<DL><DT>
<B>
 Plate-vertex table
</B><BR><BR>
<DD>
 Contains the body-fixed coordinates of each vertex in a plate model
followed by a list that associates particular vertices with each plate.
This file explicitly assigns integer IDs to the plates and vertices.<BR>
</DL>
<DL><DT>
<B>
 Gaskell shape model
</B><BR><BR>
<DD>
 Contains the body-fixed coordinates of each vertex in a plate model.
The order of the vertex data implicitly defines the plate-vertex
mapping.<BR>
</DL>
<DL><DT>
<B>
 Vertex-facet table
</B><BR><BR>
<DD>
 Is similar to the plate-vertex table, but without the plate and vertex
ID assignment. A data line has the prefix 'v' for vertex data and 'f'
for the plate-vertex mapping (the facet map).<BR>
</DL>
<DL><DT>
<B>
 Rosetta/OSIRIS ``ver'' table
</B><BR><BR>
<DD>
 (The format of M. Kasalaainen.) Contains the body-fixed coordinates of
each vertex in a plate model followed by a list that associates
particular vertices with each plate. Each line of plate vertex indices
is preceded by a line containing a vertex count. Only triangular plates
are supported by this program.<BR>
</DL>
<DL><DT>
<B>
 ASCII height grid
</B><BR><BR>
<DD>
 Contains height values of a regular grid of vertices. For segments
using the planetocentric latitudinal or planetodetic coordinate
systems, the vertices are separated by equal longitude increments and
by equal latitude increments. In the rectangular system, the vertices
are separated by equal X increments and equal Y increments.<BR>
</DL>
<BR><BR>
<A NAME="Units"></A>
<p align="right"><a href="#top"><small>Top</small></a></p>
<H2> Units
</H2><HR ALIGN="LEFT" WIDTH=50% ><P><BR><BR>
   The distance units of plate model vertex data may be any supported by
   the CSPICE unit conversion routine <a href="../cspice/convrt_c.html">convrt_c</a>. Distance units must be
   specified in the MKDSK setup file.
<P>
 
<BR><BR>
<A NAME="Reference Frame"></A>
<p align="right"><a href="#top"><small>Top</small></a></p>
<H2> Reference Frame
</H2><HR ALIGN="LEFT" WIDTH=50% ><P><BR><BR>
   The reference frame of all plate model vertex data must be specified in
   the MKDSK setup file. The frame must be body-fixed with respect to the
   body identified in the setup file as the ``center'' associated with the
   surface. However, the frame need not have that body as its own center.
<P>
 
<BR><BR>
<A NAME="Vertex order"></A>
<p align="right"><a href="#top"><small>Top</small></a></p>
<H2> Vertex order
</H2><HR ALIGN="LEFT" WIDTH=50% ><P><BR><BR>
   The ordering of the plate vertices is expected to follow a
   "right-handed" convention where the order of vertices implicitly defines
   the orientation of the outward normal, i.e. given the assignment
<P>
 
<PRE>
      plate =  vertex_1, vertex_2, vertex_3
</PRE>
   derive the outward normal as:
<P>
 
<PRE>
      -      --------   --------     --------   --------
      n  = ( vertex_2 - vertex_1) X (vertex_3 - vertex_2)
</PRE>
<BR><BR>
<A NAME="Vertex IDs"></A>
<p align="right"><a href="#top"><small>Top</small></a></p>
<H3> Vertex IDs
</H3><P><BR><BR>
   Vertex IDs always start at 1. Their upper bound is NV, the number of
   vertices. Input data files that use plates must conform to this
   convention.
<P>
 
<BR><BR>
<A NAME="Plate Data File Type 1 Plate-Vertex Table"></A>
<p align="right"><a href="#top"><small>Top</small></a></p>
<H2> Plate Data File Type 1 (Plate-Vertex Table)
</H2><HR ALIGN="LEFT" WIDTH=50% ><P><BR><BR>
   The data input file consists of two sections, the first for vertex data,
   the second describing the plate-vertex mapping.
<P>
 
<PRE>
 
   N
   1 X(1) Y(1) Z(1)
   2 X(2) Y(2) Z(2)
 
         ...
 
   N X(N) Y(N) Z(N)
   M
   1 V1(1) V2(1) V3(1)
   2 V1(2) V2(2) V3(2)
 
         ...
 
   M V1(M) V2(M) V3(M)
</PRE>
   where
<P>
 
<DL><DT>
<B>
 N
</B><BR><BR>
<DD>
 is the number of vertices listed in the file.<BR>
</DL>
<DL><DT>
<B>
 1 through N
</B><BR><BR>
<DD>
 are the indices of the plate model vertices, provided as the first
space-separated item on the file lines 2 through (N+1).<BR>
</DL>
<DL><DT>
<B>
 X(i) Y(i) Z(i)
</B><BR><BR>
<DD>
 are the body-fixed Cartesian coordinates of the plate model vertices,
provided for each vertex as the 2nd, 3rd, and 4th space-separated items
on lines 2 through (N+1).<BR>
</DL>
<DL><DT>
<B>
 M
</B><BR><BR>
<DD>
 is the number of plate-vertex mappings in the file.<BR>
</DL>
<DL><DT>
<B>
 1 through M
</B><BR><BR>
<DD>
 are the indices of the plate model plates, provided as the first
space-separated item on the file lines (N+3) through (N+M+2).<BR>
</DL>
<DL><DT>
<B>
 V1(i) V2(i) V3(i)
</B><BR><BR>
<DD>
 are the indices of the plate model vertices for the corners of a given
plate, provided for each plate as the 2nd, 3rd, and 4th space-separated
items on lines (N+3) through (N+M+2).<BR>
</DL>
<BR><BR>
<A NAME="Sample Plate-Vertex Table Input File"></A>
<p align="right"><a href="#top"><small>Top</small></a></p>
<H3> Sample Plate-Vertex Table Input File
</H3><P><BR><BR>
<PRE>
 
      12
      1 0. 0. 1.17557
      2 0.32492 1. 0.525731
      3 1.05146 0. 0.525731
      4 -0.850651 0.618034 0.525731
      5 -0.850651 -0.618034 0.525731
      6 0.32492 -1. 0.525731
      7 0.850651 0.618034 -0.525731
      8 -0.32492 1. -0.525731
      9 -1.05146 0. -0.525731
      10 -0.32492 -1. -0.525731
      11 0.850651 -0.618034 -0.525731
      12 0. 0. -1.17557
      20
      1 1 3 2
      2 1 2 4
      3 1 4 5
      4 1 5 6
      5 1 6 3
      6 3 7 2
      7 2 8 4
      8 4 9 5
      9 5 10 6
      10 6 11 3
      11 7 8 2
      12 8 9 4
      13 9 10 5
      14 10 11 6
      15 11 7 3
      16 7 12 8
      17 8 12 9
      18 9 12 10
      19 10 12 11
      20 11 12 7
</PRE>
<BR><BR>
<A NAME="Plate Data File Type 2 Gaskell Shape Model"></A>
<p align="right"><a href="#top"><small>Top</small></a></p>
<H2> Plate Data File Type 2 (Gaskell Shape Model)
</H2><HR ALIGN="LEFT" WIDTH=50% ><P><BR><BR>
   A Gaskell shape model data file has no explicit plate-vertex mapping
   data as that information is implicit in the ordering of the vertex data.
<P>
 
   The data file has the form:
<P>
 
<PRE>
 
      Q
      X(1)          Y(1)          Z(1)
      X(2)          Y(2)          Z(2)
 
       ...          ...           ...
      X(6*(Q+1)^2)  Y(6*(Q+1)^2)  Z(6*(Q+1)^2)
</PRE>
   where
<P>
 
<DL><DT>
<B>
 Q
</B><BR><BR>
<DD>
 is the number of divisions per side on a cube face. The number of
vertices in the file is<BR>
</DL>
<PRE>
                                        6 * (Q+1)^2
</PRE>
<DL><DT>
<B>
 X(i) Y(i) Z(i)
</B><BR><BR>
<DD>
 are the body-fixed Cartesian coordinates of the plate model vertices,
provided for each vertex as the 1st, 2nd, and 3rd space-separated items
on lines 2 through Nvert+1.<BR>
</DL>
<BR><BR>
<A NAME="Sample Gaskell Shape Model Input File"></A>
<p align="right"><a href="#top"><small>Top</small></a></p>
<H3> Sample Gaskell Shape Model Input File
</H3><P><BR><BR>
<PRE>
 
       64
       -9.36329     3.76796     3.80970
       -9.12138     3.82357     3.86143
       -8.87987     3.88047     3.91416
       -8.63347     3.92422     3.95698
       -8.39016     3.97415     4.00291
       -8.14081     4.03950     4.05743
       -7.88861     4.08816     4.09352
       -7.63058     4.07331     4.08113
       -7.37114     4.03909     4.05807
       -7.11810     4.05018     4.08515
       -6.89451     4.12730     4.15128
       -6.69135     4.24326     4.25130
       -6.46167     4.30681     4.31349
 
         ...         ...         ...
</PRE>
<BR><BR>
<A NAME="Plate Data File Type 3 Vertex-Facet Table"></A>
<p align="right"><a href="#top"><small>Top</small></a></p>
<H2> Plate Data File Type 3 (Vertex-Facet Table)
</H2><HR ALIGN="LEFT" WIDTH=50% ><P><BR><BR>
   The data input file consists of two sections, the first for vertex data,
   the second describing the plate-vertex mapping.
<P>
 
<PRE>
 
   v X(1)  Y(1)  Z(1)
   v X(2)  Y(2)  Z(2)
 
          ...
 
   v X(N)  Y(N)  Z(N)
   f V1(1) V2(1) V3(1)
   f V1(2) V2(2) V3(2)
 
          ...
 
   f V1(M) V2(M) V3(M)
</PRE>
   where
<P>
 
<DL><DT>
<B>
 X(i) Y(i) Z(i)
</B><BR><BR>
<DD>
 are the body-fixed Cartesian coordinates of the plate model vertices,
provided for each vertex as the 2nd, 3rd, and 4th space-separated items
on the data lines. Each vertex line has the prefix character 'v'.<BR>
</DL>
<DL><DT>
<B>
 V1(i) V2(i) V3(i)
</B><BR><BR>
<DD>
 are the indices of the plate model vertices for the corners of a given
plate, provided for each plate as the 2nd, 3rd, and 4th space-separated
items on the data lines. Each vertex line has the prefix character 'f'.<BR>
</DL>
<BR><BR>
<A NAME="Sample Vertex-Facet Input File"></A>
<p align="right"><a href="#top"><small>Top</small></a></p>
<H3> Sample Vertex-Facet Input File
</H3><P><BR><BR>
<PRE>
 
   v 0. 0. 1.17557
   v 0.32492 1. 0.525731
   v 1.05146 0. 0.525731
   v -0.850651 0.618034 0.525731
   v -0.850651 -0.618034 0.525731
   v 0.32492 -1. 0.525731
   v 0.850651 0.618034 -0.525731
   v -0.32492 1. -0.525731
   v -1.05146 0. -0.525731
   v -0.32492 -1. -0.525731
   v 0.850651 -0.618034 -0.525731
   v 0. 0. -1.17557
   f 1 3 2
   f 1 2 4
   f 1 4 5
   f 1 5 6
   f 1 6 3
   f 3 7 2
   f 2 8 4
   f 4 9 5
   f 5 10 6
   f 6 11 3
   f 7 8 2
   f 8 9 4
   f 9 10 5
   f 10 11 6
   f 11 7 3
   f 7 12 8
   f 8 12 9
   f 9 12 10
   f 10 12 11
   f 11 12 7
</PRE>
<BR><BR>
<A NAME="Rosetta/OSIRIS ``ver'' File"></A>
<p align="right"><a href="#top"><small>Top</small></a></p>
<H2> Rosetta/OSIRIS ``ver'' File
</H2><HR ALIGN="LEFT" WIDTH=50% ><P><BR><BR>
   The file starts with a line containing vertex and plate counts. Vertex
   data follow; the coordinates of each vertex are placed on a line. The
   vertex indices are implied by the order of the vertex data lines. A
   section of plate data follows the section of vertex data. Each line of
   plate data is preceded by a line containing that plate's vertex count.
   Each plate must be triangular in order to be processed by this program.
<P>
 
<BR><BR>
<A NAME="Sample Rosetta/OSIRIS ``ver'' File"></A>
<p align="right"><a href="#top"><small>Top</small></a></p>
<H3> Sample Rosetta/OSIRIS ``ver'' File
</H3><P><BR><BR>
<PRE>
   12  20
    0. 0. 1.17557
    0.32492 1. 0.525731
    1.05146 0. 0.525731
    -0.850651 0.618034 0.525731
    -0.850651 -0.618034 0.525731
    0.32492 -1. 0.525731
    0.850651 0.618034 -0.525731
    -0.32492 1. -0.525731
    -1.05146 0. -0.525731
    -0.32492 -1. -0.525731
    0.850651 -0.618034 -0.525731
    0. 0. -1.17557
   3
     1 3 2
   3
     1 2 4
   3
     1 4 5
   3
     1 5 6
   3
     1 6 3
   3
     3 7 2
   3
     2 8 4
   3
     4 9 5
   3
     5 10 6
   3
    6 11 3
   3
    7 8 2
   3
    8 9 4
   3
    9 10 5
   3
    10 11 6
   3
    11 7 3
   3
    7 12 8
   3
    8 12 9
   3
    9 12 10
   3
    10 12 11
   3
    11 12 7
</PRE>
<BR><BR>
<A NAME="ASCII Height Grid File"></A>
<p align="right"><a href="#top"><small>Top</small></a></p>
<H2> ASCII Height Grid File
</H2><HR ALIGN="LEFT" WIDTH=50% ><P><BR><BR>
   An ASCII height grid file defines a surface by means of a set of height
   values associated with a regular grid of coordinate pairs, which may be
   any of
<P>
 
<UL>
<TT>--</TT> Planetocentric longitude and latitude
<BR><BR></UL>
<UL>
<TT>--</TT> Planetodetic longitude and latitude
<BR><BR></UL>
<UL>
<TT>--</TT> Rectangular X and Y
<BR><BR></UL>
   The coordinate pairs and heights define a vertex grid in 3-dimensional
   space. The vertex grid has a rectangular shape in either longitude and
   latitude or X and Y, depending on the specified coordinate system. It
   has row and column counts specified by the setup file.
<P>
 
   Each group of four adjacent vertices in the grid defines a pair of
   plates as shown below:
<P>
 
<PRE>
 
 
            vertex(I,J)      vertex(I,J+1)
                +----------------+
                |\               |
                | \              |
                |  \             |
                |   \            |
                |    \           |
                |     \          |
                |      \         |
                |       \        |
                |        \       |
                |         \      |
                |          \     |
                |           \    |
                |            \   |
                |             \  |
                |              \ |
                |               \|
                +----------------+
            vertex(I+1,J)      vertex(I+1,J+1)
 
</PRE>
<BR><BR>
<A NAME="Domain Coordinates"></A>
<p align="right"><a href="#top"><small>Top</small></a></p>
<H3> Domain Coordinates
</H3><P><BR><BR>
   The pairs of coordinates (longitude, latitude) or (X, Y) are called
   ``domain coordinates,'' since they constitute the domain of a function
   whose range is the set of input height values.
<P>
 
   The size of the grid is given by a row count NROWS and a column count
   NCOLS; these are the values assigned by the setup file to the keywords
   NUMBER_OF_ROWS and NUMBER_OF_COLUMNS.
<P>
 
   The domain coordinates of the grid are defined by starting values and
   constant step values. For planetocentric latitudinal and planetodetic
   coordinates, longitudes are defined by a ``leftmost'' (minimum)
   longitude LFTLON and a longitude step size LONSTP. These are the values
   assigned to the keywords LEFT_COLUMN_LONGITUDE and COLUMN_STEP_SIZE. The
   longitudes of the grid points increase from
<P>
 
<PRE>
   LFTLON to LFTLON + ((NCOLS-1) * LONSTP)
</PRE>
   Latitudes are defined by a top (maximum) latitude TOPLAT and a latitude
   step size LATSTP. These are the values assigned to the keywords
   TOP_ROW_LATITUDE and ROW_STEP_SIZE. The latitudes of the grid points
   decrease from
<P>
 
<PRE>
   TOPLAT to TOPLAT - ((NROWS-1) * LATSTP)
</PRE>
   For rectangular coordinates, X values are defined by a ``leftmost''
   (minimum) X value LEFTX and an X step size XSTEP. These are the values
   assigned to the keywords LEFT_COLUMN_X and COLUMN_STEP_SIZE. The X
   values of the grid points increase from
<P>
 
<PRE>
   LEFTX to LEFTX + ((NCOLS-1) * XSTEP)
</PRE>
   Y values are defined by a top (maximum) Y value TOPY and a Y step size
   YSTEP. These are the values assigned to the keywords TOP_ROW_Y and
   ROW_STEP_SIZE. The Y values of the grid points decrease from
<P>
 
<PRE>
   TOPY to TOPY - ((NROWS-1) * YSTEP)
</PRE>
<BR><BR>
<A NAME="Heights"></A>
<p align="right"><a href="#top"><small>Top</small></a></p>
<H3> Heights
</H3><P><BR><BR>
   Height values need not be given in standard units; rather, an input
   parameter called the ``height scale'' must be present in the setup file.
   The keyword for the height scale is
<P>
 
<PRE>
   HEIGHT_SCALE
</PRE>
   This scale is a factor by which the input heights are to be multiplied
   to convert them to km.
<P>
 
   For planetodetic coordinates, heights are expressed relative to the
   reference spheroid of the coordinate system. The equatorial and polar
   radii of this spheroid are provided as setup file inputs.
<P>
 
   For planetocentric latitudinal and rectangular coordinates, input
   heights are expressed relative to a reference height value which is
   supplied in the setup file; the keyword for this value is
   HEIGHT_REFERENCE. Units of the reference height are always km.
<P>
 
<BR><BR>
<A NAME="Height Grid File Format"></A>
<p align="right"><a href="#top"><small>Top</small></a></p>
<H3> Height Grid File Format
</H3><P><BR><BR>
   The input height grid file should contain only printable ASCII
   characters. It should not contain tab characters. The line length should
   not exceed 255 characters. Each data value must be parseable as a double
   precision number. Data values cannot have embedded blanks. Values must
   not be split across lines.
<P>
 
   The data values must be separated by blanks or commas.
<P>
 
   There are no restrictions on the precision of the data values.
<P>
 
   The count of data values per line need not be constant. However, the
   file may be easier to human readers to scan if data values are placed in
   fixed-width columns.
<P>
 
   MKDSK reads the input height data file sequentially: it views the values
   in a height grid file as a 1-dimensional stream of data. Values in lines
   are read from the file from left to right; lines are read from the start
   of the file to the end.
<P>
 
<BR><BR>
<A NAME="Height Grid Data Mapping"></A>
<p align="right"><a href="#top"><small>Top</small></a></p>
<H3> Height Grid Data Mapping
</H3><P><BR><BR>
   Although the input file need not have its data arranged in a grid, the
   data may be treated as though they do form a grid, since the numbers of
   rows and columns, along with the row-major or column-major attribute
   described below, imply a shape and size of a rectangular input grid.
   Below, we depict the input data as already arranged in a grid.
<P>
 
   The input data can be arranged in either row-major or column-major
   order.
<P>
 
   Row-major order means that data for rows in the vertex grid are adjacent
   in the input file: the first NCOLS elements of the file belong to a row,
   the next NCOLS elements belong to a row, and so on.
<P>
 
   Column-major order means that data for columns in the vertex grid are
   adjacent in the input file: the first NROWS elements of the file belong
   to a column, the next NROWS elements belong to a column, and so on.
<P>
 
   Input data can be mapped to the vertex grid in top-down or bottom-up
   order, and in left-to-right or right-to-left order. The possible
   mappings are illustrated below. Setup file keywords controlling the
   mapping are discussed following these diagrams.
<P>
 
   When the input data are arranged in row-major order, rows of height data
   in the input file map to rows in the segment's vertex grid as shown
   below. Entries of the form h_ij represent height values in the ith row
   and jth column of the input file. Horizontal and vertical lines denote
   additional rows and columns of data.
<P>
 
   If the input data organization is row-major, top-down and left-right,
   the mapping is:
<P>
 
<PRE>
   h_11  h_12  ...  h_1n             h_11  h_12  ...  h_1n
   h_21  h_22  ...  h_2n             h_21  h_22  ...  h_2n
   ---------------------             ---------------------
            ...              -&gt;               ...
   ---------------------             ---------------------
   ---------------------             ---------------------
 
       Input file                    Segment's vertex grid
</PRE>
   If the input data organization is row-major, top-down and right-left,
   the mapping is:
<P>
 
<PRE>
   h_11  h_12  ...  h_1n             h_1n  ...  h_12  h_11
   h_21  h_22  ...  h_2n             h_2n  ...  h_22  h_21
   ---------------------             ---------------------
            ...              -&gt;               ...
   ---------------------             ---------------------
   ---------------------             ---------------------
 
       Input file                    Segment's vertex grid
</PRE>
   If the input data organization is row-major, bottom-up and left-right,
   the mapping is:
<P>
 
<PRE>
   h_11  h_12  ...  h_1n             ---------------------
   h_21  h_22  ...  h_2n             ---------------------
   ---------------------                      ...
            ...              -&gt;      ---------------------
   ---------------------             h_21  h_22  ...  h_2n
   ---------------------             h_11  h_12  ...  h_1n
 
       Input file                    Segment's vertex grid
</PRE>
   If the input data organization is row-major, bottom-up and right-left,
   the mapping is:
<P>
 
<PRE>
   h_11  h_12  ...  h_1n             ---------------------
   h_21  h_22  ...  h_2n             ---------------------
   ---------------------                      ...
            ...              -&gt;      ---------------------
   ---------------------             h_2n  ...  h_22  h_21
   ---------------------             h_1n  ...  h_12  h_11
 
       Input file                    Segment's vertex grid
</PRE>
   When the input data are arranged in column-major order, rows of height
   data in the input file map to columns in the segment's vertex grid as
   shown below. If the input data organization is column-major, top-down
   and left-right, the mapping is:
<P>
 
<PRE>
   h_11  h_12  ...  h_1n             h_11  h_21   |     | |
   h_21  h_22  ...  h_2n             h_12  h_22   |     | |
   ---------------------                          |     | |
            ...              -&gt;      ...   ...    | ... | |
   ---------------------                          |     | |
   ---------------------             h_1n  h_2n   |     | |
 
       Input file                    Segment's vertex grid
</PRE>
   If the input data organization is column-major, top-down and right-left,
   the mapping is:
<P>
 
<PRE>
   h_11  h_12  ...  h_1n              | |     | h_21  h_11
   h_21  h_22  ...  h_2n              | |     | h_22  h_12
   ---------------------              | |     |
            ...              -&gt;       | | ... | ...   ...
   ---------------------              | |     |
   ---------------------              | |     | h_2n  h_1n
 
       Input file                     Segment's vertex grid
</PRE>
   If the input data organization is column-major, bottom-up and
   left-right, the mapping is:
<P>
 
<PRE>
   h_11  h_12  ...  h_1n             h_1n  h_2n   |     | |
   h_21  h_22  ...  h_2n                          |     | |
   ---------------------              ...   ...   | ... | |
            ...              -&gt;                   |     | |
   ---------------------             h_12  h_22   |     | |
   ---------------------             h_11  h_21   |     | |
 
       Input file                    Segment's vertex grid
</PRE>
   If the input data organization is column-major, bottom-up and
   right-left, the mapping is:
<P>
 
<PRE>
   h_11  h_12  ...  h_1n              | |     | h_2n  h_1n
   h_21  h_22  ...  h_2n              | |     |
   ---------------------              | | ... | ...   ...
            ...              -&gt;       | |     |
   ---------------------              | |     | h_22  h_12
   ---------------------              | |     | h_21  h_11
 
       Input file                     Segment's vertex grid
</PRE>
   The assignment of the string 'YES' to the keyword
<P>
 
<PRE>
   INPUT_GRID_ORDER_ROW_MAJOR
</PRE>
   indicates that the input height data are arranged in row-major order.
   The assignment of 'NO' indicates the data are in column-major order.
<P>
 
   The assignment of the string 'YES' to the keyword
<P>
 
<PRE>
   COLUMN_VALUE_ORDER_TOP_DOWN
</PRE>
   indicates that the input height data are to be mapped to the vertex grid
   in top-down order. The assignment of 'NO' indicates the mapping is
   bottom-up.
<P>
 
   The assignment of the string 'YES' to the keyword
<P>
 
<PRE>
   ROW_VALUE_ORDER_LEFT_RIGHT
</PRE>
   indicates that the input height data are to be mapped to the vertex grid
   in left-to-right order. The assignment of 'NO' indicates the mapping is
   right-to-left.
<P>
 
<BR><BR>
<A NAME="Polar Caps"></A>
<p align="right"><a href="#top"><small>Top</small></a></p>
<H3> Polar Caps
</H3><P><BR><BR>
   If the segment's coordinate system is 'LATITUDINAL' or 'PLANETODETIC',
   then if polar latitude coverage by the plate set is desired, it may be
   necessary to fill in a gap above the northernmost or below the
   southernmost rows of the vertex grid.
<P>
 
   A polar cap is created by placing an artificial vertex on the positive
   or negative Z axis, as specified. The height of the vertex is derived by
   taking the average of the heights from the adjacent row of the vertex
   grid. Plates are formed using the polar vertex and vertices of the
   adjacent row of vertices.
<P>
 
   If longitude wrapping is enabled, a plate is created that covers the
   region between the specified pole and that filled in by longitude
   wrapping.
<P>
 
   North and south polar caps can be created independently. The assignment
   of the string 'YES' to either of the keywords
<P>
 
<PRE>
   MAKE_NORTH_POLAR_CAP
   MAKE_SOUTH_POLAR_CAP
</PRE>
   enables creation of the specified polar caps.
<P>
 
   Plates created for the north polar cap have the following form:
<P>
 
<PRE>
 
            north polar vertex
                +
                |\
                | \
                |  \
                |   \
                |    \
                |     \
                |      \
                |       \
                |        \
                |         \
                |          \
                |           \
                |            \
                |             \
                |              \
                |               \
                +----------------+
            vertex(1,J)      vertex(1,J+1)
 
</PRE>
   Plates created for the south polar cap are like the above, but include
   vertices of the southernmost row of the grid, and are inverted in the
   direction of latitude.
<P>
 
   If the input data set has a row of vertices with latitude on a pole,
   that row is converted to single vertex having height equal to the
   average height of the original vertices, and a polar cap is created
   using that vertex and the adjacent row of vertices. As a result, no
   degenerate plates are created. MKDSK takes these actions regardless of
   whether creation of polar caps is commanded.
<P>
 
<BR><BR>
<A NAME="Longitude Wrapping"></A>
<p align="right"><a href="#top"><small>Top</small></a></p>
<H3> Longitude Wrapping
</H3><P><BR><BR>
   If the segment's coordinate system is 'LATITUDINAL' or 'PLANETODETIC',
   then if 360-degree longitude coverage by the plate set is desired, it
   may be necessary to fill in a gap between the rightmost and leftmost
   vertex columns. When the ``longitude wrapping'' feature is enabled,
   plates are formed that join the vertices of these columns. The
   assignment of the string 'YES' to the keyword
<P>
 
<PRE>
   WRAP_LONGITUDE
</PRE>
   enables longitude wrapping.
<P>
 
   Plates created by longitude wrapping have the following form:
<P>
 
<PRE>
 
 
            vertex(I,NCOLS)     vertex(I,1)
                +----------------+
                |\               |
                | \              |
                |  \             |
                |   \            |
                |    \           |
                |     \          |
                |      \         |
                |       \        |
                |        \       |
                |         \      |
                |          \     |
                |           \    |
                |            \   |
                |             \  |
                |              \ |
                |               \|
                +----------------+
            vertex(I+1,NCOLS)    vertex(I+1,1)
 
</PRE>
   The plate created by longitude wrapping for the north polar cap has the
   form:
<P>
 
<PRE>
 
 
            north polar vertex
                +
                |\
                | \
                |  \
                |   \
                |    \
                |     \
                |      \
                |       \
                |        \
                |         \
                |          \
                |           \
                |            \
                |             \
                |              \
                |               \
                +----------------+
            vertex(1,NCOLS)    vertex(1,1)
 
</PRE>
   The plate created by longitude wrapping for the south polar cap is like
   the above, but includes vertices of the southernmost row of the grid,
   and is inverted in the direction of latitude.
<P>
 
   Longitude wrapping should not be used if the input data set already has
   the rightmost column overlapping the leftmost column. The new plates
   would either be degenerate or inward-facing.
<P>
 
<BR><BR>
<A NAME="Output DSK File"></A>
<p align="right"><a href="#top"><small>Top</small></a></p>
<H1> Output DSK File
</H1><HR SIZE=3 NOSHADE><P><BR><BR><BR>
   The output DSK file has a single segment, the contents of which are
   derived from the input data and from parameters specified in the setup
   file.
<P>
 
   The output file is not human-readable: it is a binary file designed to
   support rapid read access by SPICE software and SPICE-based
   applications.
<P>
 
   The contents of the output file can be summarized by running the SPICE
   utility program DSKBRIEF. It is recommended that DSK creators use
   DSKBRIEF to verify that the output file has the intended attributes.
<P>
 
   Data may be extracted from the output DSK file using the interface
   software provided in the SPICE library. Data also may be exported from
   the DSK file to a human-readable text file by means of the SPICE utility
   program DSKEXP.
<P>
 
<BR><BR>
<A NAME="Appendix A: Spatial Index and Voxels"></A>
<p align="right"><a href="#top"><small>Top</small></a></p>
<H1> Appendix A: Spatial Index and Voxels
</H1><HR SIZE=3 NOSHADE><P><BR><BR><BR>
   This discussion applies to type 2 segments.
<P>
 
   ``Voxel scales'' are attributes of a data structure in type 2 DSK
   segments called a ``spatial index.'' The spatial index enables type 2
   DSK software to rapidly locate plates in a given region of space.
<P>
 
   Starting with the release of the N0066 SPICE Toolkit, MKDSK
   automatically computes voxel scales appropriate for the input data.
<P>
 
   In some cases, speed of ray-surface intercept computations can be
   improved by manually adjusting the voxel scales.
<P>
 
   See the DSK Required Reading [1] for a detailed description of DSK type
   2 spatial indexes.
<P>
 

</TD>
</TR>
</TBODY>
</TABLE>

</BODY>

</HTML>
