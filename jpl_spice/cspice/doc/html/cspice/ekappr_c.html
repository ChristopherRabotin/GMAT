
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<HTML>

<HEAD>
   <TITLE>ekappr_c</TITLE>
</HEAD>

<BODY style="color: rgb(0, 0, 0); background-color: rgb(255, 255, 255);">
<A name="TOP"></A>

<table style="text-align: left; margin-left: auto; margin-right: auto; width: 800px;"
 border="0" cellpadding="5" cellspacing="2">
  <tbody>
    <tr><td>
<div align="center">
Index of Functions: 
<A HREF="index.html#A">A</A>&nbsp;
<A HREF="index.html#B">B</A>&nbsp;
<A HREF="index.html#C">C</A>&nbsp;
<A HREF="index.html#D">D</A>&nbsp;
<A HREF="index.html#E">E</A>&nbsp;
<A HREF="index.html#F">F</A>&nbsp;
<A HREF="index.html#G">G</A>&nbsp;
<A HREF="index.html#H">H</A>&nbsp;
<A HREF="index.html#I">I</A>&nbsp;
<A HREF="index.html#J">J</A>&nbsp;
<A HREF="index.html#K">K</A>&nbsp;
<A HREF="index.html#L">L</A>&nbsp;
<A HREF="index.html#M">M</A>&nbsp;
<A HREF="index.html#N">N</A>&nbsp;
<A HREF="index.html#O">O</A>&nbsp;
<A HREF="index.html#P">P</A>&nbsp;
<A HREF="index.html#Q">Q</A>&nbsp;
<A HREF="index.html#R">R</A>&nbsp;
<A HREF="index.html#S">S</A>&nbsp;
<A HREF="index.html#T">T</A>&nbsp;
<A HREF="index.html#U">U</A>&nbsp;
<A HREF="index.html#V">V</A>&nbsp;
<A HREF="index.html#W">W</A>&nbsp;
<A HREF="index.html#X">X</A>&nbsp;
</div>
</td></tr>

    <tr>
      <td style="background-color: rgb(153, 153, 153); vertical-align: middle; text-align: center;">
      <div align="right"> 
      <small><small><a href="index.html">Index Page</a></small></small>
      </div>
      <b>ekappr_c</b></td>
    </tr>
    

    <tr>
      <td style="vertical-align: top;">

       <br>
       <div align="left"><b>Table of contents</b></div>
       <table style="text-align: left; width: 60%; margin-left: auto; margin-right: auto;"
       border="0" cellspacing="2" cellpadding="2">
        <tbody>
          <tr>
            <td style="width: 33%; text-align: center;">
              <a href="#Procedure">Procedure<br></a>
              <a href="#Abstract">Abstract<br></a>
              <a href="#Required_Reading">Required_Reading<br></a>
              <a href="#Keywords">Keywords<br></a>
              <a href="#Brief_I/O">Brief_I/O<br></a>
              <a href="#Detailed_Input">Detailed_Input<br></a>

              </td>
              <td style="vertical-align: top; width: 33%; text-align: center;">              <a href="#Detailed_Output">Detailed_Output<br></a>
              <a href="#Parameters">Parameters<br></a>
              <a href="#Exceptions">Exceptions<br></a>
              <a href="#Files">Files<br></a>
              <a href="#Particulars">Particulars<br></a>
              <big><b><a href="#Examples">Examples<br></a></b></big>

              </td>
              <td style="vertical-align: top; width: 33%; text-align: center;">              <a href="#Restrictions">Restrictions<br></a>
              <a href="#Literature_References">Literature_References<br></a>
              <a href="#Author_and_Institution">Author_and_Institution<br></a>
              <a href="#Version">Version<br></a>
              <a href="#Index_Entries">Index_Entries<br></a>
            </td>
          </tr>
        </tbody>
</table>
<hr>

<h4><a name="Procedure">Procedure</a></h4>
<PRE>
   ekappr_c ( EK, append record onto segment ) 

   void ekappr_c ( SpiceInt     handle,
                   SpiceInt     segno,
                   SpiceInt   * recno  )

</PRE>
<h4><a name="Abstract">Abstract</a></h4>
<PRE>
   Append a new, empty record at the end of a specified E-kernel
   segment.
</PRE>
<h4><a name="Required_Reading">Required_Reading</a></h4>
<PRE>
   <a href="../req/ek.html">EK</a>
</PRE>
<h4><a name="Keywords">Keywords</a></h4>
<PRE>
   PRIVATE
   UTILITY


</PRE>
<h4><a name="Brief_I/O">Brief_I/O</a></h4>
<PRE>
   VARIABLE  I/O  DESCRIPTION
   --------  ---  --------------------------------------------------
   handle     I   File handle.
   segno      I   Segment number.
   recno      O   Number of appended record.
</PRE>
<h4><a name="Detailed_Input">Detailed_Input</a></h4>
<PRE>
   handle      is a file handle of an EK open for write access.

   segno       is the number of the segment to which the record
               is to be added. EK segment numbers range from
               zero to N-1, where N is the number of segments
               in the kernel.
</PRE>
<h4><a name="Detailed_Output">Detailed_Output</a></h4>
<PRE>
   recno       is the number of the record appended by this
               routine. recno is used to identify the record
               when writing column entries to it. EK record
               numbers range from 0 to N-1, where N is the
               number of records in the segment containing
               the record.
</PRE>
<h4><a name="Parameters">Parameters</a></h4>
<PRE>
   None.
</PRE>
<h4><a name="Exceptions">Exceptions</a></h4>
<PRE>
   1)  If `handle' is invalid, an error is signaled by a routine in the
       call tree of this routine. The file will not be modified.

   2)  If `segno' is out of range, the error SPICE(INVALIDINDEX) is
       signaled by a routine in the call tree of this routine. The
       file will not be modified.

   3)  If an I/O error occurs while reading or writing the indicated
       file, the error is signaled by a routine in the call tree of
       this routine. The file may be corrupted.
</PRE>
<h4><a name="Files">Files</a></h4>
<PRE>
   See the EK Required Reading for a discussion of the EK file
   format.
</PRE>
<h4><a name="Particulars">Particulars</a></h4>
<PRE>
   This routine operates by side effects: It appends a new, empty
   record structure to an EK segment. The ordinal position of the
   new record is one greater than the previous number of records in
   in the segment.

   After a new record has been appended to a segment by this routine,
   the record must be populated with data using the ekaceX_c
   routines.  EKs are valid only when all of their column entries
   are initialized.

   To insert a record into a segment at a specified ordinal position,
   use the routine <b>ekappr_c</b>.

   This routine cannot be used with the &quot;fast write&quot; suite of
   routines. See the EK Required Reading for a discussion of the
   fast writers.
</PRE>
<h4><a name="Examples">Examples</a></h4>
<PRE>
   The numerical results shown for this example may differ across
   platforms. The results depend on the SPICE kernels used as
   input, the compiler and supporting libraries, and the machine
   specific arithmetic implementation.

   1)  Append a record to a specified segment.

      Suppose we have an E-kernel which contains records of orders
      for data products. The E-kernel has a table called DATAORDERS
      that consists of the set of columns listed below:

         DATAORDERS

            Column Name     Data Type
            -----------     ---------
            ORDER_ID        INTEGER
            CUSTOMER_ID     INTEGER
            LAST_NAME       CHARACTER*(*)
            FIRST_NAME      CHARACTER*(*)
            ORDER_DATE      TIME
            COST            DOUBLE PRECISION

      The order database also has a table of items that have been
      ordered. The columns of this table are shown below:

         DATAITEMS

            Column Name     Data Type
            -----------     ---------
            ITEM_ID         INTEGER
            ORDER_ID        INTEGER
            ITEM_NAME       CHARACTER*(*)
            DESCRIPTION     CHARACTER*(*)
            PRICE           DOUBLE PRECISION


      We'll suppose that the EK file contains two segments, the
      first containing the DATAORDERS table and the second
      containing the DATAITEMS table.

      This examples creates such EK, with no records in either
      table, and after re-opening the file, inserts a new record
      into the DATAITEMS table.


      Example code begins here.


      /.
         Program ekappr_ex1
      ./
      #include &lt;string.h&gt;
      #include &quot;SpiceUsr.h&quot;

      int main( )
      {

         /.
         Local parameters
         ./
         #define EKNAME       &quot;ekappr_ex1.bdb&quot;
         #define DECLEN       201
         #define DESCLN       81
         #define NAMLEN       41
         #define NCOLS        6

         /.
         Local variables
         ./
         SpiceChar            cdecls [NCOLS] [DECLEN];
         SpiceChar            cnames [NCOLS] [SPICE_EK_CSTRLN];
         SpiceChar          * descrp;
         SpiceChar          * ifname;
         SpiceChar          * itemnm;

         SpiceDouble          price;

         SpiceInt             esize;
         SpiceInt             handle;
         SpiceInt             itemid;
         SpiceInt             nresvc;
         SpiceInt             ordid;
         SpiceInt             recno;
         SpiceInt             segno;

         SpiceBoolean         isnull;

         /.
         Open a new EK file.  For simplicity, we will not
         reserve any space for the comment area, so the
         number of reserved comment characters is zero.
         The variable `ifname' is the internal file name.
         ./
         nresvc  =  0;
         ifname  =  &quot;Test EK/Created 01-JUN-2019&quot;;

         <a href="ekopn_c.html">ekopn_c</a> ( EKNAME, ifname, nresvc, &amp;handle );

         /.
         Set up the table and column names and declarations
         for the DATAORDERS segment.  We'll index all of
         the columns.  All columns are scalar, so we omit
         the size declaration.  Only the COST column may take
         null values.
         ./
         strcpy( cnames[0], &quot;ORDER_ID&quot; );
         strcpy( cdecls[0], &quot;DATATYPE = INTEGER, INDEXED = TRUE&quot; );

         strcpy( cnames[1], &quot;CUSTOMER_ID&quot; );
         strcpy( cdecls[1], &quot;DATATYPE = INTEGER, INDEXED = TRUE&quot; );

         strcpy( cnames[2], &quot;LAST_NAME&quot; );
         strcpy( cdecls[2], &quot;DATATYPE = CHARACTER*(*), INDEXED  = TRUE&quot; );

         strcpy( cnames[3], &quot;FIRST_NAME&quot; );
         strcpy( cdecls[3], &quot;DATATYPE = CHARACTER*(*), INDEXED  = TRUE&quot; );

         strcpy( cnames[4], &quot;ORDER_DATE&quot; );
         strcpy( cdecls[4], &quot;DATATYPE = TIME, INDEXED  = TRUE&quot; );

         strcpy( cnames[5], &quot;COST&quot; );
         strcpy( cdecls[5], &quot;DATATYPE = DOUBLE PRECISION, &quot;
                            &quot;INDEXED  = TRUE, NULLS_OK = TRUE&quot; );

         /.
         Start the first segment. Since we have no data for this
         segment, start the segment by just defining the new
         segment's schema.
         ./
         <a href="ekbseg_c.html">ekbseg_c</a> ( handle, &quot;DATAORDERS&quot;, NCOLS,   SPICE_EK_CSTRLN,
                    cnames,  DECLEN,      cdecls, &amp;segno           );

         /.
         At this point, the second segment could be
         created by an analogous process.  In fact, the
         second segment could be created at any time; it is
         not necessary to populate the first segment with
         data before starting the second segment.

         Set up the table and column names and declarations
         for the DATAITEMS segment.  We'll index all of
         the columns.  All columns are scalar, so we omit
         the size declaration.
         ./
         strcpy( cnames[0], &quot;ITEM_ID&quot; );
         strcpy( cdecls[0], &quot;DATATYPE = INTEGER, INDEXED = TRUE&quot; );

         strcpy( cnames[1], &quot;ORDER_ID&quot; );
         strcpy( cdecls[1], &quot;DATATYPE = INTEGER, INDEXED = TRUE&quot; );

         strcpy( cnames[2], &quot;ITEM_NAME&quot; );
         strcpy( cdecls[2], &quot;DATATYPE = CHARACTER*(*), INDEXED  = TRUE&quot; );

         strcpy( cnames[3], &quot;DESCRIPTION&quot; );
         strcpy( cdecls[3], &quot;DATATYPE = CHARACTER*(*), INDEXED  = TRUE&quot; );

         strcpy( cnames[4], &quot;PRICE&quot; );
         strcpy( cdecls[4], &quot;DATATYPE = DOUBLE PRECISION, INDEXED  = TRUE&quot; );

         /.
         Start the new segment. Since we have no data for this
         segment, start the segment by just defining the new
         segment's schema.
         ./
         <a href="ekbseg_c.html">ekbseg_c</a> ( handle, &quot;DATAITEMS&quot;, 5,       SPICE_EK_CSTRLN,
                    cnames,  DECLEN,     cdecls, &amp;segno           );

         /.
         End the file by a call to <a href="ekcls_c.html">ekcls_c</a>.
         ./
         <a href="ekcls_c.html">ekcls_c</a> ( handle );

         /.
         Now, we want to insert a new record into the DATAITEMS
         table.

         Open the database for write access.  This call is
         made when the file already exists.
         ./
         <a href="ekopw_c.html">ekopw_c</a> ( EKNAME, &amp;handle );

         /.
         Append a new, empty record to the DATAITEMS
         table. Recall that the DATAITEMS table
         is in segment number 1.  The call will return
         the number of the new, empty record.
         ./
         segno = 1;
         <b>ekappr_c</b> ( handle, segno, &amp;recno );

         /.
         At this point, the new record is empty.  A valid EK
         cannot contain empty records.  We fill in the data
         here.  Data items are filled in one column at a time.
         The order in which the columns are filled in is not
         important.  We use the ekaceX_c (add column entry)
         routines to fill in column entries.  We'll assume
         that no entries are null.  All entries are scalar,
         so the entry size is 1.
         ./
         isnull   =  SPICEFALSE;
         esize    =  1;

         /.
         The following variables will contain the data for
         the new record.
         ./
         ordid    =   10011;
         itemid   =   531;
         itemnm   =  &quot;Sample item&quot;;
         descrp   =  &quot;This sample item is used only in tests.&quot;;
         price    =   1345.678;

         /.
         Note that the names of the routines called
         correspond to the data types of the columns:  the
         last letter of the routine name is C, `i', or D,
         depending on the data type.
         ./
         <a href="ekacei_c.html">ekacei_c</a> ( handle,  segno, recno, &quot;ORDER_ID&quot;,
                    esize,  &amp;ordid, isnull            );

         <a href="ekacei_c.html">ekacei_c</a> ( handle,  segno,  recno, &quot;ITEM_ID&quot;,
                    esize,  &amp;itemid, isnull           );

         <a href="ekacec_c.html">ekacec_c</a> ( handle, segno,  recno,  &quot;ITEM_NAME&quot;,
                    esize,  NAMLEN, itemnm,  isnull     );

         <a href="ekacec_c.html">ekacec_c</a> ( handle, segno,  recno,  &quot;DESCRIPTION&quot;,
                    esize,  DESCLN, descrp,  isnull       );

         <a href="ekaced_c.html">ekaced_c</a> ( handle, segno, recno, &quot;PRICE&quot;, esize, &amp;price, isnull );

         /.
         Close the file to make the update permanent.
         ./
         <a href="ekcls_c.html">ekcls_c</a> ( handle );

         return ( 0 );
      }


      When this program is executed, no output is presented on
      screen. After run completion, a new EK file exists in the
      output directory.
</PRE>
<h4><a name="Restrictions">Restrictions</a></h4>
<PRE>
   None.
</PRE>
<h4><a name="Literature_References">Literature_References</a></h4>
<PRE>
   None.
</PRE>
<h4><a name="Author_and_Institution">Author_and_Institution</a></h4>
<PRE>
   N.J. Bachman        (JPL)
   J. Diaz del Rio     (ODC Space)
</PRE>
<h4><a name="Version">Version</a></h4>
<PRE>
   -CSPICE Version 1.0.1, 24-NOV-2021 (JDR)

       Edited the header to comply with NAIF standard. Added
       complete code example.

   -CSPICE Version 1.0.0, 09-JAN-2002 (NJB)
</PRE>
<h4><a name="Index_Entries">Index_Entries</a></h4>
<PRE>
   append record to EK segment
</PRE>
<h4>Link to routine ekappr_c source file <a href='../../../src/cspice/ekappr_c.c'>ekappr_c.c</a> </h4>

      </td>
    </tr>
  </tbody>
</table>

   <pre>Fri Dec 31 18:41:05 2021</pre>

</body>
</html>

