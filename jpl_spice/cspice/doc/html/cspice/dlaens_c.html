
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<HTML>

<HEAD>
   <TITLE>dlaens_c</TITLE>
</HEAD>

<BODY style="color: rgb(0, 0, 0); background-color: rgb(255, 255, 255);">
<A name="TOP"></A>

<table style="text-align: left; margin-left: auto; margin-right: auto; width: 800px;"
 border="0" cellpadding="5" cellspacing="2">
  <tbody>
    <tr><td>
<div align="center">
Index of Functions: 
<A HREF="index.html#A">A</A>&nbsp;
<A HREF="index.html#B">B</A>&nbsp;
<A HREF="index.html#C">C</A>&nbsp;
<A HREF="index.html#D">D</A>&nbsp;
<A HREF="index.html#E">E</A>&nbsp;
<A HREF="index.html#F">F</A>&nbsp;
<A HREF="index.html#G">G</A>&nbsp;
<A HREF="index.html#H">H</A>&nbsp;
<A HREF="index.html#I">I</A>&nbsp;
<A HREF="index.html#J">J</A>&nbsp;
<A HREF="index.html#K">K</A>&nbsp;
<A HREF="index.html#L">L</A>&nbsp;
<A HREF="index.html#M">M</A>&nbsp;
<A HREF="index.html#N">N</A>&nbsp;
<A HREF="index.html#O">O</A>&nbsp;
<A HREF="index.html#P">P</A>&nbsp;
<A HREF="index.html#Q">Q</A>&nbsp;
<A HREF="index.html#R">R</A>&nbsp;
<A HREF="index.html#S">S</A>&nbsp;
<A HREF="index.html#T">T</A>&nbsp;
<A HREF="index.html#U">U</A>&nbsp;
<A HREF="index.html#V">V</A>&nbsp;
<A HREF="index.html#W">W</A>&nbsp;
<A HREF="index.html#X">X</A>&nbsp;
</div>
</td></tr>

    <tr>
      <td style="background-color: rgb(153, 153, 153); vertical-align: middle; text-align: center;">
      <div align="right"> 
      <small><small><a href="index.html">Index Page</a></small></small>
      </div>
      <b>dlaens_c</b></td>
    </tr>
    

    <tr>
      <td style="vertical-align: top;">

       <br>
       <div align="left"><b>Table of contents</b></div>
       <table style="text-align: left; width: 60%; margin-left: auto; margin-right: auto;"
       border="0" cellspacing="2" cellpadding="2">
        <tbody>
          <tr>
            <td style="width: 33%; text-align: center;">
              <a href="#Procedure">Procedure<br></a>
              <a href="#Abstract">Abstract<br></a>
              <a href="#Required_Reading">Required_Reading<br></a>
              <a href="#Keywords">Keywords<br></a>
              <a href="#Brief_I/O">Brief_I/O<br></a>
              <a href="#Detailed_Input">Detailed_Input<br></a>

              </td>
              <td style="vertical-align: top; width: 33%; text-align: center;">              <a href="#Detailed_Output">Detailed_Output<br></a>
              <a href="#Parameters">Parameters<br></a>
              <a href="#Exceptions">Exceptions<br></a>
              <a href="#Files">Files<br></a>
              <a href="#Particulars">Particulars<br></a>
              <big><b><a href="#Examples">Examples<br></a></b></big>

              </td>
              <td style="vertical-align: top; width: 33%; text-align: center;">              <a href="#Restrictions">Restrictions<br></a>
              <a href="#Literature_References">Literature_References<br></a>
              <a href="#Author_and_Institution">Author_and_Institution<br></a>
              <a href="#Version">Version<br></a>
              <a href="#Index_Entries">Index_Entries<br></a>
            </td>
          </tr>
        </tbody>
</table>
<hr>

<h4><a name="Procedure">Procedure</a></h4>
<PRE>
   dlaens_c ( DLA, end new segment ) 

   void dlaens_c ( SpiceInt            handle )

</PRE>
<h4><a name="Abstract">Abstract</a></h4>
<PRE>
   End a new segment in a DLA file.
</PRE>
<h4><a name="Required_Reading">Required_Reading</a></h4>
<PRE>
   <a href="../req/das.html">DAS</a>
   <a href="../req/dla.html">DLA</a>
</PRE>
<h4><a name="Keywords">Keywords</a></h4>
<PRE>
   DAS
   DLA
   FILES


</PRE>
<h4><a name="Brief_I/O">Brief_I/O</a></h4>
<PRE>
   VARIABLE  I/O  DESCRIPTION
   --------  ---  --------------------------------------------------
   handle     I   Handle of open DLA file.
</PRE>
<h4><a name="Detailed_Input">Detailed_Input</a></h4>
<PRE>
   handle      is the integer handle associated with the DLA file to
               be updated. This handle is used to identify the file
               in subsequent calls to other DLA or DAS routines.

               The DLA file must be open for write access. A new DLA
               segment is completed in the indicated file. The file
               is left open, since data may be written to the file
               following a call to this routine.
</PRE>
<h4><a name="Detailed_Output">Detailed_Output</a></h4>
<PRE>
   None. See the -Particulars and -Examples header sections for
   a description of the actions performed by this routine.
</PRE>
<h4><a name="Parameters">Parameters</a></h4>
<PRE>
   None.
</PRE>
<h4><a name="Exceptions">Exceptions</a></h4>
<PRE>
   1)  If the input file handle does not refer to a DAS file that is
       open for write access, an error is signaled by a routine
       in the call tree of this routine.

   2)  If an error occurs while reading or writing to the DLA file,
       the error is signaled by a routine in the call tree of
       this routine.
</PRE>
<h4><a name="Files">Files</a></h4>
<PRE>
   See description of input argument `handle'.
</PRE>
<h4><a name="Particulars">Particulars</a></h4>
<PRE>
   DLA files are built using the DAS low-level format; DLA files are
   a specialized type of DAS file in which data are organized as a
   doubly linked list of segments. Each segment's data belong to
   contiguous components of character, double precision, and integer
   type.

   This routine supports creation of a DLA segment. DLA segments
   are created by appending data to the DAS integer, double
   precision, and character address spaces of a DLA file. The new
   segment's descriptor is located immediately before the integer
   component of the segment's data.

   When a new segment is added to a DLA file, the segment is
   inserted into the file's doubly linked segment list. If the new
   segment is the first, the DLA file's first and last list entry
   pointers are updated to point to the new segment; specifically,
   these pointers point to the first integer of the new segment's
   descriptor. The backward pointer of the new segment is set to
   null in this case.

   If the new segment is not the first, the DLA file's list end
   pointer is updated to point to the new segment, and the forward
   pointer of the previous segment also is updated to point to the
   first integer of the new segment's descriptor. The backward
   pointer of the new segment points to to point to the first
   integer of the previous segment's descriptor.

   The normal sequence of operations required to create a DLA
   segment is as follows:

      Call <a href="dlaopn_c.html">dlaopn_c</a> to create a new, empty DLA file.

      For each segment to be created,

         Call <a href="dlabns_c.html">dlabns_c</a> to begin a segment.

         Use the DAS &quot;add&quot; and &quot;update&quot; routines to populate
         the segment with data.

         Call <b>dlaens_c</b> to end the segment.

      Call <a href="dascls_c.html">dascls_c</a> to segregate and close the DLA file.
</PRE>
<h4><a name="Examples">Examples</a></h4>
<PRE>
   The numerical results shown for this example may differ across
   platforms. The results depend on the SPICE kernels used as
   input, the compiler and supporting libraries, and the machine
   specific arithmetic implementation.

   1) Create a DLA file containing one segment; the segment
      contains character, double precision, and integer data.
      After writing and closing the file, open the file for
      read access; dump the data to standard output.


      Example code begins here.


      /.
         Program dlaens_ex1
      ./
      #include &lt;stdio.h&gt;
      #include &lt;string.h&gt;
      #include &quot;SpiceUsr.h&quot;

      int main( )
      {

         /.
         Local parameters
         ./
         #define DLA          &quot;dlaens_ex1.dla&quot;
         #define LNSIZE       61
         #define MAXC         5
         #define MAXD         50
         #define MAXI         100

         /.
         Local variables
         ./
         SpiceChar            buffer [2];
         SpiceChar            cvals  [MAXC][LNSIZE];
         SpiceChar            cvals2 [MAXC][LNSIZE];
         SpiceChar            cvastr [LNSIZE+1];
         SpiceChar          * ifname;

         SpiceDouble          dvals  [MAXD];
         SpiceDouble          dvals2 [MAXD];

         SpiceDLADescr        descr;

         SpiceInt             base;
         SpiceInt             handle;
         SpiceInt             i;
         SpiceInt             ivals  [MAXI];
         SpiceInt             ivals2 [MAXI];
         SpiceInt             j;
         SpiceInt             k;
         SpiceInt             n;
         SpiceInt             ncomch;

         SpiceBoolean         found;

         /.
         Set the internal file name.  Don't reserve characters in
         the DAS comment area.
         ./
         ifname = &quot;Example DLA file for testing&quot;;
         ncomch = 0;

         /.
         Open a new DLA file.
         ./
         <a href="dlaopn_c.html">dlaopn_c</a> ( DLA, &quot;DLA&quot;, ifname, ncomch, &amp;handle );

         /.
         Begin a new segment.
         ./
         <a href="dlabns_c.html">dlabns_c</a> ( handle );

         /.
         Add character data to the segment.
         ./
         for ( i = 0; i &lt; MAXC; i++ )
         {
            for ( j = 0; j &lt; LNSIZE; j++ )
            {

               /.
               Remove null-terminating character added to `buffer' in order to
               add it to the DLA file.
               ./
               k = ( (j+i+1) % 10 );
               snprintf(buffer, 2, &quot;%d&quot;, k);
               cvals[i][j] = buffer[0];
            }
         }

         <a href="dasadc_c.html">dasadc_c</a> ( handle, MAXC*LNSIZE, 0, LNSIZE-1, LNSIZE, cvals );

         /.
         Add integer and double precision data to the segment.
         ./
         for ( i = 0; i &lt; MAXI; i++ )
         {
            ivals[i] = i+1;
         }

         <a href="dasadi_c.html">dasadi_c</a> ( handle, MAXI, ivals );

         for ( i = 0; i &lt; MAXD; i++ )
         {
            dvals[i] = (double)i+1;
         }

         <a href="dasadd_c.html">dasadd_c</a> ( handle, MAXD, dvals );

         /.
         End the segment.
         ./
         <b>dlaens_c</b> ( handle );

         /.
         Close the file.  The routine <a href="dascls_c.html">dascls_c</a> flushes the DAS
         buffers and segregates the file before closing it.
         ./
         <a href="dascls_c.html">dascls_c</a> ( handle );

         /.
         Now read the file and check the data.
         ./
         <a href="dasopr_c.html">dasopr_c</a> ( DLA, &amp;handle );

         /.
         Obtain the segment descriptor for the sole segment
         in the file. We need not check the found flag
         in this case because we know there is one segment
         in the file.
         ./
         <a href="dlabfs_c.html">dlabfs_c</a> ( handle, &amp;descr, &amp;found );

         /.
         Fetch character data from the segment.  Obtain the
         base address of the character data and the
         character count from the descriptor.
         ./
         base = descr.cbase;
         n    = descr.csize;

         <a href="dasrdc_c.html">dasrdc_c</a> ( handle, base+1, base+n, 0, LNSIZE-1, LNSIZE, cvals2 );

         /.
         Display the character data.
         ./
         printf( &quot;\n&quot; );
         printf( &quot;Character array:\n&quot; );

         for ( i = 0; i &lt; n/LNSIZE; i++ )
         {
            /.
            Add null-terminating character to `cvals2[i]' in order to
            print it to the screen.
            ./
            strncpy( cvastr, cvals2[i], LNSIZE );
            cvastr[LNSIZE] = '\0';

            printf( &quot;%s\n&quot;, cvastr );
         }

         /.
         Fetch and display the integer and double precision data.
         ./
         base = descr.ibase;
         n    = descr.isize;

         <a href="dasrdi_c.html">dasrdi_c</a> ( handle, base+1, base+n, ivals2 );

         printf( &quot;\n&quot; );
         printf( &quot;Integer array:\n&quot; );
         for ( i = 0; i &lt; n/10; i++ )
         {
            for ( j = 0; j &lt; 10; j++ )
            {
               printf( &quot;%6d&quot;, ivals2[i*10+j] );
            }
            printf( &quot;\n&quot; );
         }

         base = descr.dbase;
         n    = descr.dsize;

         <a href="dasrdd_c.html">dasrdd_c</a> ( handle, base+1, base+n, dvals2 );

         printf( &quot;\n&quot; );
         printf( &quot;Double precision array:\n&quot; );
         for ( i = 0; i &lt; n/10; i++ )
         {
            for ( j = 0; j &lt; 10; j++ )
            {
               printf( &quot;%6.1f&quot;, dvals2[i*10+j] );
            }
            printf( &quot;\n&quot; );
         }

         /.
         Close the file.  This step is unnecessary in this
         program, but is a good practice in general
         because closing the file frees resources.
         ./
         <a href="dascls_c.html">dascls_c</a> ( handle );

         return ( 0 );
      }


      When this program was executed on a Mac/Intel/cc/64-bit
      platform, the output was:


      Character array:
      1234567890123456789012345678901234567890123456789012345678901
      2345678901234567890123456789012345678901234567890123456789012
      3456789012345678901234567890123456789012345678901234567890123
      4567890123456789012345678901234567890123456789012345678901234
      5678901234567890123456789012345678901234567890123456789012345

      Integer array:
           1     2     3     4     5     6     7     8     9    10
          11    12    13    14    15    16    17    18    19    20
          21    22    23    24    25    26    27    28    29    30
          31    32    33    34    35    36    37    38    39    40
          41    42    43    44    45    46    47    48    49    50
          51    52    53    54    55    56    57    58    59    60
          61    62    63    64    65    66    67    68    69    70
          71    72    73    74    75    76    77    78    79    80
          81    82    83    84    85    86    87    88    89    90
          91    92    93    94    95    96    97    98    99   100

      Double precision array:
         1.0   2.0   3.0   4.0   5.0   6.0   7.0   8.0   9.0  10.0
        11.0  12.0  13.0  14.0  15.0  16.0  17.0  18.0  19.0  20.0
        21.0  22.0  23.0  24.0  25.0  26.0  27.0  28.0  29.0  30.0
        31.0  32.0  33.0  34.0  35.0  36.0  37.0  38.0  39.0  40.0
        41.0  42.0  43.0  44.0  45.0  46.0  47.0  48.0  49.0  50.0


      Note that after run completion, a new DLA file exists in the
      output directory.
</PRE>
<h4><a name="Restrictions">Restrictions</a></h4>
<PRE>
   None.
</PRE>
<h4><a name="Literature_References">Literature_References</a></h4>
<PRE>
   None.
</PRE>
<h4><a name="Author_and_Institution">Author_and_Institution</a></h4>
<PRE>
   J. Diaz del Rio     (ODC Space)
</PRE>
<h4><a name="Version">Version</a></h4>
<PRE>
   -CSPICE Version 1.0.0, 14-JUN-2021 (JDR)
</PRE>
<h4><a name="Index_Entries">Index_Entries</a></h4>
<PRE>
   end new segment in DLA file
</PRE>
<h4>Link to routine dlaens_c source file <a href='../../../src/cspice/dlaens_c.c'>dlaens_c.c</a> </h4>

      </td>
    </tr>
  </tbody>
</table>

   <pre>Fri Dec 31 18:41:04 2021</pre>

</body>
</html>

