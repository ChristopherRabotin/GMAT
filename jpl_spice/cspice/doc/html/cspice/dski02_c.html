
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<HTML>

<HEAD>
   <TITLE>dski02_c</TITLE>
</HEAD>

<BODY style="color: rgb(0, 0, 0); background-color: rgb(255, 255, 255);">
<A name="TOP"></A>

<table style="text-align: left; margin-left: auto; margin-right: auto; width: 800px;"
 border="0" cellpadding="5" cellspacing="2">
  <tbody>
    <tr><td>
<div align="center">
Index of Functions: 
<A HREF="index.html#A">A</A>&nbsp;
<A HREF="index.html#B">B</A>&nbsp;
<A HREF="index.html#C">C</A>&nbsp;
<A HREF="index.html#D">D</A>&nbsp;
<A HREF="index.html#E">E</A>&nbsp;
<A HREF="index.html#F">F</A>&nbsp;
<A HREF="index.html#G">G</A>&nbsp;
<A HREF="index.html#H">H</A>&nbsp;
<A HREF="index.html#I">I</A>&nbsp;
<A HREF="index.html#J">J</A>&nbsp;
<A HREF="index.html#K">K</A>&nbsp;
<A HREF="index.html#L">L</A>&nbsp;
<A HREF="index.html#M">M</A>&nbsp;
<A HREF="index.html#N">N</A>&nbsp;
<A HREF="index.html#O">O</A>&nbsp;
<A HREF="index.html#P">P</A>&nbsp;
<A HREF="index.html#Q">Q</A>&nbsp;
<A HREF="index.html#R">R</A>&nbsp;
<A HREF="index.html#S">S</A>&nbsp;
<A HREF="index.html#T">T</A>&nbsp;
<A HREF="index.html#U">U</A>&nbsp;
<A HREF="index.html#V">V</A>&nbsp;
<A HREF="index.html#W">W</A>&nbsp;
<A HREF="index.html#X">X</A>&nbsp;
</div>
</td></tr>

    <tr>
      <td style="background-color: rgb(153, 153, 153); vertical-align: middle; text-align: center;">
      <div align="right"> 
      <small><small><a href="index.html">Index Page</a></small></small>
      </div>
      <b>dski02_c</b></td>
    </tr>
    

    <tr>
      <td style="vertical-align: top;">

       <br>
       <div align="left"><b>Table of contents</b></div>
       <table style="text-align: left; width: 60%; margin-left: auto; margin-right: auto;"
       border="0" cellspacing="2" cellpadding="2">
        <tbody>
          <tr>
            <td style="width: 33%; text-align: center;">
              <a href="#Procedure">Procedure<br></a>
              <a href="#Abstract">Abstract<br></a>
              <a href="#Required_Reading">Required_Reading<br></a>
              <a href="#Keywords">Keywords<br></a>
              <a href="#Brief_I/O">Brief_I/O<br></a>
              <a href="#Detailed_Input">Detailed_Input<br></a>

              </td>
              <td style="vertical-align: top; width: 33%; text-align: center;">              <a href="#Detailed_Output">Detailed_Output<br></a>
              <a href="#Parameters">Parameters<br></a>
              <a href="#Exceptions">Exceptions<br></a>
              <a href="#Files">Files<br></a>
              <a href="#Particulars">Particulars<br></a>
              <big><b><a href="#Examples">Examples<br></a></b></big>

              </td>
              <td style="vertical-align: top; width: 33%; text-align: center;">              <a href="#Restrictions">Restrictions<br></a>
              <a href="#Literature_References">Literature_References<br></a>
              <a href="#Author_and_Institution">Author_and_Institution<br></a>
              <a href="#Version">Version<br></a>
              <a href="#Index_Entries">Index_Entries<br></a>
            </td>
          </tr>
        </tbody>
</table>
<hr>

<h4><a name="Procedure">Procedure</a></h4>
<PRE>
   dski02_c ( DSK, fetch integer type 2 data ) 

   void dski02_c ( SpiceInt              handle,
                   ConstSpiceDLADescr  * dladsc,
                   SpiceInt              item,
                   SpiceInt              start,
                   SpiceInt              room,
                   SpiceInt            * n,
                   SpiceInt            * values   )

</PRE>
<h4><a name="Abstract">Abstract</a></h4>
<PRE>
   Fetch integer data from a type 2 DSK segment.
</PRE>
<h4><a name="Required_Reading">Required_Reading</a></h4>
<PRE>
   <a href="../req/das.html">DAS</a>
   <a href="../req/dsk.html">DSK</a>
</PRE>
<h4><a name="Keywords">Keywords</a></h4>
<PRE>
   DAS
   DSK
   FILES
   TOPOGRAPHY


</PRE>
<h4><a name="Brief_I/O">Brief_I/O</a></h4>
<PRE>
   VARIABLE  I/O  DESCRIPTION
   --------  ---  --------------------------------------------------
   handle     I   DSK file handle.
   dladsc     I   DLA descriptor.
   item       I   Keyword identifying item to fetch.
   start      I   Start index.
   room       I   Amount of room in output array.
   n          O   Number of values returned.
   values     O   Array containing requested item.
</PRE>
<h4><a name="Detailed_Input">Detailed_Input</a></h4>
<PRE>
   handle      is the handle of a DSK file containing a type 2
               segment from which data are to be fetched.

   dladsc      is the DLA descriptor associated with the segment
               from which data are to be fetched.

   item        is an integer &quot;keyword&quot; parameter designating the
               integer data item to fetch.

               Names, meanings, and value of keyword parameters
               supported by this routine are given in the header
               file

                  SpiceDSK.h

               The keyword parameters for integer data listed there
               are supported by this routine.

   start       is the start index within specified data item from
               which data are to be fetched. The index of the first
               element of each data item is 0. This convention
               applies uniformly to all data, even if the data are
               associated with a set of 1-based indices. For
               example, the plate ID range starts at 1 (this fact is
               language-independent), but a caller would use a
               `start' value of 0 to fetch the vertex indices of the
               first plate.

   room        is the amount of room in the output array. It is
               permissible to provide an output array that has
               too little room to fetch an item in one call. `room'
               has units of integers: for example, the room
               required to fetch one plate is 3.
</PRE>
<h4><a name="Detailed_Output">Detailed_Output</a></h4>
<PRE>
   n           is the number of elements fetched to the output
               array `values'. `n' is normally in the range
               1:room; if an error occurs on the call, `n' is
               undefined.

   values      is a contiguous set of elements of the item
               designated by `item'. The correspondence of
               `values' with the elements of the data item is:

                  values[0]      item[start]
                    ...             ...
                  values[n-1]    item[start+n-1]

               If an error occurs on the call, `values' is
               undefined.
</PRE>
<h4><a name="Parameters">Parameters</a></h4>
<PRE>
   See the header file

      SpiceDLA.h

   for declarations of DLA descriptor sizes and documentation of the
   contents of DLA descriptors.

   See the header file

      SpiceDSK.h

   for declarations of DSK descriptor sizes and documentation of the
   contents of DSK descriptors.

   See the header file

      SpiceDSK.h

   for declarations of DSK data type 2 (plate model) parameters.
</PRE>
<h4><a name="Exceptions">Exceptions</a></h4>
<PRE>
   1)  If the input handle is invalid, an error is signaled by a
       routine in the call tree of this routine.

   2)  If a file read error occurs, the error is signaled by a
       routine in the call tree of this routine.

   3)  If the input DLA descriptor is invalid, the effect of this
       routine is undefined. The error *may* be diagnosed by
       routines in the call tree of this routine, but there are no
       guarantees.

   4)  If `room' is non-positive, the error SPICE(VALUEOUTOFRANGE)
       is signaled by a routine in the call tree of this routine.

   5)  If the coarse voxel scale read from the designated segment is less
       than 1, the error SPICE(VALUEOUTOFRANGE) is signaled by a routine in
       the call tree of this routine.

   6)  If the input keyword parameter is not recognized, the error
       SPICE(NOTSUPPORTED) is signaled by a routine in the call tree of this
       routine.

   7)  If `start' is less than 0 or greater than or equal to the size of
       the item to be fetched, the error SPICE(INDEXOUTOFRANGE) is
       signaled by a routine in the call tree of this routine.
</PRE>
<h4><a name="Files">Files</a></h4>
<PRE>
   See input argument `handle'.
</PRE>
<h4><a name="Particulars">Particulars</a></h4>
<PRE>
   Most SPICE applications will not need to call this routine. The
   routines <a href="dskv02_c.html">dskv02_c</a>, <a href="dskp02_c.html">dskp02_c</a>, and <a href="dskz02_c.html">dskz02_c</a> provide a higher-level
   interface for fetching DSK type 2 vertex and plate data.

   DSK files are built using the DLA low-level format and
   the DAS architecture; DLA files are a specialized type of DAS
   file in which data are organized as a doubly linked list of
   segments. Each segment's data belong to contiguous components of
   character, double precision, and integer type.

   Note that the DSK descriptor for the segment is not needed by this
   routine; the DLA descriptor contains the base address and size
   information for the integer, double precision, and character
   components of the segment, and these suffice for the purpose of
   fetching data.
</PRE>
<h4><a name="Examples">Examples</a></h4>
<PRE>
   The numerical results shown for this example may differ across
   platforms. The results depend on the SPICE kernels used as
   input, the compiler and supporting libraries, and the machine
   specific arithmetic implementation.

   1) Look up all the vertices associated with each plate
      of the model contained in a specified type 2 segment.
      For the first 5 plates, display the plate's vertices.

      For this example, we'll show the context of this look-up:
      opening the DSK file for read access, traversing a trivial,
      one-segment list to obtain the segment of interest.


      Example code begins here.


      /.
         Program dski02_ex1
      ./
      #include &lt;stdio.h&gt;
      #include &quot;SpiceUsr.h&quot;

      int main()
      {

         /.
         Local parameters
         ./
         #define FILSIZ          256

         /.
         Local variables
         ./
         SpiceBoolean            found;

         SpiceChar               dsk     [ FILSIZ ];

         SpiceDLADescr           dladsc;

         SpiceDouble             vrtces  [3][3];

         SpiceInt                handle;
         SpiceInt                i;
         SpiceInt                j;
         SpiceInt                n;
         SpiceInt                np;
         SpiceInt                start;
         SpiceInt                vrtids  [3];


         /.
         Prompt for the name of the DSK to read.
         ./
         <a href="prompt_c.html">prompt_c</a> ( &quot;Enter DSK name &gt; &quot;, FILSIZ, dsk );

         /.
         Open the DSK file for read access. We use the DAS-level
         interface for this function.
         ./
         <a href="dasopr_c.html">dasopr_c</a> ( dsk, &amp;handle );

         /.
         Begin a forward search through the kernel, treating the
         file as a DLA. In this example, it's a very short search.
         ./
         <a href="dlabfs_c.html">dlabfs_c</a> ( handle, &amp;dladsc, &amp;found );

         if ( !found  )
         {
            /.
            We arrive here only if the kernel
            contains no segments.  This is
            unexpected, but we're prepared for it.
            ./
            <a href="setmsg_c.html">setmsg_c</a> ( &quot;No segments found in DSK file #.&quot; );
            <a href="errch_c.html">errch_c</a>  ( &quot;#&quot;, dsk                           );
            <a href="sigerr_c.html">sigerr_c</a> ( &quot;SPICE(NODATA)&quot;                    );
         }

         /.
         If we made it this far, `dladsc' is the
         DLA descriptor of the first segment.

         Find the number of plates in the model.
         ./
         <b>dski02_c</b> ( handle, &amp;dladsc, SPICE_DSK02_KWNP,
                    0,      1,       &amp;n,             &amp;np );

         /.
         For the first 5 plates, look up the desired data.
         ./
         np = <a href="mini_c.html">mini_c</a> ( 2, 5, np );
         for ( i = 1;  i &lt;= np;  i++ )
         {
            /.
            For the Ith plate, find the associated
            vertex IDs.  We must take into account
            the fact that each plate has three
            vertices when we compute the start
            index.
            ./
            start = 3*(i-1);

            <b>dski02_c</b> ( handle, &amp;dladsc, SPICE_DSK02_KWPLAT, start,
                       3,      &amp;n,      vrtids                   );

            for ( j = 0;  j &lt; 3;  j++  )
            {
               /.
               Fetch the vertex associated with
               the jth vertex ID.  Again, each
               vertex is a 3-vector.  Note that
               the vertices are double-precision
               data, so we fetch them using
               <a href="dskd02_c.html">dskd02_c</a>.
               ./
               start = (vrtids[j]-1)*3;

               <a href="dskd02_c.html">dskd02_c</a> ( handle, &amp;dladsc, SPICE_DSK02_KWVERT, start,
                          3,      &amp;n,      vrtces[j]               );
            }

            /.
            Display the vertices of the ith plate:
            ./
            printf ( &quot;\n&quot;
                     &quot;Plate number:  %d\n&quot;
                     &quot;   Vertex 1: ( %+e   %+e   %+e )\n&quot;
                     &quot;   Vertex 2: ( %+e   %+e   %+e )\n&quot;
                     &quot;   Vertex 3: ( %+e   %+e   %+e )\n&quot;,
                     (int)i,
                     vrtces[0][0], vrtces[0][1], vrtces[0][2],
                     vrtces[1][0], vrtces[1][1], vrtces[1][2],
                     vrtces[2][0], vrtces[2][1], vrtces[2][2]  );
         }

         /.
         Close the kernel.  This isn't necessary in a stand-
         alone program, but it's good practice in subroutines
         because it frees program and system resources.
         ./
         <a href="dascls_c.html">dascls_c</a> ( handle );

         return ( 0 );
      }


      When this program was executed on a Mac/Intel/cc/64-bit
      platform, using the DSK file named phobos512.bds, the output
      was:


      Enter DSK name &gt; phobos512.bds

      Plate number:  1
         Vertex 1: ( -6.774440e+00   +6.268150e+00   +6.011490e+00 )
         Vertex 2: ( -6.762380e+00   +6.257280e+00   +6.025560e+00 )
         Vertex 3: ( -6.757100e+00   +6.277540e+00   +6.020960e+00 )

      Plate number:  2
         Vertex 1: ( -6.774440e+00   +6.268150e+00   +6.011490e+00 )
         Vertex 2: ( -6.779730e+00   +6.247900e+00   +6.016100e+00 )
         Vertex 3: ( -6.762380e+00   +6.257280e+00   +6.025560e+00 )

      Plate number:  3
         Vertex 1: ( -6.779730e+00   +6.247900e+00   +6.016100e+00 )
         Vertex 2: ( -6.767680e+00   +6.237010e+00   +6.030190e+00 )
         Vertex 3: ( -6.762380e+00   +6.257280e+00   +6.025560e+00 )

      Plate number:  4
         Vertex 1: ( -6.779730e+00   +6.247900e+00   +6.016100e+00 )
         Vertex 2: ( -6.784990e+00   +6.227620e+00   +6.020700e+00 )
         Vertex 3: ( -6.767680e+00   +6.237010e+00   +6.030190e+00 )

      Plate number:  5
         Vertex 1: ( -6.784990e+00   +6.227620e+00   +6.020700e+00 )
         Vertex 2: ( -6.772990e+00   +6.216740e+00   +6.034820e+00 )
         Vertex 3: ( -6.767680e+00   +6.237010e+00   +6.030190e+00 )
</PRE>
<h4><a name="Restrictions">Restrictions</a></h4>
<PRE>
   1)  The underlying SPICELIB routine

          DSKI02

       called by this routine uses discovery check-in to boost execution
       speed. However, that routine is in violation of NAIF standards
       for use of discovery check-in:  routines called from that routine
       may signal errors. If errors are signaled in routines called
       from the SPICELIB routine DSKI02, that routine's name will be missing
       from the traceback message.
</PRE>
<h4><a name="Literature_References">Literature_References</a></h4>
<PRE>
   None.
</PRE>
<h4><a name="Author_and_Institution">Author_and_Institution</a></h4>
<PRE>
   N.J. Bachman        (JPL)
   J. Diaz del Rio     (ODC Space)
</PRE>
<h4><a name="Version">Version</a></h4>
<PRE>
   -CSPICE Version 1.0.1, 02-JUL-2021 (JDR)

       Edited the header to comply with NAIF standard. Updated
       code example to reduce the number of plates whose vertices are
       shown on output and to remove unnecessary include files.

   -CSPICE Version 1.0.0, 04-APR-2017 (NJB)

       Updated parameter references in example program.
       Removed unnecessary include statements.
       Updated header.

       DSKLIB_C Version 1.0.1, 11-JUL-2014 (NJB)

          Corrected minor header comment typos.

       DSKLIB_C Version 1.0.0, 11-FEB-2010 (NJB)
</PRE>
<h4><a name="Index_Entries">Index_Entries</a></h4>
<PRE>
   fetch integer data from a type 2 DSK segment
</PRE>
<h4>Link to routine dski02_c source file <a href='../../../src/cspice/dski02_c.c'>dski02_c.c</a> </h4>

      </td>
    </tr>
  </tbody>
</table>

   <pre>Fri Dec 31 18:41:04 2021</pre>

</body>
</html>

