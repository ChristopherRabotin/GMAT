
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<HTML>

<HEAD>
   <TITLE>limb_pl02</TITLE>
</HEAD>

<BODY style="color: rgb(0, 0, 0); background-color: rgb(255, 255, 255);">
<A name="TOP"></A>

<table style="text-align: left; margin-left: auto; margin-right: auto; width: 800px;"
 border="0" cellpadding="5" cellspacing="2">
  <tbody>
    <tr><td>
<div align="center">
Index of Functions: 
<A HREF="index.html#A">A</A>&nbsp;
<A HREF="index.html#B">B</A>&nbsp;
<A HREF="index.html#C">C</A>&nbsp;
<A HREF="index.html#D">D</A>&nbsp;
<A HREF="index.html#E">E</A>&nbsp;
<A HREF="index.html#F">F</A>&nbsp;
<A HREF="index.html#G">G</A>&nbsp;
<A HREF="index.html#H">H</A>&nbsp;
<A HREF="index.html#I">I</A>&nbsp;
<A HREF="index.html#J">J</A>&nbsp;
<A HREF="index.html#K">K</A>&nbsp;
<A HREF="index.html#L">L</A>&nbsp;
<A HREF="index.html#M">M</A>&nbsp;
<A HREF="index.html#N">N</A>&nbsp;
<A HREF="index.html#O">O</A>&nbsp;
<A HREF="index.html#P">P</A>&nbsp;
<A HREF="index.html#Q">Q</A>&nbsp;
<A HREF="index.html#R">R</A>&nbsp;
<A HREF="index.html#S">S</A>&nbsp;
<A HREF="index.html#T">T</A>&nbsp;
<A HREF="index.html#U">U</A>&nbsp;
<A HREF="index.html#V">V</A>&nbsp;
<A HREF="index.html#W">W</A>&nbsp;
<A HREF="index.html#X">X</A>&nbsp;
</div>
</td></tr>

    <tr>
      <td style="background-color: rgb(153, 153, 153); vertical-align: middle; text-align: center;">
      <div align="right"> 
      <small><small><a href="index.html">Index Page</a></small></small>
      </div>
      <b>limb_pl02</b></td>
    </tr>
    

    <tr>
      <td style="vertical-align: top;">

       <br>
       <div align="left"><b>Table of contents</b></div>
       <table style="text-align: left; width: 60%; margin-left: auto; margin-right: auto;"
       border="0" cellspacing="2" cellpadding="2">
        <tbody>
          <tr>
            <td style="width: 33%; text-align: center;">
              <a href="#Procedure">Procedure<br></a>
              <a href="#Abstract">Abstract<br></a>
              <a href="#Required_Reading">Required_Reading<br></a>
              <a href="#Keywords">Keywords<br></a>
              <a href="#Brief_I/O">Brief_I/O<br></a>
              <a href="#Detailed_Input">Detailed_Input<br></a>

              </td>
              <td style="vertical-align: top; width: 33%; text-align: center;">              <a href="#Detailed_Output">Detailed_Output<br></a>
              <a href="#Parameters">Parameters<br></a>
              <a href="#Exceptions">Exceptions<br></a>
              <a href="#Files">Files<br></a>
              <a href="#Particulars">Particulars<br></a>
              <big><b><a href="#Examples">Examples<br></a></b></big>

              </td>
              <td style="vertical-align: top; width: 33%; text-align: center;">              <a href="#Restrictions">Restrictions<br></a>
              <a href="#Literature_References">Literature_References<br></a>
              <a href="#Author_and_Institution">Author_and_Institution<br></a>
              <a href="#Version">Version<br></a>
              <a href="#Index_Entries">Index_Entries<br></a>
            </td>
          </tr>
        </tbody>
</table>
<hr>

<h4><a name="Procedure">Procedure</a></h4>
<PRE>
   limb_pl02 ( Limb using DSK type 2 plate model ) 

   void limb_pl02 ( SpiceInt              handle,
                    ConstSpiceDLADescr  * dladsc,
                    ConstSpiceChar      * target,
                    SpiceDouble           et,
                    ConstSpiceChar      * fixref,
                    ConstSpiceChar      * abcorr,
                    ConstSpiceChar      * obsrvr,
                    SpiceInt              npts,
                    SpiceDouble         * trgepc,
                    SpiceDouble           obspos [3],
                    SpiceDouble           lmbpts [][3],
                    SpiceInt              pltids []     )

</PRE>
<h4><a name="Abstract">Abstract</a></h4>
<PRE>
   Deprecated: This routine has been superseded by the CSPICE routine
   <a href="limbpt_c.html">limbpt_c</a>. This routine is supported for purposes of backward
   compatibility only.

   Compute a set of points on the limb of a specified target body,
   where the target body's surface is represented by a triangular plate
   model contained in a type 2 DSK segment.
</PRE>
<h4><a name="Required_Reading">Required_Reading</a></h4>
<PRE>
   <a href="../req/naif_ids.html">NAIF_IDS</a>
   <a href="../req/pck.html">PCK</a>
   <a href="../req/spk.html">SPK</a>
   <a href="../req/time.html">TIME</a>
</PRE>
<h4><a name="Keywords">Keywords</a></h4>
<PRE>
   BODY
   GEOMETRY
   MATH


</PRE>
<h4><a name="Brief_I/O">Brief_I/O</a></h4>
<PRE>
   VARIABLE  I/O  DESCRIPTION
   --------  ---  --------------------------------------------------
   handle     I   DSK handle.
   dladsc     I   DLA descriptor of target body segment.
   target     I   Target body.
   et         I   Observation epoch.
   fixref     I   Body-fixed frame associated with target.
   abcorr     I   Aberration correction.
   obsrvr     I   Observer.
   npts       I   Number of points in limb set.
   trgepc     O   Epoch associated with target center.
   obspos     O   Position of observer in body-fixed frame.
   lmbpts     O   Limb point set.
   pltids     O   DSK plate IDs of surface points.
</PRE>
<h4><a name="Detailed_Input">Detailed_Input</a></h4>
<PRE>
   handle      is the DAS file handle of a DSK file open for read
               access. This kernel must contain a type 2 segment that
               provides a plate model representing the entire surface
               of the target body.

   dladsc      is the DLA descriptor of a DSK segment representing the
               surface of a target body.

   target      is the name of the target body. `target' is
               case-insensitive, and leading and trailing blanks in
               `target' are not significant. Optionally, you may supply
               a string containing the integer ID code for the object.
               For example both &quot;MOON&quot; and &quot;301&quot; are legitimate strings
               that indicate the moon is the target body.

               This routine assumes that a kernel variable representing
               the target's radii is present in the kernel pool.
               Normally the kernel variable would be defined by loading
               a PCK file.

   et          is the epoch of participation of the observer,
               expressed as ephemeris seconds past J2000 TDB: `et' is
               the epoch at which the observer's position is
               computed.

               When aberration corrections are not used, `et' is also
               the epoch at which the position and orientation of the
               target body are computed.

               When aberration corrections are used, `et' is the epoch
               at which the observer's position relative to the solar
               system barycenter is computed; in this case the position
               and orientation of the target body are computed at
               et-lt, where `lt' is the one-way light time between the
               target body's center and the observer. See the
               description of `abcorr' below for details.

   fixref      is the name of the reference frame relative to which the
               output limb points are expressed. This must a
               body-centered, body-fixed frame associated with the
               target. The frame's axes must be compatible with the
               triaxial ellipsoidal shape model associated with the
               target body (normally provide via a PCK): this routine
               assumes that the first, second, and third ellipsoid radii
               correspond, respectively, to the x, y, and z-axes of the
               frame designated by `fixref'.

               `fixref' may refer to a built-in frame (documented in
               the Frames Required Reading) or a frame defined by a
               loaded frame kernel (FK).

               The orientation of the frame designated by `fixref' is
               evaluated at epoch of participation of the target
               body. See the descriptions of `et' and `abcorr' for
               details.

   abcorr      indicates the aberration correction to be applied
               when computing the observer-target position, the
               orientation of the target body, and the target-
               source position vector.  `abcorr' may be any of
               the following.

                  &quot;NONE&quot;     Apply no correction. Compute the limb
                             points using the position of the observer
                             and target, and the orientation of the
                             target, at `et'.

               Let `lt' represent the one-way light time between the
               observer and the target body's center. The following
               values of `abcorr' apply to the &quot;reception&quot; case in
               which photons depart from the target body's center at
               the light-time corrected epoch et-lt and *arrive* at
               the observer's location at `et':


                  &quot;LT&quot;       Correct for one-way light time (also
                             called &quot;planetary aberration&quot;) using a
                             Newtonian formulation. This correction
                             yields the location of the limb points at
                             the approximate time they emitted photons
                             arriving at the observer at `et' (the
                             difference between light time to the
                             target center and light time to the limb
                             points is ignored).

                             The light time correction uses an
                             iterative solution of the light time
                             equation. The solution invoked by the
                             &quot;LT&quot; option uses one iteration.

                             The target position as seen by the
                             observer and the rotation of the target
                             body are corrected for light time.

                  'LT+S'     Correct for one-way light time and stellar
                             aberration using a Newtonian formulation.
                             This option modifies the position obtained
                             with the &quot;LT&quot; option to account for the
                             observer's velocity relative to the solar
                             system barycenter. The result is the
                             apparent limb as seen by the observer.

                  &quot;CN&quot;       Converged Newtonian light time correction.
                             In solving the light time equation, the
                             &quot;CN&quot; correction iterates until the
                             solution converges. The position and
                             rotation of the target body are corrected
                             for light time.

                  'CN+S'     Converged Newtonian light time
                             and stellar aberration corrections.

   obsrvr      is the name of the observing body. This is typically
               a spacecraft, the Earth, or a surface point on the
               Earth.  `obsrvr' is case-insensitive, and leading and
               trailing blanks in `obsrvr' are not significant.
               Optionally, you may supply a string containing the
               integer ID code for the object. For example both
               &quot;EARTH&quot; and &quot;399&quot; are legitimate strings that indicate
               the Earth is the observer.


   npts        is the number of limb points to compute.
</PRE>
<h4><a name="Detailed_Output">Detailed_Output</a></h4>
<PRE>
   trgepc      is the &quot;target epoch.&quot;  `trgepc' is defined as follows:
               letting `lt' be the one-way light time between the
               target center and observer, `trgepc' is either the
               epoch et-lt or `et' depending on whether the requested
               aberration correction is, respectively, for received
               radiation or omitted. `lt' is computed using the
               method indicated by `abcorr'.

               `trgepc' is expressed as seconds past J2000 TDB.

   obspos      is the vector from the center of the target body at
               epoch `trgepc' to the observer at epoch `et'.  `obspos' is
               expressed in the target body-fixed reference frame
               `fixref', which is evaluated at `trgepc'.

               `obspos' is returned to simplify various related
               computations that would otherwise be cumbersome. For
               example, the vector `xvec' from the observer to the
               Ith limb point can be calculated via the call

                  <a href="vminus_c.html">vminus_c</a> ( lmbpts[i], obspos, xvec );

               The components of `obspos' are given in units of km.

   lmbpts      is an array of points on the limb of the target.
               The ith point is contained in the array elements

                   lmbpts[i][j],  j = 0, 1, 2

               As described above, each limb point lies on a ray
               emanating from the center of the target and passing
               through a limb point on the target's reference
               ellipsoid. Each limb point *on the reference ellipsoid*
               is the point of tangency of a ray that emanates from the
               observer. Measured in a cylindrical coordinate system
               whose Z-axis is parallel to the observer-target vector,
               the magnitude of the separation in longitude between the
               limb points is

                  2*Pi / npts

               The limb points are expressed in the body-fixed
               reference frame designated by `fixref'; the
               orientation of the frame is evaluated at `trgepc'.
               Units are km.

   pltids      is an array of integer ID codes of the plates on which
               the limb points are located. The ith plate ID
               corresponds to the ith limb point. These ID codes can
               be use to look up data associated with the plates, such
               as the plates' vertices or outward normal vectors.

               `pltids' should be declared by the caller

                  SpiceInt        pltids [npts];
</PRE>
<h4><a name="Parameters">Parameters</a></h4>
<PRE>
   None.
</PRE>
<h4><a name="Exceptions">Exceptions</a></h4>
<PRE>
   1)  If the target name `target' cannot be mapped
       to a body ID code, the error SPICE(IDCODENOTFOUND)
       is signaled.

   2)  If the observer name `obsrvr' cannot be mapped to a body ID
       code, the error SPICE(IDCODENOTFOUND) is signaled.

   3)  If `obsrvr' and `target' map to the same NAIF integer ID codes,
       the error SPICE(BODIESNOTDISTINCT) is signaled.

   4)  If the input frame name `fixref' cannot be mapped
       to a frame ID code, the error SPICE(UNKNOWNFRAME) is
       signaled.

   5)  If the frame designated by `fixref' is not centered
       on the target, the error SPICE(INVALIDFRAME) is
       signaled.

   6)  If the set size `npts' is not at least 1, the error
       SPICE(INVALIDCOUNT) is signaled.

   7)  If any of the reference ellipsoid's semi-axis lengths is
       non-positive, an error is signaled by a routine in the
       call tree of this routine.

   8)  If radii for the target body are not available in the kernel
       pool, an error is signaled by a routine in the call tree
       of this routine.

   9)  If radii are available but the target body does not have three
       radii, the error SPICE(INVALIDCOUNT) is signaled.

   10) If any SPK look-up fails, an error is signaled by
       a routine in the call tree of this routine.

   11) If a DSK providing a DSK type 2 plate model has not been
       loaded prior to calling <a href="llgrid_pl02.html">llgrid_pl02</a>, an error is signaled by a
       routine in the call tree of this routine.

   12) If the segment associated with the input DLA descriptor is not
       of data type 2, the error SPICE(WRONGDATATYPE) is signaled.

   13) If a surface point cannot be computed because the ray
       corresponding to a longitude/latitude pair fails to intersect
       the target surface as defined by the plate model, an error is
       signaled by a routine in the call tree of this routine.

   14) If the DSK segment identified by `dladsc' is not for the
       body identified by `target', the error SPICE(DSKTARGETMISMATCH)
       is signaled.

   15) If any input string pointer is null, the error SPICE(NULLPOINTER)
       is signaled.

   16) If any input string has length zero, the error SPICE(EMPTYSTRING)
       is signaled.
</PRE>
<h4><a name="Files">Files</a></h4>
<PRE>
   Appropriate DSK, SPK, PCK, and frame kernels must be loaded by the
   calling program before this routine is called.

   The following data are required:

   -  DSK data:  a DSK file containing a plate model representing the
      target body's surface must be loaded. This kernel must contain
      a type 2 segment that contains data for the entire surface of
      the target body.

   -  SPK data: ephemeris data for target and observer must be
      loaded. If aberration corrections are used, the states of both
      objects relative to the solar system barycenter must be
      calculable from the available ephemeris data. Typically
      ephemeris data are made available by loading one or more SPK
      files via <a href="furnsh_c.html">furnsh_c</a>.

   -  PCK data: triaxial radii for the target body must be loaded
      into the kernel pool. Typically this is done by loading a text
      PCK file via <a href="furnsh_c.html">furnsh_c</a>.

   -  Further PCK data: rotation data for the target body must
      be loaded. These may be provided in a text or binary PCK
      file.

   -  Frame data: if a frame definition is required to convert
      the observer and target states to the target body-fixed
      frame designated by `fixref', that definition must be
      available in the kernel pool. Typically the definitions of
      frames not already built-in to SPICE are supplied by loading
      a frame kernel.

   In all cases, kernel data are normally loaded once per program
   run, NOT every time this routine is called.
</PRE>
<h4><a name="Particulars">Particulars</a></h4>
<PRE>
   Boundaries of visible regions on an arbitrary surface are often
   complicated point sets: boundaries of mountains and craters, if
   present, may contribute to the overall set. To make the limb
   computation tractable, we simplify the problem by using a reference
   ellipsoid for guidance. We compute a set of limb points on the
   reference ellipsoid for the target body, then use those points to
   define the latitudes and longitudes of limb points on the surface
   defined by the specified triangular shape model. As such, the set
   of limb points found by this routine is just an approximation.
</PRE>
<h4><a name="Examples">Examples</a></h4>
<PRE>
   The numerical results shown for this example may differ across
   platforms. The results depend on the SPICE kernels used as input,
   the compiler and supporting libraries, and the machine specific
   arithmetic implementation.

   1) Compute a set of limb points on Phobos as seen from Mars. Perform
      a consistency check using the emission angle at each point,
      where the emission angle is computed using both a reference
      ellipsoid and the actual plate model surface and surface normal.
      We expect to see an emission angle of approximately 90 degrees.


      Use the meta-kernel shown below to load the required SPICE
      kernels.


         KPL/MK

         File: limb_pl02_ex1.tm

         This meta-kernel is intended to support operation of SPICE
         example programs. The kernels shown here should not be
         assumed to contain adequate or correct versions of data
         required by SPICE-based user applications.

         In order for an application to use this meta-kernel, the
         kernels referenced here must be present in the user's
         current working directory.

         The names and contents of the kernels referenced
         by this meta-kernel are as follows:

            File name                        Contents
            ---------                        --------
            mar097.bsp                       Mars satellite ephemeris
            pck00010.tpc                     Planet orientation and
                                             radii
            naif0010.tls                     Leapseconds


         \begindata

            KERNELS_TO_LOAD = ( 'mar097.bsp',
                                'pck00010.tpc',
                                'naif0010.tls' )
         \begintext

         End of meta-kernel


      Use the DSK kernel below to provide the plate model representation
      of the surface of Phobos.

         phobos_3_3.bds


      Example code begins here.


      /.
         Program limb_pl02_ex1
      ./
      #include &lt;stdio.h&gt;
      #include &lt;math.h&gt;
      #include &quot;SpiceUsr.h&quot;

      int main()
      {
         /.
         Prototypes
         ./
         void <b>limb_pl02</b> ( SpiceInt              handle,
                          ConstSpiceDLADescr  * dladsc,
                          ConstSpiceChar      * target,
                          SpiceDouble           et,
                          ConstSpiceChar      * fixref,
                          ConstSpiceChar      * abcorr,
                          ConstSpiceChar      * obsrvr,
                          SpiceInt              npts,
                          SpiceDouble         * trgepc,
                          SpiceDouble           obspos   [3],
                          SpiceDouble           lmbpts   [][3],
                          SpiceInt              pltids []     );

         /.
         Local parameters
         ./
         #define  FILSIZ         256
         #define  NPOINTS        3
         #define  NTYPES         2
         #define  TOL            ( 1.e-12 )
         #define  CORLEN         15
         #define  TYPLEN         81
         #define  TIMLEN         41

         /.
         Local variables
         ./
         SpiceBoolean            found;

         SpiceChar             * abcorr = &quot;LT+S&quot;;
         SpiceChar               dsk     [ FILSIZ  ];
         SpiceChar             * fixref = &quot;IAU_PHOBOS&quot;;
         SpiceChar               meta    [ FILSIZ  ];


         SpiceChar             * obsrvr = &quot;Mars&quot;;
         SpiceChar             * target = &quot;Phobos&quot;;
         SpiceChar             * utcstr = &quot;2007 FEB 9 00:00:00 UTC&quot;;
         SpiceChar               timstr  [ TIMLEN];

         SpiceDLADescr           dladsc;

         SpiceDouble             emissn;
         SpiceDouble             obspos    [3];
         SpiceDouble             phase;
         SpiceDouble             radius;
         SpiceDouble             solar;
         SpiceDouble             trgepc;
         SpiceDouble             et;
         SpiceDouble             lat;
         SpiceDouble             lon;
         SpiceDouble             lmbpts    [NPOINTS][3];

         SpiceInt                handle;
         SpiceInt                i;
         SpiceInt                pltids  [NPOINTS];

         /.
         Prompt for the name of a meta-kernel specifying
         all of the other kernels we need.  Load the
         metakernel.
         ./
         <a href="prompt_c.html">prompt_c</a> ( &quot;Enter meta-kernel name &gt; &quot;, FILSIZ, meta );
         <a href="furnsh_c.html">furnsh_c</a> ( meta );

         /.
         Prompt for the name of the DSK to read.
         ./
         <a href="prompt_c.html">prompt_c</a> ( &quot;Enter DSK name         &gt; &quot;, FILSIZ, dsk );

         /.
         Open the DSK file for read access.
         We use the DAS-level interface for
         this function.
         ./
         <a href="dasopr_c.html">dasopr_c</a> ( dsk, &amp;handle );

         /.
         Begin a forward search through the
         kernel, treating the file as a DLA.
         In this example, it's a very short
         search.
         ./
         <a href="dlabfs_c.html">dlabfs_c</a> ( handle, &amp;dladsc, &amp;found );

         if ( !found  )
         {
            /.
            We arrive here only if the kernel
            contains no segments.  This is
            unexpected, but we're prepared for it.
            ./
            <a href="setmsg_c.html">setmsg_c</a> ( &quot;No segments found in DSK file #.&quot;);
            <a href="errch_c.html">errch_c</a>  ( &quot;#&quot;,  dsk                         );
            <a href="sigerr_c.html">sigerr_c</a> ( &quot;SPICE(NODATA)&quot;                   );
         }

         /.
         If we made it this far, `dladsc' is the
         DLA descriptor of the first segment.

         Convert the observation time to seconds past J2000 TDB.
         ./
         <a href="str2et_c.html">str2et_c</a> ( utcstr, &amp;et );

         <a href="timout_c.html">timout_c</a> ( et,
                    &quot;YYYY-MON-DD &quot;
                    &quot;HR:MN:SC.### ::TDB(TDB)&quot;,
                    TIMLEN,
                    timstr                    );

         printf ( &quot;\n\n&quot;
                  &quot;   Observer:               %s\n&quot;
                  &quot;   Target:                 %s\n&quot;
                  &quot;   Observation epoch:      %s\n&quot;
                  &quot;   Aberration correction:  %s\n&quot;
                  &quot;   Body-fixed frame:       %s\n&quot;,
                  obsrvr,
                  target,
                  timstr,
                  abcorr,
                  fixref                            );

         /.
         Now compute grid of limb points.
         ./
         <b>limb_pl02</b> ( handle, &amp;dladsc,
                     target,  et,       fixref, abcorr,
                     obsrvr,  NPOINTS, &amp;trgepc, obspos,
                     lmbpts,  pltids                     );

         /.
         Display the limb points.
         ./
         for ( i = 0;  i &lt; NPOINTS;  i++  )
         {
            printf ( &quot;\n&quot; );

            <a href="reclat_c.html">reclat_c</a> ( lmbpts[i], &amp;radius, &amp;lon, &amp;lat );

            printf (
            &quot;      Limb point %d:\n&quot;
            &quot;         Radius                     (km): %f\n&quot;
            &quot;         Planetocentric longitude  (deg): %f\n&quot;
            &quot;         Planetocentric latitude   (deg): %f\n&quot;
            &quot;         Plate ID:                        %d\n&quot;,
            (int)i,
            radius,
            lon * <a href="dpr_c.html">dpr_c</a>(),
            lat * <a href="dpr_c.html">dpr_c</a>(),
            (int)pltids[i]                                );


            /.
            Compute the illumination angles using an ellipsoidal
            representation of the target's surface. The role of
            this representation is to provide an outward surface
            normal.
            ./
            <a href="illum_c.html">illum_c</a> ( target,  et,         abcorr,
                      obsrvr,  lmbpts[i],  &amp;phase,
                      &amp;solar,  &amp;emissn             );

            printf ( &quot;            emission angle derived using:\n&quot;
                     &quot;               - an ellipsoidal\n&quot;
                     &quot;                 reference surface (deg): %f\n&quot;,
                     emissn  * <a href="dpr_c.html">dpr_c</a>()                           );

            /.
            Compute the illumination angles at the limb point
            using the actual plate model surface normal.
            ./
            <a href="illum_pl02.html">illum_pl02</a> ( handle, &amp;dladsc, target,   et,
                         abcorr, obsrvr,  lmbpts[i],
                         &amp;phase, &amp;solar,  &amp;emissn      );

            printf ( &quot;               - plate model's surface\n&quot;
                     &quot;                 and normal vector (deg): %f\n&quot;,
                     emissn  * <a href="dpr_c.html">dpr_c</a>()                          );
         }

         printf ( &quot;\n&quot; );

         /.
         Close the kernel.  This isn't necessary in a stand-
         alone program, but it's good practice in subroutines
         because it frees program and system resources.
         ./
         <a href="dascls_c.html">dascls_c</a> ( handle );

         return ( 0 );
      }


      When this program was executed on a Mac/Intel/cc/64-bit
      platform, using the meta-kernel file named limb_pl02_ex1.tm
      and the DSK file named phobos_3_3.bds, the output was:


      Enter meta-kernel name &gt; limb_pl02_ex1.tm
      Enter DSK name         &gt; phobos_3_3.bds


         Observer:               Mars
         Target:                 Phobos
         Observation epoch:      2007-FEB-09 00:01:05.184 (TDB)
         Aberration correction:  LT+S
         Body-fixed frame:       IAU_PHOBOS

            Limb point 0:
               Radius                     (km): 11.563501
               Planetocentric longitude  (deg): 91.739066
               Planetocentric latitude   (deg): -0.000811
               Plate ID:                        229468
                  emission angle derived using:
                     - an ellipsoidal
                       reference surface (deg): 90.001006
                     - plate model's surface
                       and normal vector (deg): 110.821665

            Limb point 1:
               Radius                     (km): 9.537023
               Planetocentric longitude  (deg): -87.847223
               Planetocentric latitude   (deg): 59.998792
               Plate ID:                        235885
                  emission angle derived using:
                     - an ellipsoidal
                       reference surface (deg): 89.999961
                     - plate model's surface
                       and normal vector (deg): 97.681554

            Limb point 2:
               Radius                     (km): 9.046773
               Planetocentric longitude  (deg): -88.051727
               Planetocentric latitude   (deg): -59.997991
               Plate ID:                        17961
                  emission angle derived using:
                     - an ellipsoidal
                       reference surface (deg): 89.996966
                     - plate model's surface
                       and normal vector (deg): 64.808794
</PRE>
<h4><a name="Restrictions">Restrictions</a></h4>
<PRE>
   1)  The quality of the results produced by this routine depend on how
       well the target body's surface is approximated by the target's
       reference ellipsoid. This routine will *not* produce meaningful
       results for body shapes such as &quot;dumbbells.&quot;
</PRE>
<h4><a name="Literature_References">Literature_References</a></h4>
<PRE>
   None.
</PRE>
<h4><a name="Author_and_Institution">Author_and_Institution</a></h4>
<PRE>
   N.J. Bachman        (JPL)
   J. Diaz del Rio     (ODC Space)
   E.D. Wright         (JPL)
</PRE>
<h4><a name="Version">Version</a></h4>
<PRE>
   -CSPICE Version 2.1.0, 26-OCT-2021 (JDR)

       Changed the argument names &quot;npoints&quot;, &quot;limbpts&quot; and &quot;plateIDs&quot; to
       &quot;npts&quot;, &quot;lmbpts&quot; and &quot;pltids&quot; for consistency with other routines.

       Edited the header to comply with NAIF standard. Updated
       example code to reformat its output.

       Index lines now state that this routine is deprecated.

   -CSPICE Version 2.0.0, 23-JUL-2016 (NJB) (EDW)

       Added and moved <a href="failed_c.html">failed_c</a> calls.

       Include file references have been updated. Integer output
       format in the example program has been updated. Updated
       example program output to reflect bug fix of 29-APR-2014.

    Beta Version 3.0.0, 24-JUN-2014 (NJB) (EDW)

       Added <a href="failed_c.html">failed_c</a> checks to ensure return before
       performance of arithmetic computations using
       invalid operands. Added check for target equal
       to observer.

    Last update was 29-APR-2014 (NJB)

       Bug fix: corrected limb point selection so that
       points have uniform spacing in longitude, measured
       in a frame centered on the observer-target center
       line.

       Bug fix: added <a href="sigerr_c.html">sigerr_c</a> call in error handling
       branch for invalid value of `npts'.

       Bug fix: added check for body-fixed frame not
       centered on target.

       Bug fix: added error handling for null input string
       pointers and empty strings.

       Added check for mismatch between target and central
       body of DSK segment.

       Added test of <a href="failed_c.html">failed_c</a> after <a href="spkpos_c.html">spkpos_c</a> call.

       Changed argument name `fixfrm' to `fixref'.

       The target name to ID conversion is now performed
       in-line. The short error message for a failed
       conversion is not SPICE(IDCODENOTFOUND).

       Header correction: the error case of an unmapped
       observer name is now listed.


    Beta Version 2.1.0, 14-MAY-2010 (NJB)

       Updated header example. Added include statement
       for header pl02.h.

    Beta Version 2.0.0, 12-FEB-2010 (NJB)

       Updated to include

          SpiceDSK.h

    Beta Version 1.0.0, 27-FEB-2007 (NJB)
</PRE>
<h4><a name="Index_Entries">Index_Entries</a></h4>
<PRE>
   DEPRECATED find limb on plate model
   DEPRECATED find limb on triangular shape model
</PRE>
<h4>Link to routine limb_pl02 source file <a href='../../../src/cspice/limb_pl02.c'>limb_pl02.c</a> </h4>

      </td>
    </tr>
  </tbody>
</table>

   <pre>Fri Dec 31 18:41:09 2021</pre>

</body>
</html>

