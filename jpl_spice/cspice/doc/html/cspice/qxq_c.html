
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<HTML>

<HEAD>
   <TITLE>qxq_c</TITLE>
</HEAD>

<BODY style="color: rgb(0, 0, 0); background-color: rgb(255, 255, 255);">
<A name="TOP"></A>

<table style="text-align: left; margin-left: auto; margin-right: auto; width: 800px;"
 border="0" cellpadding="5" cellspacing="2">
  <tbody>
    <tr><td>
<div align="center">
Index of Functions: 
<A HREF="index.html#A">A</A>&nbsp;
<A HREF="index.html#B">B</A>&nbsp;
<A HREF="index.html#C">C</A>&nbsp;
<A HREF="index.html#D">D</A>&nbsp;
<A HREF="index.html#E">E</A>&nbsp;
<A HREF="index.html#F">F</A>&nbsp;
<A HREF="index.html#G">G</A>&nbsp;
<A HREF="index.html#H">H</A>&nbsp;
<A HREF="index.html#I">I</A>&nbsp;
<A HREF="index.html#J">J</A>&nbsp;
<A HREF="index.html#K">K</A>&nbsp;
<A HREF="index.html#L">L</A>&nbsp;
<A HREF="index.html#M">M</A>&nbsp;
<A HREF="index.html#N">N</A>&nbsp;
<A HREF="index.html#O">O</A>&nbsp;
<A HREF="index.html#P">P</A>&nbsp;
<A HREF="index.html#Q">Q</A>&nbsp;
<A HREF="index.html#R">R</A>&nbsp;
<A HREF="index.html#S">S</A>&nbsp;
<A HREF="index.html#T">T</A>&nbsp;
<A HREF="index.html#U">U</A>&nbsp;
<A HREF="index.html#V">V</A>&nbsp;
<A HREF="index.html#W">W</A>&nbsp;
<A HREF="index.html#X">X</A>&nbsp;
</div>
</td></tr>

    <tr>
      <td style="background-color: rgb(153, 153, 153); vertical-align: middle; text-align: center;">
      <div align="right"> 
      <small><small><a href="index.html">Index Page</a></small></small>
      </div>
      <b>qxq_c</b></td>
    </tr>
    

    <tr>
      <td style="vertical-align: top;">

       <br>
       <div align="left"><b>Table of contents</b></div>
       <table style="text-align: left; width: 60%; margin-left: auto; margin-right: auto;"
       border="0" cellspacing="2" cellpadding="2">
        <tbody>
          <tr>
            <td style="width: 33%; text-align: center;">
              <a href="#Procedure">Procedure<br></a>
              <a href="#Abstract">Abstract<br></a>
              <a href="#Required_Reading">Required_Reading<br></a>
              <a href="#Keywords">Keywords<br></a>
              <a href="#Brief_I/O">Brief_I/O<br></a>
              <a href="#Detailed_Input">Detailed_Input<br></a>

              </td>
              <td style="vertical-align: top; width: 33%; text-align: center;">              <a href="#Detailed_Output">Detailed_Output<br></a>
              <a href="#Parameters">Parameters<br></a>
              <a href="#Exceptions">Exceptions<br></a>
              <a href="#Files">Files<br></a>
              <a href="#Particulars">Particulars<br></a>
              <big><b><a href="#Examples">Examples<br></a></b></big>

              </td>
              <td style="vertical-align: top; width: 33%; text-align: center;">              <a href="#Restrictions">Restrictions<br></a>
              <a href="#Literature_References">Literature_References<br></a>
              <a href="#Author_and_Institution">Author_and_Institution<br></a>
              <a href="#Version">Version<br></a>
              <a href="#Index_Entries">Index_Entries<br></a>
            </td>
          </tr>
        </tbody>
</table>
<hr>

<h4><a name="Procedure">Procedure</a></h4>
<PRE>
   qxq_c ( Quaternion times quaternion ) 

   void qxq_c ( ConstSpiceDouble    q1   [4],
                ConstSpiceDouble    q2   [4],
                SpiceDouble         qout [4]  )

</PRE>
<h4><a name="Abstract">Abstract</a></h4>
<PRE>
   Multiply two quaternions.
</PRE>
<h4><a name="Required_Reading">Required_Reading</a></h4>
<PRE>
   <a href="../req/rotation.html">ROTATION</a>
</PRE>
<h4><a name="Keywords">Keywords</a></h4>
<PRE>
   MATH
   POINTING
   ROTATION


</PRE>
<h4><a name="Brief_I/O">Brief_I/O</a></h4>
<PRE>
   VARIABLE  I/O  DESCRIPTION
   --------  ---  --------------------------------------------------
   q1         I   First SPICE quaternion factor.
   q2         I   Second SPICE quaternion factor.
   qout       O   Product of `q1' and `q2'.
</PRE>
<h4><a name="Detailed_Input">Detailed_Input</a></h4>
<PRE>
   q1          is a 4-vector representing a SPICE-style quaternion.
               See the discussion of &quot;Quaternion Styles&quot; in the
               -Particulars section below.

               Note that multiple styles of quaternions are in use.
               This routine will not work properly if the input
               quaternions do not conform to the SPICE convention.

   q2          is a second SPICE-style quaternion.
</PRE>
<h4><a name="Detailed_Output">Detailed_Output</a></h4>
<PRE>
   qout        is 4-vector representing the quaternion product

                  q1 * q2

               Representing q(i) as the sums of scalar (real)
               part s(i) and vector (imaginary) part v(i)
               respectively,

                  q1 = s1 + v1
                  q2 = s2 + v2

               qout has scalar part s3 defined by

                  s3 = s1 * s2 - &lt;v1, v2&gt;

               and vector part v3 defined by

                  v3 = s1 * v2  +  s2 * v1  +  v1 x v2

               where the notation &lt; , &gt; denotes the inner
               product operator and x indicates the cross
               product operator.
</PRE>
<h4><a name="Parameters">Parameters</a></h4>
<PRE>
   None.
</PRE>
<h4><a name="Exceptions">Exceptions</a></h4>
<PRE>
   Error free.
</PRE>
<h4><a name="Files">Files</a></h4>
<PRE>
   None.
</PRE>
<h4><a name="Particulars">Particulars</a></h4>
<PRE>
   Quaternion Styles
   -----------------

   There are different &quot;styles&quot; of quaternions used in
   science and engineering applications. Quaternion styles
   are characterized by

   -  The order of quaternion elements

   -  The quaternion multiplication formula

   -  The convention for associating quaternions
      with rotation matrices

   Two of the commonly used styles are

      - &quot;SPICE&quot;

         &gt; Invented by Sir William Rowan Hamilton
         &gt; Frequently used in mathematics and physics textbooks

      - &quot;Engineering&quot;

         &gt; Widely used in aerospace engineering applications


   CSPICE function interfaces ALWAYS use SPICE quaternions.
   Quaternions of any other style must be converted to SPICE
   quaternions before they are passed to CSPICE functions.


   Relationship between SPICE and Engineering Quaternions
   ------------------------------------------------------

   Let `m' be a rotation matrix such that for any vector `v',

      m*v

   is the result of rotating `v' by theta radians in the
   counterclockwise direction about unit rotation axis vector `a'.
   Then the SPICE quaternions representing `m' are

      (+/-) (  cos(theta/2),
               sin(theta/2) * a(0),
               sin(theta/2) * a(1),
               sin(theta/2) * a(2)  )

   while the engineering quaternions representing `m' are

      (+/-) ( -sin(theta/2) * a(0),
              -sin(theta/2) * a(1),
              -sin(theta/2) * a(2),
               cos(theta/2)         )

   For both styles of quaternions, if a quaternion `q' represents
   a rotation matrix `m', then -q represents `m' as well.

   Given an engineering quaternion

      qeng   = ( q0,  q1,  q2,  q3 )

   the equivalent SPICE quaternion is

      qspice = ( q3, -q0, -q1, -q2 )


   Associating SPICE Quaternions with Rotation Matrices
   ----------------------------------------------------

   Let `from' and `to' be two right-handed reference frames, for
   example, an inertial frame and a spacecraft-fixed frame. Let the
   symbols

      v    ,   v
       from     to

   denote, respectively, an arbitrary vector expressed relative to
   the `from' and `to' frames. Let `m' denote the transformation matrix
   that transforms vectors from frame `from' to frame `to'; then

      v   =  m * v
       to         from

   where the expression on the right hand side represents left
   multiplication of the vector by the matrix.

   Then if the unit-length SPICE quaternion `q' represents `m', where

      q = (q0, q1, q2, q3)

   the elements of `m' are derived from the elements of `q' as follows:

        .-                                                           -.
        |            2    2                                           |
        |  1 - 2*( q2 + q3 )   2*(q1*q2 - q0*q3)   2*(q1*q3 + q0*q2)  |
        |                                                             |
        |                                                             |
        |                                2    2                       |
    m = |  2*(q1*q2 + q0*q3)   1 - 2*( q1 + q3 )   2*(q2*q3 - q0*q1)  |
        |                                                             |
        |                                                             |
        |                                                    2    2   |
        |  2*(q1*q3 - q0*q2)   2*(q2*q3 + q0*q1)   1 - 2*( q1 + q2 )  |
        |                                                             |
        `-                                                           -'

   Note that substituting the elements of -q for those of `q' in the
   right hand side leaves each element of `m' unchanged; this shows
   that if a quaternion `q' represents a matrix `m', then so does the
   quaternion -q.

   To map the rotation matrix `m' to a unit quaternion, we start by
   decomposing the rotation matrix as a sum of symmetric
   and skew-symmetric parts:

                                        2
      m = [ I  +  (1-cos(theta)) * omega  ] + [ sin(theta) * omega ]

                       symmetric                 skew-symmetric


   `omega' is a skew-symmetric matrix of the form

                 .-               -.
                 |   0   -n2   n1  |
                 |                 |
       omega  =  |   n2   0   -n0  |
                 |                 |
                 |  -n1   n0   0   |
                 `-               -'

   The vector `n' of matrix entries (n0, n1, n2) is the rotation axis
   of `m' and `theta' is m's rotation angle. Note that `n' and `theta'
   are not unique.

   Let

      cth = cos(theta/2)
      sth = sin(theta/2)

   Then the unit quaternions `q' corresponding to `m' are

      q = +/- ( cth, sth*n0, sth*n1, sth*n2 )

   The mappings between quaternions and the corresponding rotations
   are carried out by the CSPICE routines

      <a href="q2m_c.html">q2m_c</a> {quaternion to matrix}
      <a href="m2q_c.html">m2q_c</a> {matrix to quaternion}

   <a href="m2q_c.html">m2q_c</a> always returns a quaternion with scalar part greater than
   or equal to zero.


   SPICE Quaternion Multiplication Formula
   ---------------------------------------

   Given a SPICE quaternion

      q = ( q0, q1, q2, q3 )

   corresponding to rotation axis `a' and angle `theta' as above, we can
   represent `q' using &quot;scalar + vector&quot; notation as follows:

      s =   q0           = cos(theta/2)

      v = ( q1, q2, q3 ) = sin(theta/2) * a

      q = s + v

   Let `quat1' and `quat2' be SPICE quaternions with respective scalar
   and vector parts `s1', `s2' and `v1', `v2':

      quat1 = s1 + v1
      quat2 = s2 + v2

   We represent the dot product of `v1' and `v2' by

      &lt;v1, v2&gt;

   and the cross product of `v1' and `v2' by

      v1 x v2

   Then the SPICE quaternion product is

      quat1*quat2 = s1*s2 - &lt;v1,v2&gt;  + s1*v2 + s2*v1 + (v1 x v2)

   If `quat1' and `quat2' represent the rotation matrices `m1' and `m2'
   respectively, then the quaternion product

      quat1*quat1

   represents the matrix product

      m1*m2
</PRE>
<h4><a name="Examples">Examples</a></h4>
<PRE>
   The numerical results shown for these examples may differ across
   platforms. The results depend on the SPICE kernels used as
   input, the compiler and supporting libraries, and the machine
   specific arithmetic implementation.

   1) Given the &quot;basis&quot; quaternions:

         qid:  ( 1.0, 0.0, 0.0, 0.0 )
         qi :  ( 0.0, 1.0, 0.0, 0.0 )
         qj :  ( 0.0, 0.0, 1.0, 0.0 )
         qk :  ( 0.0, 0.0, 0.0, 1.0 )

      the following quaternion products give these results:

          Product       Expected result
         -----------   ----------------------
          qi  * qj     ( 0.0, 0.0, 0.0, 1.0 )
          qj  * qk     ( 0.0, 1.0, 0.0, 0.0 )
          qk  * qi     ( 0.0, 0.0, 1.0, 0.0 )
          qi  * qi     (-1.0, 0.0, 0.0, 0.0 )
          qj  * qj     (-1.0, 0.0, 0.0, 0.0 )
          qk  * qk     (-1.0, 0.0, 0.0, 0.0 )
          qid * qi     ( 0.0, 1.0, 0.0, 0.0 )
          qi  * qid    ( 0.0, 1.0, 0.0, 0.0 )
          qid * qj     ( 0.0, 0.0, 1.0, 0.0 )

      The following code example uses QXQ to produce these results.


      Example code begins here.


      /.
         Program qxq_ex1
      ./
      #include &lt;stdio.h&gt;
      #include &quot;SpiceUsr.h&quot;

      int main( )
      {

         /.
         Local variables
         ./
         SpiceDouble          qout   [4];

         /.
         Let `qid', `qi', `qj', `qk' be the &quot;basis&quot;
         quaternions.
         ./
         SpiceDouble          qid    [4] = { 1.0,  0.0,  0.0,  0.0 };
         SpiceDouble          qi     [4] = { 0.0,  1.0,  0.0,  0.0 };
         SpiceDouble          qj     [4] = { 0.0,  0.0,  1.0,  0.0 };
         SpiceDouble          qk     [4] = { 0.0,  0.0,  0.0,  1.0 };

         /.
         Compute:

            qi x qj = qk
            qj x qk = qi
            qk x qi = qj
         ./
         <b>qxq_c</b> ( qi, qj, qout );
         printf( &quot;qi x qj  = %7.1f %7.1f %7.1f %7.1f\n&quot;,
                             qout[0], qout[1], qout[2], qout[3] );
         printf( &quot;     qk  = %7.1f %7.1f %7.1f %7.1f\n&quot;,
                             qk[0],   qk[1],   qk[2],   qk[3]   );
         printf( &quot; \n&quot; );

         <b>qxq_c</b> ( qj, qk, qout );
         printf( &quot;qj x qk  = %7.1f %7.1f %7.1f %7.1f\n&quot;,
                             qout[0], qout[1], qout[2], qout[3] );
         printf( &quot;     qi  = %7.1f %7.1f %7.1f %7.1f\n&quot;,
                             qi[0],   qi[1],   qi[2],   qi[3]   );
         printf( &quot; \n&quot; );

         <b>qxq_c</b> ( qk, qi, qout );
         printf( &quot;qk x qi  = %7.1f %7.1f %7.1f %7.1f\n&quot;,
                             qout[0], qout[1], qout[2], qout[3] );
         printf( &quot;     qj  = %7.1f %7.1f %7.1f %7.1f\n&quot;,
                             qj[0],   qj[1],   qj[2],   qj[3]   );
         printf( &quot; \n&quot; );

         /.
         Compute:

            qi x qi  ==  -qid
            qj x qj  ==  -qid
            qk x qk  ==  -qid
         ./
         <b>qxq_c</b> ( qi, qi, qout );
         printf( &quot;qi x qi  = %7.1f %7.1f %7.1f %7.1f\n&quot;,
                             qout[0], qout[1], qout[2], qout[3] );
         printf( &quot;     qid = %7.1f %7.1f %7.1f %7.1f\n&quot;,
                             qid[0],   qid[1],  qid[2],  qid[3] );
         printf( &quot; \n&quot; );

         <b>qxq_c</b> ( qj, qj, qout );
         printf( &quot;qj x qj  = %7.1f %7.1f %7.1f %7.1f\n&quot;,
                             qout[0], qout[1], qout[2], qout[3] );
         printf( &quot;     qid = %7.1f %7.1f %7.1f %7.1f\n&quot;,
                             qid[0],   qid[1],  qid[2],  qid[3] );
         printf( &quot; \n&quot; );

         <b>qxq_c</b> ( qk, qk, qout );
         printf( &quot;qk x qk  = %7.1f %7.1f %7.1f %7.1f\n&quot;,
                             qout[0], qout[1], qout[2], qout[3] );
         printf( &quot;     qid = %7.1f %7.1f %7.1f %7.1f\n&quot;,
                             qid[0],   qid[1],  qid[2],  qid[3] );
         printf( &quot; \n&quot; );

         /.
         Compute:

            qid x qi  = qi
            qi  x qid = qi
            qid x qj  = qj
         ./
         <b>qxq_c</b> ( qid, qi, qout );
         printf( &quot;qid x qi = %7.1f %7.1f %7.1f %7.1f\n&quot;,
                             qout[0], qout[1], qout[2], qout[3] );
         printf( &quot;      qi = %7.1f %7.1f %7.1f %7.1f\n&quot;,
                             qi[0],   qi[1],   qi[2],   qi[3]   );
         printf( &quot; \n&quot; );

         <b>qxq_c</b> ( qi, qid, qout );
         printf( &quot;qi x qid = %7.1f %7.1f %7.1f %7.1f\n&quot;,
                             qout[0], qout[1], qout[2], qout[3] );
         printf( &quot;      qi = %7.1f %7.1f %7.1f %7.1f\n&quot;,
                             qi[0],   qi[1],   qi[2],   qi[3]   );
         printf( &quot; \n&quot; );

         <b>qxq_c</b> ( qid, qj, qout );
         printf( &quot;qid x qj = %7.1f %7.1f %7.1f %7.1f\n&quot;,
                             qout[0], qout[1], qout[2], qout[3] );
         printf( &quot;      qj = %7.1f %7.1f %7.1f %7.1f\n&quot;,
                             qj[0],   qj[1],   qj[2],   qj[3]   );
         printf( &quot; \n&quot; );

         return ( 0 );
      }


      When this program was executed on a Mac/Intel/cc/64-bit
      platform, the output was:


      qi x qj  =     0.0     0.0     0.0     1.0
           qk  =     0.0     0.0     0.0     1.0

      qj x qk  =     0.0     1.0     0.0     0.0
           qi  =     0.0     1.0     0.0     0.0

      qk x qi  =     0.0     0.0     1.0     0.0
           qj  =     0.0     0.0     1.0     0.0

      qi x qi  =    -1.0     0.0     0.0     0.0
           qid =     1.0     0.0     0.0     0.0

      qj x qj  =    -1.0     0.0     0.0     0.0
           qid =     1.0     0.0     0.0     0.0

      qk x qk  =    -1.0     0.0     0.0     0.0
           qid =     1.0     0.0     0.0     0.0

      qid x qi =     0.0     1.0     0.0     0.0
            qi =     0.0     1.0     0.0     0.0

      qi x qid =     0.0     1.0     0.0     0.0
            qi =     0.0     1.0     0.0     0.0

      qid x qj =     0.0     0.0     1.0     0.0
            qj =     0.0     0.0     1.0     0.0


   2) Compute the composition of two rotation matrices by
      converting them to quaternions and computing their
      product, and by directly multiplying the matrices.

      Example code begins here.


      /.
         Program qxq_ex2
      ./
      #include &lt;stdio.h&gt;
      #include &quot;SpiceUsr.h&quot;

      int main( )
      {

         /.
         Local variables
         ./
         SpiceDouble          cmout  [3][3];
         SpiceDouble          q1     [4];
         SpiceDouble          q2     [4];
         SpiceDouble          qout   [4];

         SpiceDouble          cmat1  [3][3] = { {1.0,  0.0,  0.0},
                                                {0.0, -1.0,  0.0},
                                                {0.0,  0.0, -1.0} };

         SpiceDouble          cmat2  [3][3] = { {0.0,  1.0,  0.0},
                                                {1.0,  0.0,  0.0},
                                                {0.0,  0.0, -1.0} };

         /.
         Convert the C-matrices to quaternions.
         ./
         <a href="m2q_c.html">m2q_c</a> ( cmat1, q1 );
         <a href="m2q_c.html">m2q_c</a> ( cmat2, q2 );

         /.
         Find the product.
         ./
         <b>qxq_c</b> ( q1, q2, qout );

         /.
         Convert the result to a C-matrix.
         ./
         <a href="q2m_c.html">q2m_c</a> ( qout, cmout );

         printf( &quot;Using quaternion product:\n&quot; );
         printf( &quot;%9.4f %9.4f %9.4f\n&quot;,
                 cmout[0][0], cmout[0][1], cmout[0][2] );
         printf( &quot;%9.4f %9.4f %9.4f\n&quot;,
                 cmout[1][0], cmout[1][1], cmout[1][2] );
         printf( &quot;%9.4f %9.4f %9.4f\n&quot;,
                 cmout[2][0], cmout[2][1], cmout[2][2] );

         /.
         Multiply `cmat1' and `cmat2' directly.
         ./
         <a href="mxm_c.html">mxm_c</a> ( cmat1, cmat2, cmout );

         printf( &quot;Using matrix product:\n&quot; );
         printf( &quot;%9.4f %9.4f %9.4f\n&quot;,
                 cmout[0][0], cmout[0][1], cmout[0][2] );
         printf( &quot;%9.4f %9.4f %9.4f\n&quot;,
                 cmout[1][0], cmout[1][1], cmout[1][2] );
         printf( &quot;%9.4f %9.4f %9.4f\n&quot;,
                 cmout[2][0], cmout[2][1], cmout[2][2] );

         return ( 0 );
      }


      When this program was executed on a Mac/Intel/cc/64-bit
      platform, the output was:


      Using quaternion product:
         0.0000    1.0000    0.0000
        -1.0000    0.0000    0.0000
         0.0000    0.0000    1.0000
      Using matrix product:
         0.0000    1.0000    0.0000
        -1.0000    0.0000    0.0000
         0.0000    0.0000    1.0000
</PRE>
<h4><a name="Restrictions">Restrictions</a></h4>
<PRE>
   None.
</PRE>
<h4><a name="Literature_References">Literature_References</a></h4>
<PRE>
   None.
</PRE>
<h4><a name="Author_and_Institution">Author_and_Institution</a></h4>
<PRE>
   N.J. Bachman        (JPL)
   J. Diaz del Rio     (ODC Space)
</PRE>
<h4><a name="Version">Version</a></h4>
<PRE>
   -CSPICE Version 1.0.2, 10-AUG-2021 (JDR)

       Edited the header to comply with NAIF standard.

       Created complete code examples from existing example and code
       fragments.

   -CSPICE Version 1.0.1, 27-FEB-2008 (NJB)

       Updated header; added information about SPICE
       quaternion conventions.

   -CSPICE Version 1.0.0, 27-OCT-2005 (NJB)
</PRE>
<h4><a name="Index_Entries">Index_Entries</a></h4>
<PRE>
   quaternion times quaternion
   multiply quaternion by quaternion
</PRE>
<h4>Link to routine qxq_c source file <a href='../../../src/cspice/qxq_c.c'>qxq_c.c</a> </h4>

      </td>
    </tr>
  </tbody>
</table>

   <pre>Fri Dec 31 18:41:11 2021</pre>

</body>
</html>

